{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftvertechnik\u00e1k (2024-t\u0151l)","text":"<p>Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz, 2024 \u00e9vt\u0151l kezd\u0151d\u0151en. A kor\u00e1bbi \u00e9vek anyag\u00e1nak megtekint\u00e9s\u00e9hez az oldal fejl\u00e9c\u00e9ben tal\u00e1lhat\u00f3 leny\u00edl\u00f3 mez\u0151ben a megfelel\u0151 \u00e9vet kell kiv\u00e1lasztani (pl. \"2023-ig\").</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3d\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-osztaly","title":"Absztrakt oszt\u00e1ly","text":"<p>A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.:</p> <pre><code>abstract class Shape { \u2026 }\n</code></pre> <p>Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni:</p> <pre><code>\u2026\nabstract void Draw();\n\u2026\n</code></pre> <p>Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet:</p> <ul> <li>Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t.</li> <li>Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k).</li> </ul> <p>.NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz","title":"Interf\u00e9sz","text":"<p>Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt.</p> <p>C# nyelven az <code>interface</code> kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni:</p> <pre><code>public interface ISerializable \n{\n   void WriteToStream(Stream s);\n   void LoadFromStream(Stream s);\n}\n\npublic interface IComparable \n{\n   int CompareTo(Object obj);\n}\n</code></pre> <p>M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n    \u2026\n}\n</code></pre> <p>Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az <code>ISerializable</code> \u00e9s <code>IComparable</code> interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t. Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt.</p> <p>Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g:</p> <ul> <li>A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni.</li> <li>Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani). Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-os-es-interfesz-osszehasonlitasa","title":"Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa","text":"<p>Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat.</p> <p>Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet.</p> <p>Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1. Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent.</p> <p>\u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja. B\u0151vebben inform\u00e1ci\u00f3 itt:  default interface methods.</p> <p>Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/","title":"Interface and abstract (base) class","text":"<p>Last modified date: 2022.10.15 Edited by Zolt\u00e1n Benedek</p> <p>The chapter does not contain an exercise, it introduces the related theory to students.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#abstract-class","title":"Abstract class","text":"<p>The concepts have been covered in previous topics, so for now we will just summarize the most important ones and focus on the C# aspect. Abstract class A class that cannot be instantiated. In C#, in the class definition, the abstract keyword must be written out, e.g.:</p> <pre><code>abstract class Shape { ... }\n</code></pre> <p>Abstract classes may have abstract methods that do not have a root, and for these abstract methods the abstract keyword should be used:</p> <pre><code>...\nabstract void Draw();\n...\n</code></pre> <p>There are two purposes for using abstract classes:</p> <ul> <li>In a class hierarchy, we can map code common to descendants into an abstract common base class, thus avoiding code duplication.</li> <li>We can uniformly refer to descendants as abstract base classes (e.g. heterogeneous collections).</li> </ul> <p>in .NET, as in Java, a class can have only one base class class.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#interface","title":"Interface","text":"<p>An interface is nothing more than a set of operations. In fact, it corresponds to an abstract class whose all operations are abstract.</p> <p>In C# you can define an interface with the <code>interface</code> keyword:</p> <pre><code>public interface ISerializable \n{\n   void WriteToStream(Stream s);\n   void LoadFromStream(Stream s);\n}\n\npublic interface IComparable \n{\n   int CompareTo(Object obj);\n}\n</code></pre> <p>While a class can have only one base class, it can implement any number of interfaces:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n    ...\n}\n</code></pre> <p>In this example, the Rect class is derived from the Shape class and implements the <code>ISerializable</code> and <code>IComparable</code> interfaces (mandatory to specify the base class first). In a class implementing an interface, all its operations must be implemented, i.e., its trunk must be written (except in the rare case where it is implemented by an abstract operation). There is one main purpose for using interfaces. Referenced as an interface, we can uniformly manage all the classes that implement the interface (e.g., a heterogeneous collection). One consequence of this is that interfaces allow us to write classes and functions that can be used in a wide variety of ways. For example, we can write a universal Sort ordering function that can be used with any class that implements the IComparable interface.</p> <p>Other benefits of using the interface include:</p> <ul> <li>The client only needs to know the interface of the server object to be able to use the server easily.</li> <li>If the client only uses the server through the interface, so the internal implementation of the server may change, the client does not need to be modified (nor recompiled). Accordingly, the interface is also a contract between the server and the client: as long as the server guarantees support for the interface, the client does not need to change.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#comparison-of-abstract-base-class-and-interface","title":"Comparison of abstract base class and interface","text":"<p>The advantage of the abstract base class over the interface is that you can specify a default implementation for the operations and include member variables.</p> <p>The advantage of interfaces over abstract ancestors is that a class can implement any number of interfaces, while its base class can implement at most one.</p> <p>There is another consequence of using interfaces, which can cause inconvenience in some cases. When a new operation is added to the interface, all implementing classes must also be extended, otherwise the code will not compile. This is not the case when extending an abstract base class: if you add a new operation, you have the option to add it as a virtual function, and thus give it a default implementation in the ancestor. In this case, the descendants can redefine this as they wish, they are not forced to do so. This feature of interfaces can be particularly inconvenient for class libraries/framework systems. Suppose a new version of .NET is released and a new operation is added to one of the interfaces of the framework. All implementing classes in all applications must then be modified, otherwise the code will not compile. There are two ways to avoid this. Either by using a legacy class, or, if an interface should be extended, by introducing a new interface that already contains the new operation. Although the first approach (using an base class class) seems more attractive at first sight, it also has a drawback: if you derive from an ancestor in the framework when developing your application, your class can have no other ancestor, and this is a painful constraint in many cases.</p> <p>It's worth knowing that starting from C# 8 (or .NET or .NET Core runtime, not supported under .NET Framework), interface operations can be given a default implementation (default interface methods), so no abstract class is needed to solve the above problem, but an interface can no longer have a member variable. More information here: default interface methods.</p> <p>Since using both interfaces and abstract classes can have negative consequences, in many cases we can get the most out of our solution by using both (i.e., our code can be easily extended with no or minimal code duplication).</p>"},{"location":"egyeb/uml-kod-kapcsolata/","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3d\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#bevezeto","title":"Bevezet\u0151","text":"<p>A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt.</p> <p>Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt.</p> <p>Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#fogalmak","title":"Fogalmak","text":"<ul> <li>Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni.</li> <li>Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti.</li> <li>Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban.</li> </ul> <p>Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni.</p> <p>A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#osztalyok-lekepezese","title":"Oszt\u00e1lyok lek\u00e9pez\u00e9se","text":"<p>Mondhatni trivi\u00e1lisan egyszer\u0171:</p> <ul> <li>UML oszt\u00e1ly -&gt; oszt\u00e1ly</li> <li>UML attrib\u00fatum -&gt; tagv\u00e1ltoz\u00f3</li> <li>UML m\u0171velet -&gt; m\u0171velet/met\u00f3dus</li> </ul> <p>Egy p\u00e9lda:</p> <p></p> <p>, mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven:</p> <pre><code>public abstract class Shape\n{\n    private int x;\n    private int y;\n    public Shape(int x, int y) { this.x = x; this.y = y; }\n    public abstract void Draw(Graphics gr);\n}\n</code></pre> <p>A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s:</p> <ul> <li>+: public</li> <li>-: private</li> <li>#: protected</li> </ul> <p>Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#i-altalanositas-specializacio-kapcsolat","title":"I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat","text":"<p>C# lek\u00e9pez\u00e9s:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#ii-asszociacio","title":"II. Asszoci\u00e1ci\u00f3","text":"<p>Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#a-lekepezes-01-multiplicitasu-asszociacios-kapcsolat-eseten","title":"A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda:</p> <p></p> <p>C++ lek\u00e9pez\u00e9s:</p> <pre><code>class Application\n{\n   WindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k):</p> <pre><code>class Application\n{\n   WindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role), mely a p\u00e9ld\u00e1ban a <code>windowManager</code>. A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni.</p> <p>Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#b-lekepezes-0n-multiplicitasu-asszociacios-kapcsolat-eseten","title":"B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda:</p> <p></p> <p>Egy <code>WindowManager</code> objektum t\u00f6bb <code>Window</code> objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel.</p> <p>Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven:</p> <pre><code>class WindowManager\n{\n  vector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Illetve C# nyelven:</p> <pre><code>class WindowManager\n{\n  List&lt;Window&gt; windows; \n};\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#iii-aggregacio-tartalmazas-resz-egesz-viszony","title":"III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony)","text":"<p>\u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#iv-fuggoseg-dependency","title":"IV. F\u00fcgg\u0151s\u00e9g (dependency)","text":"<p>A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda:</p> <p></p> <p>A jelent\u00e9se: a <code>Window</code> oszt\u00e1ly f\u00fcgg a <code>Graphics</code> oszt\u00e1lyt\u00f3l. Vagyis, ha a <code>Graphics</code> oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a <code>Window</code> oszt\u00e1ly <code>onDraw</code> m\u0171velete param\u00e9terk\u00e9nt megkapja a <code>Graphics</code> oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a <code>Graphics</code> oszt\u00e1ly met\u00f3dusait. Ha pl. a <code>Graphics</code> oszt\u00e1ly <code>FillRect</code> met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a <code>Window</code> oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/","title":"Theory of the relationship between the UML class diagram and code","text":"<p>Last modified date: 2022.10.15 Edited by Zolt\u00e1n Benedek</p> <p>The chapter does not contain an exercise, it introduces the related theory to students.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#introduction","title":"Introduction","text":"<p>The chapter gives a brief, sketchy overview of the basics of mapping between the UML class diagram and the source code, as a review of what has already been learned in Software Engineering in the previous semester.</p> <p>Today, there are many software development methodologies. They rely on, or require, modelling to varying degrees in the construction of the software. However, there is no doubt that even the most agile, \"code-centric\" followers of the most \"code-centric\" approaches find it useful to visually model the more important/complex components and structural elements of software, because of the greater expressive power of the graphical nature of the software.</p> <p>Let's say you have to build an application or a specific module of an application. Following our chosen methodology, we will cover the steps of requirements analysis, analysis, design, implementation and testing, probably in several iterations. Let's now focus on the design phase. This will result in a detailed design of the system (at least parts of it), resulting in a detailed/implementation plan or model. At this level, certain elements of the model (e.g. classes) can be explicitly mapped to elements of the programming language chosen to implement the subsystem. If you have a good development/modeling tool, it can generate the class skeleton (e.g. C++, Java, C# classes). Our task is then to fill in the root of the methods in the generated code.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#concepts","title":"Concepts","text":"<ul> <li>Forward engineering: generating code from a model. From the detailed plan, the modelling tool can generate the program framework. The advantage is that less coding is needed.</li> <li>Reverse engineering: generating a model from code. It helps you understand the code you already have.</li> <li>Round-trip engineering: a combination of the previous two. The point is: the model and the code are in sync all the time. If you change the code, the change appears in the model, if you change the model, the change appears in the code.</li> </ul> <p>In order to take advantage of code generation, you need to be aware of the following: you need to know how a given modelling tool maps each model element to elements of a given programming language. The mapping depends on the language and the modelling tool, there is no universal standard. The mappings are usually self-explanatory, there is not usually too much variation.</p> <p>In the following we will look at how each model element of the UML class diagram is mapped to source code, and vice versa.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#mapping-of-classes","title":"Mapping of classes","text":"<p>It's trivially simple:</p> <ul> <li>UML class -&gt; class</li> <li>UML attribute -&gt; member variable</li> <li>UML operation -&gt; operation/method</li> </ul> <p>An example:</p> <p>Shape class</p> <p>, which corresponds to the following code in C#:</p> <pre><code>public abstract class Shape\n{\n    private int x;\n    private int y;\n    public Shape(int x, int y) { this.x = x; this.y = y; }\n    public abstract void Draw(Graphics gr);\n}\n</code></pre> <p>In the context of visibility, mapping:</p> <ul> <li>+: public</li> <li>-: private</li> <li>#: protected</li> </ul> <p>A more exciting question is how the relationships between classes are mapped, and this is discussed in the following chapters.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#i-generalisation-specialisation-link","title":"I. Generalisation, specialisation link","text":"<p>Generalisation, specialisation</p> <p>C# mapping:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#ii-association","title":"II. Association","text":"<p>This relationship type always implies communication between objects of classes. A department uses the services of another department.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#a-building-a-01-multiplicity-association-relation","title":"A) Building a 0..1 multiplicity association relation","text":"<p>In this case, the client class contains a pointer or reference through which it can use the services of the target class (call its operations). Example:</p> <p>Generalisation, specialisation, single contact</p> <p>C++ mapping:</p> <pre><code>class Application\n{\n   WindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C# mapping (no pointers, only references):</p> <pre><code>class Application\n{\n   WindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>In both cases, we see that a pointer or reference member variable is added to the client class, whose type is the same as the type of the target class referenced in the association, and the name of the member variable is the role given to the target class for the association relationship, which in the example is . The mapping is logical, since the client can access the target object from any of its operations and call its methods through this pointer/reference.</p> <p>Comment. Sometimes the association is two-way, with each class using the services of the other. Often, instead of putting an arrow at both ends of the association, we leave it at both ends. In such a two-way relationship, the role must be specified at both ends of the relationship. During the mapping, we add a pointer/reference to each class to the other.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#b-derivation-for-an-association-relation-with-multiplicity-0n","title":"B) Derivation for an association relation with multiplicity 0..n","text":"<p>In this case, a client-side object is related to several target-side objects. Example:</p> <p>Generalisation, specialisation, multiple links</p> <p>One <code>WindowManager</code> object manages several <code>Window</code> objects. The mapping takes some collection of objects in the target class into the client class. This can be an array, list, etc., whichever best suits our purpose in the situation.</p> <p>A mapping to the above example in C++:</p> <pre><code>class WindowManager\n{\n  vector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Or in C#:</p> <pre><code>class WindowManager\n{\n  List&lt;Window&gt; windows; \n};\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#iii-aggregation-inclusion-part-part-relationship","title":"III. Aggregation (inclusion, part-part relationship)","text":"<p>In general, the mapping is exactly the same as for association.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#iv-dependency-dependency","title":"IV. Dependency (dependency)","text":"<p>It represents the loosest link between departments. Example:</p> <p>Dependency</p> <p>Meaning: the <code>Window</code> class depends on the <code>Graphics</code> class. That is, if the <code>Graphics</code> class is changed, the Window class may also need to be changed. This connection type is used when the parameter list/return value of the methods of the class at the beginning of the dependency connection contains the class at the end of the connection. In the example, the <code>onDraw</code> operation of the <code>Window</code> class receives an object of the <code>Graphics</code> class as a parameter, and thus depends on it, since it can call the methods of the <code>Graphics</code> class in the method's trunk. If, for example, the name of the <code>FillRect</code> method of the <code>Graphics</code> class is changed, this change must be reflected in the call location, i.e., in the trunk of the <code>onDraw</code> method of the Window class.</p>"},{"location":"hazi/","title":"\u00d6n\u00e1ll\u00f3/h\u00e1zi feladatok","text":"<p>Valamennyi h\u00e1zi feladat elk\u00e9sz\u00edt\u00e9se k\u00f6telez\u0151. A megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik (b\u0151vebben itt). Az \u00f6n\u00e1ll\u00f3/h\u00e1zi feladatokra vonatkoz\u00f3 pontos k\u00f6vetelm\u00e9nyek Moodle-ben, a T\u00e1rgyk\u00f6vetelm\u00e9nyek alatt olvashat\u00f3k (\"\u00d6n\u00e1ll\u00f3/h\u00e1zi feladatok\" fejezet).</p>"},{"location":"hazi/#a-feladatok","title":"A feladatok","text":"<ul> <li>1. HF - A modell \u00e9s a k\u00f3d kapcsolata</li> <li>2. HF - Nyelvi eszk\u00f6z\u00f6k</li> <li>3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa</li> <li>4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se</li> <li>5. HF - ? Tervez\u00e9si mint\u00e1k ?</li> <li>6. HF - ? MVVM ?</li> </ul>"},{"location":"hazi/#a-feladatok-beadasa","title":"A feladatok bead\u00e1sa","text":"<p>Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt. K\u00e9r\u00fcnk, alaposan olvasd v\u00e9gig a le\u00edr\u00e1st!</p> <p>FONTOS</p> <p>A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zi feladatokat nem \u00e9rt\u00e9kelj\u00fck.</p> <p>Bizonyos h\u00e1zi feladatokhoz automata el\u0151ellen\u0151rz\u0151 is tartozik, err\u0151l itt olvashatsz b\u0151vebben.</p>"},{"location":"hazi/#kepernyokepek","title":"K\u00e9perny\u0151k\u00e9pek","text":"<p>Bizonyos h\u00e1zi feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi.</p> <p>A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, \u00edgy felker\u00fclnek a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</p>"},{"location":"hazi/#szukseges-eszkozok","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k","text":"<p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezet alapvet\u0151en a Visual Studio 2022, err\u0151l itt tal\u00e1lhat\u00f3 b\u0151vebb le\u00edr\u00e1s.</p>"},{"location":"hazi/VisualStudio/","title":"Visual Studio &amp; .NET SDK telep\u00edt\u00e9se","text":"<p>COMING SOON</p>"},{"location":"hazi/meghirdetes-elott/","title":"H\u00e1zi feladat","text":"<p>Ez a h\u00e1zi feladat ebben a f\u00e9l\u00e9vben m\u00e9g nem ker\u00fclt meghirdet\u00e9sre, \u00edgy a le\u00edr\u00e1sa k\u00e9s\u0151bb lesz el\u00e9rhet\u0151 a f\u00e9l\u00e9v folyam\u00e1n.</p>"},{"location":"hazi/2-nyelvi-eszkozok/","title":"2. HF - Nyelvi eszk\u00f6z\u00f6k","text":""},{"location":"hazi/2-nyelvi-eszkozok/#bevezetes","title":"Bevezet\u00e9s","text":"<p>Az \u00f6n\u00e1ll\u00f3 feladat a 2. el\u0151ad\u00e1son \u00e9s a 3. el\u0151ad\u00e1s els\u0151 fel\u00e9ben elhangzottakra \u00e9p\u00edt (ezek a \"El\u0151ad\u00e1s 02 - Nyelvi eszk\u00f6z\u00f6k\" el\u0151ad\u00e1sanyagban szerepelnek). Gyakorlati h\u00e1tter\u00e9\u00fcl a 2. labor - Nyelvi eszk\u00f6z\u00f6k laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Tulajdons\u00e1gok (property) haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Deleg\u00e1tok (delegate) \u00e9s esem\u00e9nyek (event) alkalmaz\u00e1sa</li> <li>.NET attrib\u00fatumok haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Alapvet\u0151 gy\u0171jtem\u00e9nyt\u00edpusok haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Lambda kifejez\u00e9sek gyakorl\u00e1sa</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#beadas-menete-eloellenorzo","title":"Bead\u00e1s menete, el\u0151ellen\u0151rz\u0151","text":"<p>A bead\u00e1s menete megegyezik az els\u0151 h\u00e1zi feladat\u00e9val (r\u00e9szletes le\u00edr\u00e1s a szok\u00e1sos helyen, l\u00e1sd H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata):</p> <ol> <li>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik).</li> <li>Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t.</li> <li>A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> </ol> <p>Az el\u0151ellen\u0151rz\u0151 is a szok\u00e1sos m\u00f3don m\u0171k\u00f6dik. R\u00e9szletes le\u00edr\u00e1s: A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-1-baljos-arnyak","title":"Feladat 1 \u2013 Balj\u00f3s \u00e1rnyak","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat","title":"Feladat","text":"<p>Amint az k\u00f6zismert, a jedi lovagok erej\u00e9t a sejtjeikben \u00e9l\u0151 kis \u00e9letform\u00e1k, a midi-chlorianok adj\u00e1k. Az eddigi legmagasabb midi-chlorian szintet (20.000 f\u00f6l\u00f6tti \u00e9rt\u00e9ket) Anakin Skywalkern\u00e9l m\u00e9rt\u00e9k.</p> <p>K\u00e9sz\u00edts egy oszt\u00e1lyt <code>Jedi</code> n\u00e9ven mely egy <code>string</code> t\u00edpus\u00fa <code>Name</code> \u00e9s egy <code>int</code> t\u00edpus\u00fa <code>MidiChlorianCount</code> tulajdons\u00e1ggal rendelkezik. Ut\u00f3bbi eset\u00e9ben figyelj r\u00e1, hogy a <code>MidiChlorianCount</code> \u00e9rt\u00e9k\u00e9t ne lehessen 35-re, vagy ann\u00e1l kisebb \u00e9rt\u00e9kre \u00e1ll\u00edtani, ha ezzel pr\u00f3b\u00e1lkozik valaki, az oszt\u00e1lynak kiv\u00e9telt kell dobnia. A valid\u00e1ci\u00f3 sor\u00e1n a lehet\u0151 legegyszer\u0171bb, legletisztultabb megold\u00e1st v\u00e1laszd: a property setterben egyszer\u0171 <code>if</code>-et haszn\u00e1lj \u00e9s dobj kiv\u00e9telt, ne legyen az <code>if</code>-nek <code>else</code> \u00e1ga, valamint nincs sz\u00fcks\u00e9g a <code>return</code> haszn\u00e1lat\u00e1ra sem.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor 1. feladat\u00e1val anal\u00f3g m\u00f3don k\u00e9sz\u00edthet\u0151 el. A <code>MidiChlorianCount</code> tulajdons\u00e1g setter\u00e9ben \u00e9rv\u00e9nytelen \u00e9rt\u00e9k eset\u00e9n dobj kiv\u00e9telt. Ezt p\u00e9ld\u00e1ul a k\u00f6vetkez\u0151 utas\u00edt\u00e1ssal tehet\u0151 meg:</p> <pre><code>throw new ArgumentException(\"You are not a true jedi!\");\n</code></pre>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-2-a-klonok-tamadasa","title":"Feladat 2 \u2013 A kl\u00f3nok t\u00e1mad\u00e1sa","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_1","title":"Feladat","text":"<p>Eg\u00e9sz\u00edtsd ki az 1. feladatban elk\u00e9sz\u00edtett oszt\u00e1lyt attrib\u00fatumokkal \u00fagy, hogy amennyiben az <code>XmlSerializer</code> oszt\u00e1ly seg\u00edts\u00e9g\u00e9vel, XML form\u00e1tum\u00fa adatf\u00e1jlba \u00edrunk/soros\u00edtunk ki egy <code>Jedi</code> objektumot, a tulajdons\u00e1gai egy-egy XML attrib\u00fatum form\u00e1j\u00e1ban, magyarul jelenjenek meg! Ezt k\u00f6vet\u0151en \u00edrjon egy f\u00fcggv\u00e9nyt, mely a <code>Jedi</code> oszt\u00e1ly egy p\u00e9ld\u00e1ny\u00e1t egy sz\u00f6vegf\u00e1jlba soros\u00edtja, majd onnan visszaolvassa egy \u00faj objektumba (ezzel tulajdonk\u00e9ppen kl\u00f3nozva az eredeti objektumot).</p> <p>XML soros\u00edt\u00f3 attrib\u00fatumai</p> <p>Az XML soros\u00edt\u00e1st szab\u00e1lyoz\u00f3 attrib\u00fatumokat ne tagv\u00e1ltoz\u00f3k, hanem a property-k felett helyezd el!</p> <p>A Jedi oszt\u00e1ly legyen publikus</p> <p>Az XML soros\u00edt\u00f3 csak publikus oszt\u00e1lyokon tud dolgozni, ennek megfelel\u0151en a Jedi oszt\u00e1ly legyen publikus: <pre><code>public class Jedi { ...}\n</code></pre></p> <p>Fontos</p> <p>A ment\u00e9st \u00e9s bet\u00f6lt\u00e9st v\u00e9gz\u0151/demonstr\u00e1l\u00f3 k\u00f3dot \u00edrd egy k\u00f6z\u00f6s, erre dedik\u00e1lt f\u00fcggv\u00e9nybe, a f\u00fcggv\u00e9nyt pedig l\u00e1sd el a <code>[Description(\"Feladat2\")]</code> C# attrib\u00fatummal (a f\u00fcggv\u00e9ny el\u0151tti sorba kell be\u00edrni). A mentett/bet\u00f6lt\u00f6tt objektum lok\u00e1lis v\u00e1ltoz\u00f3k\u00e9nt legyen ebben a f\u00fcggv\u00e9nyben megval\u00f3s\u00edtva. Az oszt\u00e1ly/f\u00fcggv\u00e9ny neve b\u00e1rmi lehet (pl. ker\u00fclhet a <code>Program</code> oszt\u00e1lyba is). A f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l. A fenti attrib\u00fatum haszn\u00e1lat\u00e1hoz using-olni kell a <code>System.ComponentModel</code> n\u00e9vteret.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_1","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor 4. feladat\u00e1val anal\u00f3g m\u00f3don k\u00e9sz\u00edthet\u0151 el. A megold\u00e1shoz az al\u00e1bbi seg\u00edts\u00e9geket adjuk:</p> <ul> <li> <p>A soros\u00edt\u00e1st k\u00f6vet\u0151en az XML f\u00e1jlnak ehhez hasonl\u00f3an kell kin\u00e9znie:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;Jedi xmlns:xsi=\"...\" Nev=\"Obi-Wan\" MidiChlorianSzam=\"15000\" /&gt;\n</code></pre> <p>L\u00e9nyeges, hogy az egyes Jedik <code>Jedi</code> XML elemk\u00e9nt, nev\u00fck <code>Nev</code>, a midichloriansz\u00e1muk <code>MidiChlorianSzam</code> XML attrib\u00fatumk\u00e9nt jelenjen meg.</p> </li> <li> <p>A soros\u00edtott objektumok visszat\u00f6lt\u00e9s\u00e9re a labor sor\u00e1n nem n\u00e9zt\u00fcnk p\u00e9ldak\u00f3dot, ez\u00e9rt ezt itt megadjuk:</p> <pre><code>var serializer = new XmlSerializer(typeof(Jedi));\nvar stream = new FileStream(\"jedi.txt\", FileMode.Open);\nvar clone = (Jedi)serializer.Deserialize(stream);\nstream.Close();\n</code></pre> <p>Az el\u0151z\u0151 m\u0171veletsor el\u0151sz\u00f6r l\u00e9trehoz egy soros\u00edt\u00f3t (<code>serializer</code>), mellyel majd a beolvas\u00e1st k\u00e9s\u0151bb elv\u00e9gezz\u00fck. A beolvas\u00e1st egy <code>jedi.txt</code> nev\u0171 f\u00e1jlb\u00f3l fogjuk v\u00e9gezni, amelyet a m\u00e1sodik sorban olvas\u00e1sra nyitunk meg (figyelj\u00fck meg, hogy ha \u00edrni akartuk volna, akkor<code>FileMode.Create</code>-et kellett volna megadni).</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-3-a-sith-ek-bosszuja","title":"Feladat 3 \u2013 A Sith-ek bossz\u00faja","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_2","title":"Feladat","text":"<p>A Jeditan\u00e1csban az ut\u00f3bbi id\u0151ben nagy a fluktu\u00e1ci\u00f3. Hogy a v\u00e1ltoz\u00e1sokat k\u00f6nnyebben nyomon k\u00f6vethess\u00fck, k\u00e9sz\u00edts egy oszt\u00e1lyt, mely k\u00e9pes nyilv\u00e1ntartani a tan\u00e1cs tagjait \u00e9s minden v\u00e1ltoz\u00e1sr\u00f3l egy esem\u00e9ny form\u00e1j\u00e1ban sz\u00f6veges \u00e9rtes\u00edt\u00e9st k\u00fcldeni! A lista manipul\u00e1ci\u00f3j\u00e1t k\u00e9t f\u00fcggv\u00e9nnyel lehessen v\u00e9gezni. Az <code>Add</code> f\u00fcggv\u00e9ny egy \u00faj jedi lovagot regisztr\u00e1ljon a tan\u00e1csba, m\u00edg a <code>Remove</code> f\u00fcggv\u00e9ny t\u00e1vol\u00edtsa el a legutolj\u00e1ra felvett tan\u00e1cstagot. K\u00fcl\u00f6n \u00e9rtes\u00edt\u00e9s jelezze, ha a tan\u00e1cs teljesen ki\u00fcr\u00fcl (ehhez ugyanazt az esem\u00e9nyt haszn\u00e1ld, mint a t\u00f6bbi v\u00e1ltoz\u00e1s eset\u00e9n, csak m\u00e1s sz\u00f6veggel jelezze).</p> <p>A tan\u00e1cstagok (<code>members</code>) nyilv\u00e1ntart\u00e1s\u00e1t egy <code>List&lt;Jedi&gt;</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3ban t\u00e1roljuk, az <code>Add</code> f\u00fcggv\u00e9ny ehhez a list\u00e1hoz f\u0171zze hozz\u00e1 az \u00faj elemeket, m\u00edg a <code>Remove</code> f\u00fcggv\u00e9ny generikus lista <code>RemoveAt</code> utas\u00edt\u00e1s\u00e1val mindig a legutolj\u00e1ra felvett tagot t\u00e1vol\u00edtsa el (az utols\u00f3 elem index\u00e9t a lista hossza alapj\u00e1n tudjuk meghat\u00e1rozni, melyet a <code>Count</code> property ad vissza).</p> <p>Az \u00e9rtes\u00edt\u00e9s egy C# esem\u00e9nyen (C# event) kereszt\u00fcl t\u00f6rt\u00e9njen. Az esem\u00e9nyhez tartoz\u00f3 delegate t\u00edpus param\u00e9terk\u00e9nt egy egyszer\u0171 <code>string</code>-et kapjon. Az \u00faj tag hozz\u00e1ad\u00e1s\u00e1t, az egyes tagok elt\u00e1vol\u00edt\u00e1s\u00e1t, illetve az utols\u00f3 tag elt\u00e1vol\u00edt\u00e1s\u00e1t m\u00e1s-m\u00e1s sz\u00f6veg\u0171 \u00fczenet jelezze. Az esem\u00e9ny els\u00fct\u00e9s\u00e9t k\u00f6zvetlen\u00fcl az <code>Add</code> \u00e9s a <code>Remove</code> m\u0171veletekben v\u00e9gezd el (ne vezess be erre seg\u00e9df\u00fcggv\u00e9nyt).</p> <p>Az esem\u00e9ny t\u00edpus\u00e1nak ne haszn\u00e1lj be\u00e9p\u00edtett delegate t\u00edpust, hanem vezess be egy saj\u00e1tot.</p> <p>Fontos</p> <p>A Jeditan\u00e1cs objektumot l\u00e9trehoz\u00f3 \u00e9s azt tesztel\u0151 (C# esem\u00e9ny\u00e9re val\u00f3 feliratkoz\u00e1s, <code>Add</code> \u00e9s <code>Remove</code> h\u00edv\u00e1sa) k\u00f3d ker\u00fclj\u00f6n egy k\u00f6z\u00f6s, \u00f6n\u00e1ll\u00f3 f\u00fcggv\u00e9nybe, ezt a f\u00fcggv\u00e9nyt pedig l\u00e1sd el a <code>[Description(\"Feladat3\")]</code> C# attrib\u00fatummal.   Az oszt\u00e1ly/f\u00fcggv\u00e9ny neve b\u00e1rmi lehet.   A f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.   A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_2","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor t\u00f6bb r\u00e9szlet\u00e9re is \u00e9p\u00edt. Az \u00faj esem\u00e9ny bevezet\u00e9s\u00e9t a 2. \u00e9s a 3. feladatban le\u00edrt m\u00f3don tudjuk elv\u00e9gezni, m\u00edg a tan\u00e1cs tagjait egy list\u00e1ban tudjuk nyilv\u00e1ntartani.</p> <p>A fenti inform\u00e1ci\u00f3k alapj\u00e1n pr\u00f3b\u00e1ld meg \u00f6n\u00e1ll\u00f3an megoldani a feladatot, majd ha k\u00e9szen vagy, a k\u00f6vetkez\u0151 kinyithat\u00f3 blokkban folytasd az \u00fatmutat\u00f3 olvas\u00e1s\u00e1t \u00e9s vesd \u00f6ssze a megold\u00e1sodat a lenti referencia megold\u00e1ssal! Sz\u00fcks\u00e9g szerint korrig\u00e1ld a saj\u00e1t megold\u00e1sod!</p> <p>Publikus l\u00e1that\u00f3s\u00e1g</p> <p>A p\u00e9lda \u00e9p\u00edt arra, hogy a r\u00e9sztvev\u0151 oszt\u00e1lyok, tulajdons\u00e1gok, delegate-ek publikus l\u00e1that\u00f3s\u00e1g\u00faak. Amennyiben fura ford\u00edt\u00e1si hib\u00e1val tal\u00e1lkozol, vagy az <code>XmlSerializer</code> fut\u00e1sid\u0151ben hib\u00e1t dob, els\u0151 k\u00f6rben azt ellen\u0151rizd, hogy minden \u00e9rintett helyen megfelel\u0151en be\u00e1ll\u00edtottad-e a publikus l\u00e1that\u00f3s\u00e1got.</p> Referencia megold\u00e1s <p>A referencia megold\u00e1s l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ol> <li>Hozzunk l\u00e9tre egy \u00faj oszt\u00e1lyt, <code>JediCouncil</code> n\u00e9ven.</li> <li>Vegy\u00fcnk fel egy <code>List&lt;Jedi&gt;</code> t\u00edpus\u00fa mez\u0151t \u00e9s inicializ\u00e1ljuk egy \u00fcres list\u00e1val.</li> <li> <p>Val\u00f3s\u00edtsuk meg az <code>Add</code> \u00e9s a <code>Remove</code> f\u00fcggv\u00e9nyeket.</p> <p>A fenti l\u00e9p\u00e9seket k\u00f6vet\u0151en az al\u00e1bbi k\u00f3dot kapjuk:</p> <pre><code>public class JediCouncil\n{\n    List&lt;Jedi&gt; members = new List&lt;Jedi&gt;();\n\n    public void Add(Jedi newJedi)\n    {\n        members.Add(newJedi);\n    }\n\n    public void Remove()\n    {\n        // Elt\u00e1vol\u00edtja a lista utols\u00f3 elem\u00e9t\n        members.RemoveAt(members.Count - 1);\n    }\n}\n</code></pre> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sk\u00e9nt val\u00f3s\u00edtsuk meg az esem\u00e9nykezel\u00e9st. </p> </li> <li> <p>Defini\u00e1ljunk egy \u00faj deleg\u00e1t t\u00edpust (az oszt\u00e1lyon k\u00edv\u00fcl, mivel ez is egy t\u00edpus), mely az \u00e9rtes\u00edt\u00e9sek sz\u00f6veg\u00e9t adja majd \u00e1t:</p> <pre><code>public delegate void CouncilChangedDelegate(string message);\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>JediCouncil</code> oszt\u00e1lyt az esem\u00e9nykezel\u0151vel:</p> <pre><code>public class JediCouncil\n{\n    public event CouncilChangedDelegate CouncilChanged;\n\n    // ...\n}\n</code></pre> </li> <li> <p>S\u00fcss\u00fck el az esem\u00e9nyt, amikor \u00faj tan\u00e1cstagot vesz\u00fcnk fel. Ehhez az <code>Add</code> met\u00f3dust kell kieg\u00e9sz\u00edten\u00fcnk.</p> <pre><code>public void Add(Jedi newJedi)\n{\n    members.Add(newJedi);\n\n    // TODO: Itt s\u00fcsd el az esem\u00e9nyt.\n    // Figyelj arra, hogy csak akkor tedd meg, ha van legal\u00e1bb egy feliratkoz\u00f3/el\u0151fizet\u0151.\n    // Ennek sor\u00e1n ne a terjeng\u0151sebb null ellen\u0151rz\u00e9st, hanem a modernebb, ?.Invoke-ot haszn\u00e1ld.\n}\n</code></pre> </li> <li> <p>S\u00fcss\u00fck el az esem\u00e9nyt, amikor egy tan\u00e1cstag t\u00e1vozik! K\u00fcl\u00f6nb\u00f6ztess\u00fck meg azt az esetet, amikor a tan\u00e1cs teljesen ki\u00fcr\u00fcl. Ehhez a <code>Remove</code> met\u00f3dust kell kieg\u00e9sz\u00edten\u00fcnk.</p> <pre><code>public void Remove()\n{\n    // Elt\u00e1vol\u00edtja a lista utols\u00f3 elem\u00e9t\n    members.RemoveAt(members.Count - 1);\n\n    // TODO: Itt s\u00fcsd el az esem\u00e9nyt.\n    // Figyelj arra, hogy csak akkor tedd meg, ha van legal\u00e1bb egy feliratkoz\u00f3/el\u0151fizet\u0151.\n}\n</code></pre> </li> <li> <p>Megold\u00e1sunk tesztel\u00e9s\u00e9hez vegy\u00fcnk fel egy <code>MessageReceived</code> f\u00fcggv\u00e9nyt abba az oszt\u00e1lyba, ahol az esem\u00e9nyre val\u00f3 feliratkoz\u00e1st \u00e9s az esem\u00e9ny kezel\u00e9s\u00e9t tesztelni szeretn\u00e9nk (pl. a <code>Program</code> oszt\u00e1lyba). Ezt a f\u00fcggv\u00e9nyt fogjuk feliratkoztatni a <code>JediCouncil</code> \u00e9rtes\u00edt\u00e9seire.</p> Program.cs<pre><code>private static void MessageReceived(string message)\n{\n    Console.WriteLine(message);\n}\n</code></pre> </li> <li> <p>V\u00e9gezet\u00fcl tesztelj\u00fck az \u00faj oszt\u00e1lyunkat egy erre a c\u00e9lra dedik\u00e1lt f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val (ez t\u00f6rt\u00e9nhet pl. a <code>Program</code> oszt\u00e1lyban), a f\u00fcggv\u00e9ny f\u00f6l\u00e9 tegy\u00fck oda a <code>[Description(\"Feladat3\")]</code> attrib\u00fatumot! A f\u00fcggv\u00e9ny v\u00e1za:</p> <pre><code>// Tan\u00e1cs l\u00e9trehoz\u00e1sa\nvar council = new JediCouncil();\n\n// TODO: Itt iratkozz fel a council CouncilChanged esem\u00e9ny\u00e9re\n\n// TODO Itt adj hozz\u00e1 k\u00e9t Jedi objektumot a council objektumhoz az Add h\u00edv\u00e1s\u00e1val\n\ncouncil.Remove();\ncouncil.Remove();\n</code></pre> </li> <li> <p>Ha j\u00f3l v\u00e9gezt\u00fck a dolgunkat, a program futtat\u00e1s\u00e1t k\u00f6vet\u0151en a k\u00f6vetkez\u0151 kimenetet kell kapnunk:</p> <pre><code>\u00daj taggal b\u0151v\u00fclt\u00fcnk\n\u00daj taggal b\u0151v\u00fclt\u00fcnk\nZavart \u00e9rzek az er\u0151ben\nA tan\u00e1cs elesett!\n</code></pre> </li> </ol> <p>Esem\u00e9nyek null vizsg\u00e1lata</p> <p>Amennyiben a <code>JediCouncil.Add</code> m\u0171veletben <code>null</code> vizsg\u00e1lattal v\u00e9gezted annak ellen\u0151rz\u00e9s\u00e9t, hogy van-e legal\u00e1bb egy feliratkoz\u00f3 az esem\u00e9nyre, ezt alak\u00edtsd \u00e1t korszer\u0171bb megold\u00e1sra (<code>?.Invoke</code> alkalmaz\u00e1sa, mely t\u00f6m\u00f6rebb form\u00e1ban szint\u00e9n elv\u00e9gzi az ellen\u0151rz\u00e9st, de <code>null</code> vizsg\u00e1lat n\u00e9lk\u00fcl \u2013 err\u0151l a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1son \u00e9s laboron is volt sz\u00f3). Ezt el\u00e9g a <code>JediCouncil.Add</code> kapcs\u00e1n megtenni, a <code>JediCouncil.Remove</code> eset\u00e9ben mindk\u00e9t megold\u00e1s elfogadhat\u00f3 most.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-4-delegatok","title":"Feladat 4 \u2013 Deleg\u00e1tok","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_3","title":"Feladat","text":"<p>Eg\u00e9sz\u00edtsd ki a <code>JediCouncil</code> oszt\u00e1lyt egy olyan param\u00e9ter n\u00e9lk\u00fcli f\u00fcggv\u00e9nnyel (a f\u00fcggv\u00e9nyn\u00e9v v\u00e9gz\u0151dj\u00f6n <code>_Delegate</code>-re, ez k\u00f6telez\u0151), mely visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben visszaadja a Jedi tan\u00e1cs \u00f6sszes olyan tagj\u00e1t, melynek a midi-chlorian sz\u00e1ma 530 alatt van!</p> <ul> <li>F\u00fcggv\u00e9nyt haszn\u00e1lj, ne tulajdons\u00e1got a lek\u00e9rdez\u00e9sre.</li> <li>A f\u00fcggv\u00e9nyen bel\u00fcl a tagok kikeres\u00e9s\u00e9re haszn\u00e1ld a <code>List&lt;Jedi&gt;</code> oszt\u00e1ly <code>FindAll()</code> f\u00fcggv\u00e9ny\u00e9t.</li> <li>Ebben a feladatban m\u00e9g NEM haszn\u00e1lhatsz lambda kifejez\u00e9st!</li> </ul> <p>\u00cdrj egy dedik\u00e1lt \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt is (pl. a <code>Program</code> oszt\u00e1lyba), mely megh\u00edvja a fenti f\u00fcggv\u00e9ny\u00fcnket \u00e9s ki\u00edrja a visszaadott jedi lovagok neveit! Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.</p> <p>Fontos</p> <p>Ezt a \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt l\u00e1sd el a <code>[Description(\"Feladat4\")]</code> C# attrib\u00fatummal. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul> <p>Inicializ\u00e1ci\u00f3 kiszervez\u00e9se</p> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n vezess be egy k\u00fcl\u00f6n statikus met\u00f3dust (pl. a <code>Program</code> oszt\u00e1lyba), mely param\u00e9terk\u00e9nt egy Jeditan\u00e1cs objektumot kap, abba legal\u00e1bb h\u00e1rom felparam\u00e9terezett <code>Jedi</code> objektumot az <code>Add</code> h\u00edv\u00e1s\u00e1val felvesz. A c\u00e9lunk ezzel az, hogy egy olyan inicializ\u00e1l\u00f3 met\u00f3dusunk legyen, mely a k\u00e9s\u0151bbi feladat(ok) sor\u00e1n is felhaszn\u00e1lhat\u00f3, ne kelljen a kapcsol\u00f3d\u00f3 inicializ\u00e1l\u00f3 k\u00f3dot duplik\u00e1lni.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_3","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1s\u00e1hoz a 2. labor 6. feladat\u00e1t haszn\u00e1lhatjuk referenciak\u00e9nt. Seg\u00edts\u00e9gk\u00e9nt megadjuk a k\u00f6vetkez\u0151ket:</p> <ul> <li>a f\u00fcggv\u00e9ny\u00fcnk ak\u00e1r t\u00f6bb tal\u00e1latot is visszaadhat, ez\u00e9rt a visszat\u00e9r\u00e9si \u00e9rt\u00e9k t\u00edpusa <code>List&lt;Jedi&gt;</code>,</li> <li>a <code>FindAll</code> param\u00e9terk\u00e9nt az eset\u00fcnkben egy <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi j)</code> szignat\u00far\u00e1j\u00fa sz\u0171r\u0151f\u00fcggv\u00e9nyt v\u00e1r el.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-5-lambda-kifejezesek","title":"Feladat 5 \u2013 Lambda kifejez\u00e9sek","text":"<p>A feladat megfelel az el\u0151z\u0151nek, csak most lambda kifejez\u00e9s seg\u00edts\u00e9g\u00e9vel fogunk dolgozni. Ez a t\u00e9mak\u00f6r szerepelt el\u0151ad\u00e1son \u00e9s laboron is (2. labor 6. feladat).</p> <p>Eg\u00e9sz\u00edtsd ki a JediCouncil oszt\u00e1lyt egy olyan param\u00e9ter n\u00e9lk\u00fcli f\u00fcggv\u00e9nnyel (a f\u00fcggv\u00e9nyn\u00e9v v\u00e9gz\u0151dj\u00f6n <code>_Lambda</code>-ra, ez k\u00f6telez\u0151), mely visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben visszaadja a Jedi tan\u00e1cs \u00f6sszes olyan tagj\u00e1t, melynek a midi-chlorian sz\u00e1ma 1000 alatt van!</p> <ul> <li>F\u00fcggv\u00e9nyt haszn\u00e1lj, ne tulajdons\u00e1got a lek\u00e9rdez\u00e9sre.</li> <li>A f\u00fcggv\u00e9nyen bel\u00fcl a tagok kikeres\u00e9s\u00e9re haszn\u00e1ld a <code>List&lt;Jedi&gt;</code> oszt\u00e1ly <code>FindAll()</code> f\u00fcggv\u00e9ny\u00e9t.</li> <li>Ebben a feladatban k\u00f6telez\u0151en lambda kifejez\u00e9st kell haszn\u00e1lj (az mindegy, hogy statement vagy expression lambd\u00e1t)!</li> </ul> <p>\u00cdrj egy dedik\u00e1lt \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt is (pl. a <code>Program</code> oszt\u00e1lyba), mely megh\u00edvja a fenti f\u00fcggv\u00e9ny\u00fcnket \u00e9s ki\u00edrja a visszaadott jedi lovagok neveit! Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.</p> <p>Fontos</p> <p>Ezt a \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt l\u00e1sd el a <code>[Description(\"Feladat5\")]</code> C# attrib\u00fatummal. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-6-imsc-beepitett-funcaction-generikus-delegate-tipusok-hasznalata","title":"Feladat 6 (iMSc) \u2013 be\u00e9p\u00edtett <code>Func</code>/<code>Action</code> generikus delegate t\u00edpusok haszn\u00e1lata","text":"<p>A feladat megold\u00e1sa nem k\u00f6telez\u0151, de er\u0151sen aj\u00e1nlott: alapanyag, \u00edgy ZH-n/vizsg\u00e1n szerepelhet. Laboron nem volt, csak el\u0151ad\u00e1son.</p> <p>A megold\u00e1s\u00e9rt +2 IMSc pont is j\u00e1r.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat_4","title":"Feladat","text":"<p>B\u0151v\u00edtsd ki a <code>JediCouncil</code> oszt\u00e1lyt.</p> <ul> <li> <p>K\u00e9sz\u00edts egy <code>Count</code> nev\u0171 <code>int</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171 property-t (tulajdons\u00e1got), amely minden lek\u00e9rdez\u00e9skor a tan\u00e1csban aktu\u00e1lisan tal\u00e1lhat\u00f3 Jedi-k sz\u00e1m\u00e1t adja vissza. \u00dcgyelj arra, hogy ezt az \u00e9rt\u00e9ket csak lek\u00e9rdezni lehessen (be\u00e1ll\u00edtani nem).</p> <p>Tipp</p> <p>A <code>JediCouncil</code>-ban tal\u00e1lhat\u00f3 members nev\u0171 tagv\u00e1ltoz\u00f3nak van egy <code>Count</code> nev\u0171 property-je, a megold\u00e1s \u00e9p\u00edtsen erre.</p> </li> <li> <p>K\u00e9sz\u00edts egy <code>CountIf</code> nev\u0171 f\u00fcggv\u00e9nyt, amely szint\u00e9n a tan\u00e1cstagok megsz\u00e1ml\u00e1l\u00e1s\u00e1ra val\u00f3, de csak bizonyos felt\u00e9telnek eleget tev\u0151 tan\u00e1cstagokat vesz figyelembe. A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9ke <code>int</code>, \u00e9s a felt\u00e9telt, amelynek megfelel\u0151 tan\u00e1cstagok sz\u00e1m\u00e1t visszaadja, egy delegate seg\u00edts\u00e9g\u00e9vel kapja meg param\u00e9terk\u00e9nt (teh\u00e1t a <code>CountIf</code>-nek kell legyen param\u00e9tere).</p> <p>Delegate t\u00edpusa</p> <p>A delegate t\u00edpusa k\u00f6telez\u0151en a be\u00e9p\u00edtett generikus <code>Action</code> / <code>Func</code> delegate t\u00edpusok k\u00f6z\u00fcl a megfelel\u0151 kell legyen (vagyis saj\u00e1t delegate t\u00edpus, ill. a be\u00e9p\u00edtett <code>Predicate</code> t\u00edpus nem haszn\u00e1lhat\u00f3).</p> <p>Emiatt a list\u00e1n NEM haszn\u00e1lhatod a be\u00e9p\u00edtett <code>FindAll</code> m\u0171velet\u00e9t, mivel az \u00e1ltalunk haszn\u00e1lt delegate t\u00edpus nem lenne kompatibilis a <code>FindAll</code> \u00e1ltal v\u00e1rt param\u00e9terrel. A tagokon egy <code>foreach</code> ciklusban v\u00e9gigiter\u00e1lva dolgozz!</p> </li> <li> <p>A property \u00e9s a f\u00fcggv\u00e9ny m\u0171k\u00f6d\u00e9s\u00e9t demonstr\u00e1ld egy erre dedik\u00e1lt k\u00f6z\u00f6s f\u00fcggv\u00e9nyben, amit l\u00e1ss el a <code>[Description(\"Feladat6\")]</code> attrib\u00fatummal. Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, viszont a Jeditan\u00e1cs felt\u00f6lt\u00e9s\u00e9hez az el\u0151z\u0151 feladatban bevezetett seg\u00e9df\u00fcggv\u00e9nyt h\u00edvd. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l. </p> <p>Fontos</p> <p>A <code>[Description(\"Feladat6\")]</code> attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_4","title":"Megold\u00e1s","text":"<ul> <li>A <code>Count</code> nev\u0171 property eset\u00e9ben csak a <code>get</code> \u00e1gnak van \u00e9rtelme, ez\u00e9rt a <code>set</code> \u00e1gat meg se \u00edrjuk. Ez egy csak olvashat\u00f3 tulajdons\u00e1g legyen.</li> <li>A <code>CountIf</code> f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1ban a 4-es feladat ny\u00fajt seg\u00edts\u00e9get. A k\u00fcl\u00f6nbs\u00e9g, hogy a <code>CountIf</code> nem a tan\u00e1cstagokat, csak a darabsz\u00e1mot adja vissza.<ul> <li>A <code>CountIf</code> f\u00fcggv\u00e9ny a felt\u00e9telt param\u00e9terk\u00e9nt egy <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi jedi)</code> szignat\u00far\u00e1j\u00fa sz\u0171r\u0151f\u00fcggv\u00e9nyt v\u00e1rjon.</li> </ul> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#beadas","title":"Bead\u00e1s","text":"<p>Ellen\u0151rz\u0151lista ism\u00e9tl\u00e9sk\u00e9ppen:</p> <ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/beadas-ellenorzes/","title":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k","text":"<ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/eloellenorzes-ertekeles/","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se","text":"<p>Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut a felt\u00f6lt\u00f6tt k\u00f3d (el\u0151)ellen\u0151rz\u00e9se, \u00e9s meg lehet n\u00e9zni a kimenet\u00e9t! Az ellen\u0151rz\u0151t maga a GitHub futtatja. A push-t k\u00f6vet\u0151en a feladat egy v\u00e1rakoz\u00e1si sorba ker\u00fcl, majd adott id\u0151 ut\u00e1n lefutnak az ellen\u0151rz\u0151 tesztek. Azt nem lehet tudni, mennyi ez az id\u0151, a GitHub-on m\u00falik. Amikor csak egy-k\u00e9t feladat van a sorban a szervezetre (ez n\u00e1lunk a t\u00e1rgy), akkor a tapasztalatok alapj\u00e1n az ellen\u0151rz\u00e9s 1-2 percen bel\u00fcl elindul. De ha a t\u00e1rgy alatt egyszerre sokan kezdik majd felt\u00f6lteni a megold\u00e1st, akkor ez j\u00f3 es\u00e9llyel belassul. Nem \u00e9rdemes ez\u00e9rt sem az utols\u00f3 pillanatra hagyni a bead\u00e1st: lehet, hogy ekkor a k\u00e9sleltet\u00e9sek miatt m\u00e1r nem kapsz esetleg id\u0151ben visszajelz\u00e9st.</p> <p> Hivatalosan a feladat azon \u00e1llapota ker\u00fcl \u00e9rt\u00e9kel\u00e9sre, amely a hat\u00e1rid\u0151 lej\u00e1rtakor GitHub-on fent van. A hivatalos ellen\u0151rz\u00e9st szok\u00e1sos m\u00f3don, saj\u00e1t, oktat\u00f3i k\u00f6rnyezetben v\u00e9gezz\u00fck \u00e9s az eredm\u00e9nyt Moodleben publik\u00e1ljuk a sz\u00e1monk\u00e9r\u00e9sn\u00e9l. Vagyis a hivatalos eredm\u00e9ny tekintet\u00e9ben teljesen mindegy, hogy a GitHub-on a hat\u00e1rid\u0151 lej\u00e1rta lefutott-e m\u00e1r b\u00e1rmif\u00e9le (el\u0151)ellen\u0151rz\u00e9s, vagy hogy az ellen\u0151rz\u00e9s esetleg csak k\u00e9s\u0151bb tudott elindulni. A GitHub \u00e1ltali ellen\u0151rz\u00e9s csak azt a c\u00e9lt szolg\u00e1lja, hogy m\u00e9g a hat\u00e1rid\u0151 lej\u00e1rta el\u0151tt visszajelz\u00e9st kaphasson mindenki. A hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1ni hivatalos ellen\u0151rz\u00e9s tartalmaz m\u00e9g plusz l\u00e9p\u00e9seket a GitHub alap\u00fa el\u0151ellen\u0151rz\u00e9shez k\u00e9pest, az el\u0151ellen\u0151rz\u00e9s ilyen \u00e9rtelemben r\u00e9szleges, de az\u00e9rt sok probl\u00e9m\u00e1t seg\u00edthet megfogni!</p> <p> Arra k\u00e9r\u00fcnk, hogy ne apr\u00e1nk\u00e9nt push-olj, csak a k\u00e9sz, \u00e1tn\u00e9zett, fordul\u00f3 megold\u00e1st tedd fel! Ez nem a legszerencs\u00e9sebb, de a GitHub korl\u00e1tozott id\u0151t biztos\u00edt az ellen\u0151rz\u0151k futtat\u00e1s\u00e1ra: ha elfogy a havi keret, akkor m\u00e1r nem fogsz visszajelz\u00e9st kapni, csak a hat\u00e1rid\u0151 ut\u00e1ni hivatalos ellen\u0151rz\u00e9s kimenet\u00e9t kapja meg mindenki.</p> <p>A (f\u00e9l)automata ellen\u0151rz\u0151, most m\u00e9g egy r\u00e9szben k\u00eds\u00e9rleti projekt. Ha valaki az \u00fatmutat\u00f3ban inkonzisztenci\u00e1t tal\u00e1l, vagy az ellen\u0151rz\u0151 adott helyzetet nem kezel \u00e9s indokolatlanul panaszkodik, Benedek Zolt\u00e1n felel\u0151s oktat\u00f3 fel\u00e9 legyen sz\u00edves jelezni! Ugyanakkor ezeket nagy t\u00f6megben nem fogjuk tudni kezelni. Ha j\u00f3 a megold\u00e1sod, \u00e9s az ellen\u0151rz\u0151 indokolatlanul panaszkodik, a hivatalos ellen\u0151rz\u00e9s sor\u00e1n term\u00e9szetesen el fogjuk fogadni.</p> <p>Az el\u0151ellen\u0151rz\u0151 \u2013 k\u00fcl\u00f6n\u00f6sen az els\u0151 h\u00e1zi feladat eset\u00e9ben \u2013 sokszor el\u00e9gg\u00e9 \"g\u00e9pk\u00f6zeli megfogalmaz\u00e1sban\" jelzi az esetleges probl\u00e9m\u00e1kat. Ha semmik\u00e9ppen nem tudod \u00e9rtelmezni, \u00edrj Benedek Zolt\u00e1nnak Teams-ben, a hiba\u00fczenet megad\u00e1s\u00e1val, illetve egy linkkel a GitHub repository-dra  (m\u00e1sk\u00fcl\u00f6nben nem tudjuk, hol tal\u00e1lhat\u00f3 a k\u00f3dod).</p> <p>Az, hogy az el\u0151ellen\u0151rz\u0151 milyen m\u00e9lys\u00e9gben ellen\u0151rzi a megold\u00e1st, a h\u00e1zi feladatt\u00f3l f\u00fcgg. Az 1-3 feladat eset\u00e9ben el\u00e9g alapos, m\u00edg a 4-5 feladat eset\u00e9n csak a Neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi, \u00e9s azt, van-e ford\u00edt\u00e1si hiba (az \u00e9rdemi \u00e9rt\u00e9kel\u00e9s ut\u00f3lag t\u00f6rt\u00e9nik).</p>"},{"location":"hazi/eloellenorzes-ertekeles/#a-github-altal-futtatott-ellenorzesek-megtekintese","title":"A GitHub \u00e1ltal futtatott ellen\u0151rz\u00e9sek megtekint\u00e9se","text":"<ol> <li>GitHub-on a navig\u00e1l\u00e1s a repository-hoz</li> <li>Actions tabf\u00fclre v\u00e1lt\u00e1s</li> <li>Itt megjelenik egy t\u00e1bl\u00e1zat, minden push \u00e1ltal futtatott ellen\u0151rz\u00e9shez egy k\u00fcl\u00f6n sor, a tetej\u00e9n van legfrissebb. A sor elej\u00e9n lev\u0151 ikon jelzi a st\u00e1tuszt: v\u00e1r, fut, sikeres, sikertelen lehet. A sor sz\u00f6vege a Git commit neve.</li> <li> <p>Egy sorban a commit nev\u00e9n kattintva jelenik meg egy \u00e1tfog\u00f3 oldal az ellen\u0151rz\u0151 fut\u00e1s\u00e1r\u00f3l, ez sok inform\u00e1ci\u00f3t nem tartalmaz. Ezen az oldalon baloldalt kell a \"build\" vagy \"build-and-check\" (vagy hasonl\u00f3 nev\u0171) linken  kattintani, ez \u00e1tnavig\u00e1l az ellen\u0151rz\u00e9s r\u00e9szletes n\u00e9zet\u00e9re. Ez egy \u201e\u00e9l\u0151\u201d n\u00e9zet, ha fut a teszt, folyamatosan friss\u00fcl. Ha v\u00e9gzett, a csom\u00f3pontokat lenyitva lehet megn\u00e9zni az adott l\u00e9p\u00e9s kimenet\u00e9t.  Ha minden siker\u00fclt, egy ehhez hasonl\u00f3 n\u00e9zet l\u00e1that\u00f3:</p> <p></p> </li> <li> <p>Itt a legfontosabb tal\u00e1n a \"Run tests\" l\u00e9p\u00e9s. Ha valamelyik l\u00e9p\u00e9s sikertelen, pipa helyett piros x van a csom\u00f3pont elej\u00e9n, \u00e9s a csom\u00f3pontot kibontva a teszt kimenete utal a hiba ok\u00e1ra. Az els\u0151 h\u00e1zi feladat eset\u00e9ben az \"Error Message\"-re, ill. az \"Assert\"-re \u00e9rdemes sz\u00f6vegesen (control+F) keresni a kimenetben, ennek a k\u00f6rny\u00e9k\u00e9n szokott lenni hivatkoz\u00e1s a hiba ok\u00e1ra.</p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/","title":"Fejleszt\u0151k\u00f6rnyezet h\u00e1zi feladatokhoz","text":""},{"location":"hazi/fejlesztokornyezet/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok megold\u00e1s\u00e1hoz a Visual Studio 2022 fejleszt\u0151k\u00f6rnyezetet kell haszn\u00e1lni (a Visual Studio for Mac nem alkalmas). Ennek futtat\u00e1s\u00e1hoz Windows oper\u00e1ci\u00f3s rendszerre van sz\u00fcks\u00e9g.  Ha telep\u00edtve van m\u00e1r a g\u00e9p\u00fcnkre a Visual Studio 2022, akkor a Start men\u00fcb\u0151l ind\u00edtsuk el a \u201eVisual Studio Installer\u201d-t. Ez indul\u00e1skor ellen\u0151rzi, \u00e9rhet\u0151-e el Visual Studio-b\u00f3l \u00fajabb v\u00e1ltozat online, \u00e9s ha igen, az Update gombra kattintva ind\u00edtsuk is el a legfrissebb verzi\u00f3 telep\u00edt\u00e9s\u00e9t.</p> Mi\u00e9rt is van sz\u00fcks\u00e9g Visual Studiora \u00e9s Windowsra? <p>VS Code, illetve a Visual Studio for Mac a k\u00f6vetkez\u0151k miatt nem haszn\u00e1lhat\u00f3k:</p> <ul> <li>Nem t\u00e1mogatj\u00e1k az UML (szer\u0171) modellez\u00e9st, melyre az els\u0151 h\u00e1zi feladatn\u00e1l sz\u00fcks\u00e9g van.</li> <li>\u00c9rdemben nem t\u00e1mogatj\u00e1k a Windows Form \u0171rlap alap\u00fa .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9t (erre a 3-5 h\u00e1zi feladat \u00e9p\u00edt).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/#visual-studio-edition-ok","title":"Visual Studio edition-\u00f6k","text":"<p>A Visual Studionak t\u00f6bb kiad\u00e1sa l\u00e9tezik:</p> <ul> <li>A t\u00e1rgy teljes\u00edt\u00e9s\u00e9hez megfelel a Microsoft honlapj\u00e1r\u00f3l let\u00f6lthet\u0151 \u00e9s ingyenesen haszn\u00e1lhat\u00f3 Community edition.</li> <li>Term\u00e9szetesen a Professional \u00e9s Enterprise v\u00e1ltozatok is haszn\u00e1lhat\u00f3k, a t\u00e1rgy vonatkoz\u00e1s\u00e1ban ugyanakkor ezek \u00e9rdemi pluszt nem adnak. Ezek az egy\u00e9bk\u00e9nt fizet\u0151s v\u00e1ltozatok az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ingyenesen el\u00e9rhet\u0151k (a https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/#telepitendo-komponensek","title":"Telep\u00edtend\u0151 komponensek","text":"<p>A t\u00e1rgy els\u0151 el\u0151ad\u00e1sa r\u00f6viden kit\u00e9r a .NET k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltozataira (.NET Framework, .NET Core, .NET 5-7 \u00e9s  stb.). A feladatok megold\u00e1s\u00e1hoz a .NET 7-et haszn\u00e1ljuk a f\u00e9l\u00e9v sor\u00e1n. A Visual Studio ezt telep\u00edti, de sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>Modify gombra kattint\u00e1s</li> <li>A megjelen\u0151 ablakban ellen\u0151rizz\u00fck, hogy a \".NET desktop development\" k\u00e1rtya ki van-e pip\u00e1lva.</li> <li>Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck.</li> </ol> <p>Bizonyos h\u00e1zi feladatok eset\u00e9n (m\u00e1r az els\u0151n\u00e9l is) sz\u00fcks\u00e9g van Visual Studio Class Diagram t\u00e1mogat\u00e1sra. Ezt a k\u00f6vetkez\u0151k\u00e9ppen tudjuk ut\u00f3lag telep\u00edteni a Visual Studio al\u00e1:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>Modify gombra kattint\u00e1s</li> <li>A megjelen\u0151 ablakban \"Individual components\" f\u00fcl kiv\u00e1laszt\u00e1sa</li> <li>A keres\u0151mez\u0151be \"class designer\" beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \"Class Designer\" elem ki van pip\u00e1lva.</li> <li> <p>Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck.</p> <p></p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/#macbook-es-linux-hasznalok-szamara-informaciok","title":"MacBook \u00e9s Linux haszn\u00e1l\u00f3k sz\u00e1m\u00e1ra inform\u00e1ci\u00f3k","text":"<p>A t\u00e1rgy felel\u0151s oktat\u00f3j\u00e1t\u00f3l (Benedek Zolt\u00e1n) BME Cloud hozz\u00e1f\u00e9r\u00e9s ig\u00e9nylelhet\u0151 e-mailben.</p>"},{"location":"hazi/git-github-github-classroom/","title":"Git, GitHub, GitHub Classroom","text":"<p>A t\u00e1rgy keret\u00e9ben nem c\u00e9lunk a Git \u00e9s GitHub r\u00e9szletes megismer\u00e9se, csak a legsz\u00fcks\u00e9gesebb l\u00e9p\u00e9sekre szor\u00edtkozunk, valamint a legfontosabb parancsokat haszn\u00e1ljuk ahhoz, hogy a h\u00e1zi feladat(ok) kiindul\u00e1si programv\u00e1z\u00e1t hallgat\u00f3k\u00e9nt egy dedik\u00e1lt GitHub repository-b\u00f3l le tudjuk t\u00f6lteni, illetve a k\u00e9sz munk\u00e1t GitHubra fel tudjuk t\u00f6lteni.</p>"},{"location":"hazi/git-github-github-classroom/#git","title":"Git","text":"<p>A Git egy sok szolg\u00e1ltat\u00e1ssal rendelkez\u0151, rendk\u00edv\u00fcl n\u00e9pszer\u0171 \u00e9s elterjedt, ingyenesen let\u00f6lthet\u0151 \u00e9s telep\u00edthet\u0151, elosztottan is haszn\u00e1lhat\u00f3 verzi\u00f3kezel\u0151 rendszer. A k\u00f6zpontos\u00edtott rendszerekhez k\u00e9pest (TFS, CVS, SVN) a GIT eset\u00e9ben nem egyetlen k\u00f6zponti repository-ba dolgoznak a fejleszt\u0151k, hanem mindenki egy saj\u00e1t lok\u00e1lis repository p\u00e9ld\u00e1nnyal rendelkezik.</p> <p>Egy Git repository (becenev\u00e9n rep\u00f3) nem m\u00e1s, mint egy k\u00f6z\u00f6ns\u00e9ges k\u00f6nyvt\u00e1r a f\u00e1jlrendszerben, benne \u00e1llom\u00e1nyokkal (pl. forr\u00e1sk\u00f3d) \u00e9s alk\u00f6nyvt\u00e1rakkal, illetve egy \".git\" alk\u00f6nyvt\u00e1rral, melyben minden, a verzi\u00f3kezel\u00e9shez kapcsol\u00f3d\u00f3 extra inform\u00e1ci\u00f3 megtal\u00e1lhat\u00f3.</p> <p>A Git alap\u00fa munkafolyamat legfontosabb l\u00e9p\u00e9sei - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel - a k\u00f6vetkez\u0151k (felt\u00e9ve, hogy l\u00e9tezik egy k\u00f6zponti repository, ahol a verzi\u00f3kezelt k\u00f3d adott v\u00e1ltozata m\u00e1r el\u00e9rhet\u0151):</p> <ol> <li>A fejleszt\u0151 kl\u00f3nozza (<code>clone</code>) az adott k\u00f6zponti repository-t, melynek sor\u00e1n egy azzal megegyez\u0151 helyi repository j\u00f6n l\u00e9tre a saj\u00e1t sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n. Ezt a m\u0171veletet el\u00e9g egyszer elv\u00e9gezni.</li> <li>A fejleszt\u0151 a helyi repository-hoz tartoz\u00f3 munkak\u00f6nyvt\u00e1rban (working directory) v\u00e1ltoztat\u00e1sokat v\u00e9gez a k\u00f3don: \u00faj f\u00e1jlokat vesz fel, megl\u00e9v\u0151ket m\u00f3dos\u00edt \u00e9s t\u00f6r\u00f6l.</li> <li>Ha elk\u00e9sz\u00fcl egy \u00e9rdemi r\u00e9szfeladat, akkor a fejleszt\u0151 a v\u00e1ltoztat\u00e1sokat <code>commit</code>-olja a sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n lev\u0151 helyi repository-ba. Ennek sor\u00e1n a commit-ot c\u00e9lszer\u0171 egy a v\u00e1ltoztat\u00e1sok jelleg\u00e9t j\u00f3l \u00f6sszefoglal\u00f3 megjegyz\u00e9ssel ell\u00e1tni.</li> <li>A helyi repository-b\u00f3l egy <code>push</code> m\u0171velettel a fejleszt\u0151 fel\u00f6lti a v\u00e1ltoz\u00e1sokat a k\u00f6zponti repository-ba, ahol \u00edgy v\u00e1ltoztat\u00e1sai m\u00e1sok sz\u00e1m\u00e1ra is l\u00e1that\u00f3v\u00e1 v\u00e1lnak.</li> </ol> <p>Minden egyes commit tulajdonk\u00e9ppen egy id\u0151b\u00e9lyeggel, a fejleszt\u0151 felhaszn\u00e1l\u00f3nev\u00e9vel \u00e9s e-mail c\u00edm\u00e9vel ell\u00e1tott k\u00f3dot \u00e9rint\u0151 v\u00e1ltoz\u00e1shalmaz. A repositoryban ezek \"egym\u00e1sut\u00e1nis\u00e1g\u00e1b\u00f3l\" \u00e1ll \u00f6ssze a teljes verzi\u00f3t\u00f6rt\u00e9net. Mivel a legt\u00f6bb esetben a fejleszt\u0151k csapatban dolgoznak, id\u0151nk\u00e9nt sz\u00fcks\u00e9g van arra, hogy m\u00e1sok \u00e1ltal a k\u00f6zponti repository-ba <code>push</code>-olt v\u00e1ltoztat\u00e1sokat a fejleszt\u0151k a saj\u00e1t lok\u00e1lis repository-jukba let\u00f6lts\u00e9k \u00e9s belemerge-elj\u00e9k: erre szolg\u00e1l a <code>pull</code> m\u0171velet. Fontos szab\u00e1ly, hogy <code>push</code>-olni csak akkor lehet a k\u00f6zponti repository-ba (a Git csak akkor engedi), ha el\u0151tte m\u00e1sok v\u00e1ltoztat\u00e1sait a saj\u00e1t lok\u00e1lis repository-nkba egy <code>pull</code> m\u0171velettel el\u0151tte belemerge-elt\u00fck. A Szoftvertechnik\u00e1k t\u00e1rgy keret\u00e9ben a <code>pull</code> m\u0171veletet nem kell haszn\u00e1lni, mert mindenki \u00f6n\u00e1ll\u00f3an, saj\u00e1t repository-ba dolgozik. Megjegyz\u00e9s: ha esetleg a GitHub fel\u00fclet\u00e9n k\u00f6zvetlen v\u00e1ltoztatunk f\u00e1jlokon (vagy t\u00f6bb clone-ban is dolgozunk), akkor sz\u00fcks\u00e9g van a <code>pull</code> haszn\u00e1lat\u00e1ra ez esetben is. A fentieken t\u00falmen\u0151en a Git sz\u00e1mos tov\u00e1bbi szolg\u00e1ltat\u00e1st biztos\u00edt (pl. teljes verzi\u00f3t\u00f6rt\u00e9net megtekint\u00e9se minden f\u00e1jlra, commit t\u00f6rt\u00e9net megtekint\u00e9se, tetsz\u0151leges m\u00faltbeli verzi\u00f3ra vissza\u00e1ll\u00e1s, \u00e1gak kezel\u00e9se stb.).</p>"},{"location":"hazi/git-github-github-classroom/#github","title":"GitHub","text":"<p>A GitHub egy online el\u00e9rhet\u0151 website \u00e9s szolg\u00e1ltat\u00e1s (https://github.com), mely teljes k\u00f6r\u0171 Git szolg\u00e1ltat\u00e1st biztos\u00edt. Mindezt r\u00e1ad\u00e1sul \u2013 legal\u00e1bbis publikus, vagyis mindenki sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 repositoryk vonatkoz\u00e1s\u00e1ban \u2013 teljesen ingyenesen biztos\u00edtja. Napjainkra a GitHub v\u00e1lt a k\u00f6z\u00f6ss\u00e9gi k\u00f3d (verzi\u00f3kezelt) t\u00e1rol\u00e1s\u00e1nak els\u0151 sz\u00e1m\u00fa platformj\u00e1v\u00e1, a legt\u00f6bb ny\u00edlt forr\u00e1sk\u00f3d\u00fa projekt \u201eotthon\u00e1v\u00e1\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#github-classroom","title":"GitHub Classroom","text":"<p>A GitHub Classroom egy ingyenesen el\u00e9rhet\u0151 GitHub-bal integr\u00e1lt szolg\u00e1ltat\u00e1s, mely t\u00f6bbek k\u00f6z\u00f6tt oktat\u00e1si int\u00e9zm\u00e9nyek sz\u00e1m\u00e1ra lehet\u0151v\u00e9 teszi \u00f6n\u00e1ll\u00f3 tanul\u00f3i feladatokhoz tartoz\u00f3, tanul\u00f3nk\u00e9nt egyedi GitHub repository-k l\u00e9trehoz\u00e1s\u00e1t, ez\u00e1ltal a kiindul\u00e1si k\u00f3d tanul\u00f3k sz\u00e1m\u00e1ra t\u00f6rt\u00e9n\u0151 \u201ekioszt\u00e1s\u00e1t\u201d, valamint az elk\u00e9sz\u00fclt feladatok \u201ebeszed\u00e9s\u00e9t\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#git-github-es-github-classroom-a-targy-kontextusaban","title":"Git, GitHub \u00e9s GitHub Classroom a t\u00e1rgy kontextus\u00e1ban","text":"<p>A t\u00e1rgy keret\u00e9ben a GitHub Classroom seg\u00edts\u00e9g\u00e9vel kap minden hallgat\u00f3 minden h\u00e1zi feladat\u00e1hoz egy dedik\u00e1lt, a GitHub-on hostolt repository-t, mely a megfelel\u0151 kiindul\u00e1si k\u00f6rnyezettel (kiindul\u00f3 Visual Studio solution-\u00f6k) inicializ\u00e1l\u00e1sra ker\u00fcl. Mindenkinek a sz\u00e1m\u00e1ra dedik\u00e1lt repository-t kell a saj\u00e1t g\u00e9p\u00e9re <code>clone</code>-oznia, ebbe a v\u00e1ltoztat\u00e1sait <code>commit</code>-olni, \u00e9s a hat\u00e1rid\u0151ig az elk\u00e9sz\u00fclt megold\u00e1s\u00e1t <code>push</code>-olni (hogy GitHub-on is el\u00e9rhet\u0151 legyen a megold\u00e1s). A pontos l\u00e9p\u00e9sekre r\u00f6videsen visszat\u00e9r\u00fcnk.</p>"},{"location":"hazi/git-github-github-classroom/#visual-studio-es-a-git","title":"Visual Studio \u00e9s a Git","text":"<p>A Git egy elosztott verzi\u00f3kezel\u0151 rendszer. Ahhoz, hogy a saj\u00e1t g\u00e9p\u00fcnk\u00f6n dolgozni tudjunk vele, a Git-nek telep\u00edtve kell lennie. K\u00e9tf\u00e9le m\u00f3don tudjuk haszn\u00e1lni:</p> <ul> <li>A Git \u00f6nmag\u00e1ban is telep\u00edthet\u0151, \u00e9s parancssorb\u00f3l is ki tudjuk adni a sz\u00fcks\u00e9ges <code>clone</code>, <code>commit</code>, <code>push</code> stb. parancsokat.</li> <li>Haszn\u00e1lhatunk a parancsok kiad\u00e1s\u00e1ra egy grafikus fel\u00fclettel rendelkez\u0151 eszk\u00f6zt. Ilyenek pl. a GitHub Desktop, a GitExtensions, vagy maga a Visual Studio is (mely integr\u00e1lt grafikus Git szolg\u00e1ltat\u00e1sokat is biztos\u00edt).</li> </ul> <p>A k\u00e9t megk\u00f6zel\u00edt\u00e9st a mindennapokban kombin\u00e1ltan szoktuk haszn\u00e1lni. Egy repo lekl\u00f3noz\u00e1sa sokszor parancssorb\u00f3l a legegyszer\u0171bb/leggyorsabb. A v\u00e1ltoz\u00e1sok commit-ol\u00e1s\u00e1ra, a k\u00f6zponti repositoryval val\u00f3 szinkroniz\u00e1ci\u00f3ra (push, pull), a verzi\u00f3t\u00f6rt\u00e9nek megjelen\u00edt\u00e9s\u00e9re m\u00e1r c\u00e9lszer\u0171bb egy grafikus eszk\u00f6zt haszn\u00e1lni, k\u00fcl\u00f6n\u00f6sen akkor, ha m\u00e9g kev\u00e9sb\u00e9 vagyunk rutinosak. A t\u00e1rgy keret\u00e9ben a kl\u00f3noz\u00e1sra a parancssor vagy a Visual Studio, az egy\u00e9b parancsok kiad\u00e1s\u00e1ra a Visual Studio javasolt. A git haszn\u00e1latr\u00f3l (a h\u00e1zi feladatok kontextus\u00e1ban) itt tal\u00e1lhat\u00f3 b\u0151vebb le\u00edr\u00e1s.</p>"},{"location":"hazi/git-github-github-classroom/#git-telepitese","title":"Git telep\u00edt\u00e9se","text":"<p>Amennyiben a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre nincs m\u00e9g a Git telep\u00edtve, \u00e9s szeretn\u00e9nk azt parancssorb\u00f3l is haszn\u00e1lni, akkor innen telep\u00edthet\u0151 Windows oper\u00e1ci\u00f3s rendszerre: https://git-scm.com/download/win. Egy\u00e9b oper\u00e1ci\u00f3s rendszerek eset\u00e9n pedig innen \u00e9rdemes indulni: https://git-scm.com/downloads.</p>"},{"location":"hazi/hf-folyamat/","title":"H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata","text":"<p>Ha m\u00e9g nem olvastad, c\u00e9lszer\u0171 itt kezdeni: Git, GitHub, GitHub Classroom</p>"},{"location":"hazi/hf-folyamat/#lepesek","title":"L\u00e9p\u00e9sek","text":"<p>Az egyes h\u00e1zi feladatok kiindul\u00f3 keret\u00e9t GitHub/GitHub Classroom seg\u00edts\u00e9g\u00e9vel publik\u00e1ljuk. Az \u00edgy publik\u00e1lt h\u00e1zi feladatok kiindul\u00f3 k\u00f6rnyezet let\u00f6lt\u00e9s\u00e9nek \u00e9s a megold\u00e1s bead\u00e1s\u00e1nak l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ol> <li> Az elindul\u00e1ssal ne v\u00e1rd meg a hat\u00e1rid\u0151 k\u00f6zeledt\u00e9t, legal\u00e1bb a saj\u00e1t repository l\u00e9trehoz\u00e1s\u00e1ig juss el miel\u0151bb. \u00cdgy, ha b\u00e1rmi elakad\u00e1s lenne, m\u00e9g id\u0151ben tudunk seg\u00edteni.</li> <li>Regisztr\u00e1lj egy GitHub accountot (https://github.com/), ha m\u00e9g nem regisztr\u00e1lt\u00e1l, \u00e9s l\u00e9pj be vele GitHub-ra.</li> <li>A feladathoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, Moodle-ben ker\u00fclnek meghirdet\u00e9sre fokozatosan a f\u00e9l\u00e9v folyam\u00e1n. A form\u00e1tuma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3: https://classroom.github.com/abcdefgh. Ha a hivatkoz\u00e1sra kattintva hib\u00e1t kapsz (\"There was a problem authenticating with GitHub, please try again.\"), copy-paste-tel m\u00e1sold be k\u00f6zvetlen\u00fcl a b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba a c\u00edmet.</li> <li>Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat.</li> <li>L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept this assignment\"). Kattints a gombra.</li> <li>V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A GitHub nem mindig friss\u00edti az oldalt mag\u00e1t\u00f3l, c\u00e9lszer\u0171 az oldal id\u0151nk\u00e9nti k\u00e9zi friss\u00edt\u00e9s\u00e9vel pr\u00f3b\u00e1lkozni (pl. F5 billenty\u0171). Ha elk\u00e9sz\u00fclt a repository, az oldal ki\u00edrja az \u00faj repository url-j\u00e9t, amin kattintva a repository-ra lehet navig\u00e1lni (ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2023-username).  De nem is felt\u00e9tlen sz\u00fcks\u00e9ges az url elment\u00e9se, a GitHub nyit\u00f3oldal\u00e1n (https://github.com/) baloldalt a saj\u00e1t repository-k k\u00f6zt b\u00e1rmikor meg lehet k\u00e9s\u0151bb is tal\u00e1lni.</li> <li>Kl\u00f3nozd le a repository-t (ennek mik\u00e9ntj\u00e9re r\u00f6videsen visszat\u00e9r\u00fcnk). Ebben tal\u00e1lni fogsz egy keretet, vagy kiindul\u00f3 k\u00f3dot. Ezen dolgozz, ezt v\u00e1ltoztasd. Az alap\u00e9rtelmezett git \u00e1gon/branchen dolgozz (ha ez nem mond semmit, nem baj: ez csak azoknak sz\u00f3l, akik a git haszn\u00e1lat\u00e1ban j\u00e1rtasak \u00e9s t\u00f6bb \u00e1gon szoktak dolgozni).</li> <li> A kiindul\u00f3 projektben van egy .github/workflows mappa, ennek tartalm\u00e1t tilos megv\u00e1ltoztatni, t\u00f6r\u00f6lni stb.</li> <li> A munka sor\u00e1n a kiindul\u00e1si rep\u00f3ban lev\u0151 solutionben/projektben kell dolgozni, \u00faj projektet/solutiont ne hozz l\u00e9tre.</li> <li> A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>Oldd meg a feladatot. Pushold a hat\u00e1rid\u0151ig. Ak\u00e1rh\u00e1ny commitod lehet, a legutols\u00f3 \u00e1llapotot fogjuk n\u00e9zni.</li> <li>Az eredm\u00e9nyek Moodle-ben ker\u00fclnek meghirdet\u00e9sre (a nyit\u00f3oldalon kapcsol\u00f3d\u00f3 h\u00e1zi feladat oldal\u00e1t Moodle-ben megnyitva az oldal alj\u00e1n a \"Visszajelz\u00e9s\" szekci\u00f3ban l\u00e1that\u00f3). Eredm\u00e9nyek az adott feladatra vonatkoz\u00f3 hat\u00e1rid\u0151t k\u00f6vet\u0151 p\u00e1r napon bel\u00fcl v\u00e1rhat\u00f3k.</li> <li>A h\u00e1zi feladatot k\u00fcl\u00f6n explicit beadni nem kell, csak legyen fent GitHub-on hat\u00e1rid\u0151re a megold\u00e1s.</li> <li> Amikor a h\u00e1zi feladatod beadottnak tekinted,  c\u00e9lszer\u0171 ellen\u0151rizni a b\u00f6ng\u00e9sz\u0151ben a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st push-olt\u00e1l-e, \u00e9s hogy a neptun.txt val\u00f3ban ki van-e t\u00f6ltve.</li> </ol> <p>A fenti l\u00e9p\u00e9sek kapcs\u00e1n k\u00e9t k\u00e9rd\u00e9s v\u00e1r m\u00e9g megv\u00e1laszol\u00e1sra:</p> <ul> <li>Hogyan kl\u00f3nozzuk (clone) a rep\u00f3nkat (mely a h\u00e1zi feladat kiindul\u00f3 keret\u00e9t tartalmazza)?</li> <li>Hogyan commit-\u00e1ljunk \u00e9s push-oljunk a Visual Studio seg\u00edts\u00e9g\u00e9vel GitHub-ra?</li> </ul> <p>Az al\u00e1bbiakban ezekre is kit\u00e9r\u00fcnk.</p>"},{"location":"hazi/hf-folyamat/#github-repository-klonozasa","title":"GitHub repository kl\u00f3noz\u00e1sa","text":"<p>K\u00e9t lehet\u0151s\u00e9get n\u00e9z\u00fcnk meg al\u00e1bb:</p> <ul> <li>Kl\u00f3noz\u00e1s a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studioban</li> <li>Kl\u00f3noz\u00e1s parancssorb\u00f3l</li> </ul>"},{"location":"hazi/hf-folyamat/#clone-a-github-webes-feluleterol-indulva-visual-studio-ban","title":"Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studio-ban","text":"<p>Egy (h\u00e1zi feladathoz tartoz\u00f3) repository kl\u00f3noz\u00e1sra sz\u00e1mos m\u00f3d van, egy lehet\u0151s\u00e9g a k\u00f6vetkez\u0151. Nyissuk meg az elk\u00e9sz\u00fclt repository online oldal\u00e1t, melyre t\u00f6bb m\u00f3don eljuthatunk. Lehet\u0151s\u00e9gek pl.:</p> <ul> <li>A repo l\u00e9trehoz\u00e1sakor megjelenik a GitHub fel\u00fcleten az url, csak kattintani kell rajta.</li> <li>A GitHub nyit\u00f3oldalon (https://github.com) - ha be vagyunk l\u00e9pve - list\u00e1z\u00f3dnak baloldalt azon repository-k, melyekhez van hozz\u00e1f\u00e9r\u00e9s\u00fcnk, csak kattintsunk a megfelel\u0151n.</li> <li>Amikor elk\u00e9sz\u00fcl a rep\u00f3nk (a GitHub classroom feladat elfogad\u00e1sa sor\u00e1n), e-mail \u00e9rtes\u00edt\u00e9st is kapunk r\u00f3la, ebben is megtal\u00e1lhat\u00f3 a link.</li> </ul> <p>Az oldal k\u00e9pe nagyj\u00e1b\u00f3l megfelel a k\u00f6vetkez\u0151nek (az mindenk\u00e9ppen k\u00fcl\u00f6nbs\u00e9g, hogy a rep\u00f3 url v\u00e9g\u00e9n mindenkin\u00e9l a saj\u00e1t felhaszn\u00e1l\u00f3neve szerepel):</p> <p></p> <p>Kattintsunk a z\u00f6ld sz\u00edn\u0171 Code gombon, majd a leny\u00edl\u00f3 men\u00fcben az \"Open in Visual Studio\" linkre:</p> <p></p> <p>A b\u00f6ng\u00e9sz\u0151nk ekkor j\u00f3 es\u00e9llyel feldob egy ablakot (pl. a Chrome/Edge eset\u00e9ben a c\u00edmsor alatt) melyben egy k\u00fcl\u00f6n gombkattint\u00e1ssal (Open\u2026) tudjuk ind\u00edtani a Visual Studio-t. A felk\u00edn\u00e1lt lehet\u0151s\u00e9gnek lehet, kiss\u00e9 fura a neve, ha \"Microsoft Visual Studio Web Protocol Handler Selector\" n\u00e9ven hivatkozik r\u00e1, v\u00e1lasszuk/enged\u00e9lyezz\u00fck ki b\u00e1tran. Illetve, itt c\u00e9lszer\u0171 az \"Always allow github.com to open links ...\" vagy hasonl\u00f3 sz\u00f6veg\u0171 jel\u00f6l\u0151n\u00e9gyzetet is pip\u00e1lni. Ha minden j\u00f3l megy, a Visual Studio elindul, \u00e9s indul\u00e1s ut\u00e1n feldob egy ablakot, melyben a \"Repository location\" ki is van t\u00f6ltve a repository-nk URL-j\u00e9vel. A Path alatt adjuk meg, hogy hova szeretn\u00e9nk a h\u00e1tt\u00e9rt\u00e1runkon clone-ozni, majd kattintsunk a Clone gombra:</p> <p></p> <p>Alternat\u00edv kl\u00f3noz\u00e1si lehet\u0151s\u00e9g Visual Studioban</p> <p>Ha nem m\u0171k\u00f6dik a b\u00f6ng\u00e9sz\u0151ablakban az \"Open in Visual Studio\" vagy \"Microsoft Visual Studio Web Protocol Handler Selector\" hivatkoz\u00e1s, akkor indulhatunk egyb\u0151l a Visual Studio-b\u00f3l is. Csak ind\u00edtsuk el a Visual Studio-t, \u00e9s a startup ablakban v\u00e1lasszuk jobboldalt a \"Clone Repository\" gombot (vagy a startup ablakot \u00e1tugorva v\u00e1lasszuk ki a \"Git/Clone Repository men\u00fct\" a VS f\u0151ablak\u00e1ban), melynek hat\u00e1s\u00e1ra a fenti ablak jelenik meg, a Repository URL-be pedig \u00edrjuk be a rep\u00f3nk URL-j\u00e9t. A Clone-ra kattintva n\u00e9h\u00e1ny m\u00e1sodperc alatt a repository a megadott c\u00e9lmapp\u00e1ba kl\u00f3noz\u00f3dik.</p> <p>A kl\u00f3noz\u00e1st k\u00f6vet\u0151en pl. Windows Explorer-ben meg tudjuk tekinteni a l\u00e9trehozott mapp\u00e1kat \u00e9s f\u00e1jlokat:</p> <p></p> <p>Ebb\u0151l j\u00f3l l\u00e1that\u00f3, hogy egy Git repository nem m\u00e1s, mint mapp\u00e1k \u00e9s f\u00e1jlok gy\u0171jtem\u00e9nye, valamint egy a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 .git mappa, mely (n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve) az egyes f\u00e1jlok verzi\u00f3t\u00f6rt\u00e9net\u00e9t tartalmazza. A munka megkezd\u00e9s\u00e9hez csak meg kell nyissuk az adott h\u00e1zi feladathoz tartoz\u00f3 .sln kiterjeszt\u00e9s\u0171 solution f\u00e1jlt (pl. duplakatt Windows Explorerben).</p> <p>Az els\u0151 h\u00e1zi feladat speci\u00e1lis (k\u00e9t solution is van)!</p> <p>Az els\u0151 h\u00e1zi feladat kiv\u00e9telesen k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll, melyekhez elt\u00e9r\u0151 solution tartozik. Az els\u0151h\u00f6z a Feladat1 mapp\u00e1ban tal\u00e1lhat\u00f3 MusicApp.sln f\u00e1jlt, a m\u00e1sodikhoz a Feladat2-ben tal\u00e1lhat\u00f3 Shapes.sln-t kell megnyitni. A megnyit\u00e1st megtehetj\u00fck Explorerb\u0151l, az adott .sln f\u00e1jlon dupl\u00e1n kattintva. Ugyanakkor van erre m\u00e1s m\u00f3d is: amennyiben Visual Studio-ban a Git gy\u00f6k\u00e9rmapp\u00e1t nyitottuk meg (a Clone-t k\u00f6vet\u0151en is ez a helyzet \u00e1llt el\u0151) a Solution Explorer n\u00e9zet fejl\u00e9c\u00e9ben \"Switch View\" gombot lenyomva a Solution Explorer list\u00e1zza a Git gy\u00f6k\u00e9rmappa alatti solution-\u00f6ket, \u00e9s ezek b\u00e1rmelyik\u00e9n dupl\u00e1n kattintva az adott solution megny\u00edlik:</p> <p></p>"},{"location":"hazi/hf-folyamat/#clone-parancssorbol","title":"Clone parancssorb\u00f3l","text":"<p>Alternat\u00edv lehet\u0151s\u00e9g a parancssor haszn\u00e1lata. Parancssorban navig\u00e1ljunk abba a mapp\u00e1ba, ahov\u00e1 a forr\u00e1sk\u00f3dot ki szeretn\u00e9nk clone-ozni, \u00e9s itt adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone &lt;repo url&gt;</code> , ahol a <code>&lt;repo url&gt;</code> a repositorynk c\u00edme (pl. b\u00f6ng\u00e9sz\u0151 c\u00edms\u00e1vj\u00e1b\u00f3l bem\u00e1solva, ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2022-myusername). A parancs lefut\u00e1sa ut\u00e1n egy a repository nev\u00e9nek megfelel\u0151 alk\u00f6nyvt\u00e1rban tal\u00e1ljuk az \u00faj helyi rep\u00f3nkat.</p> <p>Parancssori git</p> <p>Ne f\u00e9lj\u00fcnk a parancssori git-et haszn\u00e1lni, egy repository clone-oz\u00e1s\u00e1nak tulajdonk\u00e9ppen ez a legegyszer\u0171bb m\u00f3dja.</p> <p>Amennyiben a parancs futtat\u00e1sa sor\u00e1n azt tapasztaljuk, hogy a git parancsot nem ismeri fel a k\u00f6rnyezet, annak oka val\u00f3sz\u00edn\u0171leg az, hogy nem telep\u00edtett\u00fcnk m\u00e9g a parancssori gitet a g\u00e9p\u00fcnkre. Err\u0151l b\u0151vebben itt.</p>"},{"location":"hazi/hf-folyamat/#napi-git-munka-visual-studio-segitsegevel-commit-push","title":"Napi Git munka Visual Studio seg\u00edts\u00e9g\u00e9vel (commit, push)","text":"<p>Miut\u00e1n lekl\u00f3noztuk az adott h\u00e1zi feladathoz tartoz\u00f3 GitHub repository-t a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre, \u00e9s ennek sor\u00e1n l\u00e9trej\u00f6tt a lok\u00e1lis Git repository-nk, a benne lev\u0151 .sln f\u00e1jlokat Visual Studioban megnyitva pont \u00fagy dolgozunk \u2013 vesz\u00fcnk fel \u00faj f\u00e1jlokat, m\u00f3dos\u00edtunk/t\u00f6rl\u00fcnk megl\u00e9v\u0151ket \u2013 mintha a f\u00e1jlok nem is tartozn\u00e1nak semmif\u00e9le Git rep\u00f3hoz. Ugyanakkor, legk\u00e9s\u0151bb a feladat bead\u00e1sakor a v\u00e1ltoztat\u00e1sainkat commit-olni kell, majd push-olni GitHub-ra. A munka sor\u00e1n ak\u00e1rh\u00e1nyszor commit-\u00e1lhatjuk/push-olhatjuk az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat: a h\u00e1zi feladat ellen\u0151rz\u00e9sekor a hat\u00e1rid\u0151 pillanat\u00e1ban a GitHub-on tal\u00e1lhat\u00f3 \u00e1llapot ker\u00fcl elb\u00edr\u00e1l\u00e1sra, teljesen mindegy, h\u00e1ny commit tartozik hozz\u00e1. A commit \u00e9s push m\u0171veletek v\u00e9grehajt\u00e1s\u00e1hoz a Visual Studio \"Git\" men\u00fcj\u00e9ben lev\u0151 parancsokat haszn\u00e1ljuk.</p>"},{"location":"hazi/hf-folyamat/#commit","title":"Commit","text":"<p>Az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt v\u00e1ltoztat\u00e1sok megtekint\u00e9s\u00e9hez v\u00e1lasszuk ki a \"View\\Git Changes\" men\u00fct. Ennek hat\u00e1s\u00e1ra megjelenik a \"Git Changes\" n\u00e9zet a v\u00e1ltoz\u00e1sok list\u00e1j\u00e1val:</p> <p></p> <p>A v\u00e1ltoztat\u00e1sok commit-\u00e1l\u00e1s\u00e1hoz \u00edrjunk a fenti sz\u00f6vegmez\u0151be egy a v\u00e1ltoztat\u00e1sokra jellemz\u0151 egy-k\u00e9t soros le\u00edr\u00e1st (pl. \"V\u00e9gs\u0151 megold\u00e1s\", \"Az xyz hiba jav\u00edt\u00e1sa\" stb.). A lehet\u0151s\u00e9geink ezt k\u00f6vet\u0151en a k\u00f6vetkez\u0151k:</p> <ul> <li>\"Commit All\" gomb: Csak helyben commit-olja a v\u00e1ltoztat\u00e1sokat (a k\u00f6zponti Git rep\u00f3ban mindaddig nem jelenik meg a commit, am\u00edg egy k\u00fcl\u00f6n Push paranccsal fel nem \"toljuk\").</li> <li>\"Commit All and Push\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit, majd ut\u00e1na push. Ha a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lni is szeretn\u00e9nk a GitHub-on lev\u0151 k\u00f6zponti rep\u00f3ba, akkor haszn\u00e1ljuk b\u00e1tran parancsot. A h\u00e1zi feladatok tekintet\u00e9ben c\u00e9lszer\u0171 is ezt haszn\u00e1lni, mert ekkor nincs sz\u00fcks\u00e9g a commit-ot k\u00f6vet\u0151en k\u00fcl\u00f6n push m\u0171veletre. Megjegyz\u00e9s: ha a parancs az \"Unable to push to the remote repository because your local branch is behind the remote branch\" hib\u00e1val z\u00e1rul, el\u0151bb pull-oljuk, majd ism\u00e9telj\u00fck meg a push-t. Erre m\u00e9g al\u00e1bb visszat\u00e9r\u00fcnk.</li> <li>\"Commit All and Sync\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit ut\u00e1n pull (leszedi a saj\u00e1t helyi rep\u00f3nkba m\u00e1sok esetleges v\u00e1ltoztat\u00e1sait a k\u00f6zponti rep\u00f3b\u00f3l), majd push. \u00cdgy a k\u00f6zponti rep\u00f3ban lev\u0151 esetleges v\u00e1ltoz\u00e1sokat lehozza a helyi rep\u00f3nkba, az ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lja is ide.</li> </ul> <p>Note</p> <p>A git commit-ot mindig meg kell el\u0151zze egy \u00fan. stage l\u00e9p\u00e9s, mely sor\u00e1n kiv\u00e1lasztjuk azokat a helyi v\u00e1ltoztat\u00e1sokat, melyeket a k\u00f6vetkez\u0151 commit-ba be k\u00edv\u00e1nunk tenni. Ez az \u00fan. staging area ter\u00fcletre teszi az \u00e1ltalunk kiv\u00e1lasztott v\u00e1ltoz\u00e1sokat (a f\u00e1jlrendszerben nem mozgat semmif\u00e9le f\u00e1jlt, ez csak a git a bels\u0151 nyilv\u00e1ntart\u00e1s\u00e1ban jelenik meg). Ez az\u00e9rt j\u00f3, mert plusz rugalmass\u00e1got biztos\u00edt, hiszen nem biztos, mindig minden v\u00e1ltoztat\u00e1st bele k\u00edv\u00e1nunk tenni a k\u00f6vetkez\u0151 commit-ba. A fenti \"Commit all\" stb. parancsok nev\u00e9ben nem v\u00e9letlen van benne az \"all\": ezek a sz\u00ednfalak m\u00f6g\u00f6tt a commit el\u0151tt egy megfelel\u0151 git paranccsal valamennyi v\u00e1ltoz\u00e1st a git staging area-ra tesznek, \u00edgy ezt nek\u00fcnk nem kell k\u00fcl\u00f6n megtenn\u00fcnk.</p>"},{"location":"hazi/hf-folyamat/#push-pull","title":"Push, Pull","text":"<p>A commit m\u0171velet csak a helyi repository-ban \"\u00e9rv\u00e9nyes\u00edti\" a v\u00e1ltoztat\u00e1sokat. Ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sokat a GitHub k\u00f6zponti repository-nkba fel kell t\u00f6lteni a push m\u0171velettel. Erre a l\u00e9p\u00e9sre csak akkor van sz\u00fcks\u00e9g, ha a commit sor\u00e1n nem haszn\u00e1ltuk a \"Commit All and Push\" vagy \"Commit All and Sync\" parancsokat. A push m\u0171velet VS-ben a \"Git/Push\" men\u00fc seg\u00edt\u00e9s\u00e9vel ind\u00edthat\u00f3.  Ha t\u00f6bben dolgozunk, a k\u00f6zponti repository-ban lehetnek m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok (vagy ak\u00e1r olyanok, melyeket mi magunk push-oltunk egy m\u00e1sik lok\u00e1lis clone-b\u00f3l, vagy ha a GitHub online fel\u00fclet\u00e9n eszk\u00f6z\u00f6lt\u00fcnk a k\u00f3don v\u00e1ltoz\u00e1sokat). Ezeket a pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni (Git/Pull men\u00fc). A h\u00e1zi feladat vonatkoz\u00e1s\u00e1ban ezt nem haszn\u00e1ljuk, hiszen mindenki saj\u00e1t dedik\u00e1lt k\u00f6zponti repositoryval rendelkezik, melyben egyed\u00fcl dolgozik (kiv\u00e9ve, ha esetleg valaki a GitHub fel\u00fclet\u00e9nek seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztatott a k\u00f3don, akkor ezt egy pull-lal tudja a helyi rep\u00f3j\u00e1ba lehozni).</p> <p>Note</p> <p>A push csak akkor hajthat\u00f3 v\u00e9gre, ha a k\u00f6zponti rep\u00f3ban nincs olyan v\u00e1ltoz\u00e1s, melyet m\u00e9g a pull paranccsal nem hoztunk le \u00e9s merge-elt\u00fcnk a saj\u00e1t lok\u00e1lis rep\u00f3nkba. Ha ez nincs \u00edgy, egy ehhez hasonl\u00f3 hiba\u00fczenet kapunk: \"Unable to push to the remote repository because your local branch is behind the remote branch\". Ekkor pull-oljunk, ut\u00e1na ism\u00e9telj\u00fck meg a pusht.</p> <p>Note</p> <p>A pull m\u0171velet csak akkor hajthat\u00f3 v\u00e9gre, ha nincs olyan v\u00e1ltoztat\u00e1sunk helyben, melyeket m\u00e9g nem commit\u00e1ltunk. Ha van ilyen, akkor azokat vagy commit\u00e1ljuk (vagy ha ezt nem akarjuk megtenni m\u00e9g, akkor stash-elj\u00fck a pull idej\u00e9re).</p> <p>Tip</p> <p>A Pull \u00e9s Push parancsok a \u201eGit Changes\u201d (View/Git Changes men\u00fc jelen\u00edti meg) panel tetej\u00e9n el\u00e9rhet\u0151 le \u00e9s fel nyilakkal is v\u00e9grehajthat\u00f3k:</p> <p></p>"},{"location":"hazi/hf-folyamat/#git-history","title":"Git history","text":"<p>A Git egy v\u00e1ltoz\u00e1sk\u00f6vet\u0151 rendszer. A v\u00e1ltoz\u00e1s egys\u00e9ge a commit (melyben tetsz\u0151leges sz\u00e1m\u00fa f\u00e1jlt \u00e9rint\u0151 v\u00e1ltoz\u00e1s lehet), a Git historyban a commitok egym\u00e1sut\u00e1nis\u00e1g\u00e1t l\u00e1thatjuk. A f\u00e1jlokat \u00e9rint\u0151 v\u00e1ltoz\u00e1sokon t\u00falmen\u0151en minden commithoz tartozik egy egyedi azonos\u00edt\u00f3 (commit hash), id\u0151b\u00e9lyeg, illetve egy szerz\u0151. A szerz\u0151 felhaszn\u00e1l\u00f3, aki a v\u00e1ltoz\u00e1sokat eszk\u00f6z\u00f6lte (val\u00f3j\u00e1ban van k\u00fcl\u00f6n Author \u00e9s Commiter, de a kett\u0151 \u00e1ltal\u00e1ban ugyanaz). Visual Studioban a historyt a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni, de a history term\u00e9szetesen a GitHub online fel\u00fclet\u00e9n is megjelen\u00edthet\u0151. A Visual Studioban a \"Git Repository\" n\u00e9zetet a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni.</p> <ul> <li>Outgoing commits: Megmutatja, hogy milyen, a lok\u00e1lis repository-nkba m\u00e1r l\u00e9tez\u0151, de a k\u00f6zponti rep\u00f3ba m\u00e9g nem push-olt commitok vannak. Ezeket a Push m\u0171velettel tudjuk felt\u00f6lteni.</li> <li>Incoming commits: Megmutatja, hogy a k\u00f6zponti repository-ban milyen m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok vannak. Ezek akkor jelennek meg, ha a Fetch paranccsal lehozzuk a helyi rep\u00f3ba (ez m\u00e9g nem merge-el). Ezeket a Pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni. A fetch parancsot ritk\u00e1n haszn\u00e1ljuk: \u00e1ltal\u00e1ban a pullt haszn\u00e1ljuk mag\u00e1ban, ami egy fetch + merge (v\u00e1ltoz\u00e1sok merge-el\u00e9se a helyi rep\u00f3ba) kombin\u00e1ci\u00f3ja.</li> </ul> <p>P\u00e9lda:</p> <p></p> <p>Tip</p> <p>Am\u00edg nem vagyunk rutinosak a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00fcnk-e.</p>"},{"location":"hazi/hf-folyamat/#egyeb-iranyelvek","title":"Egy\u00e9b ir\u00e1nyelvek","text":"<p>A Git commit \u00e9s push sor\u00e1n megfigyelhetj\u00fck, hogy a solution-jeink k\u00f6ztes \u00e9s kimeneti \u00e1llom\u00e1nyai (.dll, .exe stb. f\u00e1jlok) nem ker\u00fclnek bele a commitba, \u00e9s \u00edgy nem ker\u00fclnek fel GitHubra sem. Ez \u00edgy is van j\u00f3l, ezen \u00e1llom\u00e1nyok b\u00e1rmikor reproduk\u00e1lhat\u00f3k, a verzi\u00f3kezel\u0151 rendszernek nem feladata ezek t\u00e1rol\u00e1sa, csak felesleges \u00e9s zavar\u00f3 helyfoglal\u00f3k lenn\u00e9nek. Felmer\u00fcl a k\u00e9rd\u00e9s, honnan tudja a Git, hogy mely \u00e1llom\u00e1nyokat sz\u00fcks\u00e9ges figyelmen k\u00edv\u00fcl hagyni a commit sor\u00e1n. Erre szolg\u00e1l a repository-ban (tipikusan annak gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban) tal\u00e1lhat\u00f3 .gitignore f\u00e1jl, mely felsorolja azon mapp\u00e1kat, f\u00e1jlkiterjeszt\u00e9seket, illetve egyedi f\u00e1jlokat, melyeket a commit sor\u00e1n figyelmen k\u00edv\u00fcl szeretn\u00e9nk hagyni. A .gitignore f\u00e1jl tartalma teljes eg\u00e9sz\u00e9ben a kez\u00fcnk al\u00e1 tartozik, szabadon szerkeszthet\u0151/commit\u00e1lhat\u00f3/pusholhat\u00f3. A t\u00e1rgy keret\u00e9ben minden kiindul\u00f3 rep\u00f3nak r\u00e9sze egy .gitignore f\u00e1jl, ne v\u00e1ltoztassuk a tartalm\u00e1t! \u00cdgy a commit/push sor\u00e1n a kimeneti \u00e1llom\u00e1nyok a h\u00e1zi feladatok eset\u00e9ben sem ker\u00fclnek fel GitHub-ra, \u00e9s egy \u00edgy is van rendj\u00e9n.</p> <p>A f\u00e9l\u00e9vben a feladatok megold\u00e1sa sor\u00e1n az egyes oszt\u00e1lyok, interf\u00e9szek stb. forr\u00e1sk\u00f3dj\u00e1t k\u00fcl\u00f6n f\u00e1jlba kell tenni, vagyis egy C# forr\u00e1sf\u00e1jlban egy oszt\u00e1ly/interf\u00e9sz/stb. defin\u00edci\u00f3ja legyen.</p>"},{"location":"hazi/hf-folyamat/#git-hasznalata-parancssorbol","title":"Git haszn\u00e1lata parancssorb\u00f3l","text":"<p>B\u00e1r sokan \u00f3dzkodnak a git parancssori alkalmaz\u00e1s\u00e1t\u00f3l, az egyszer\u0171bb m\u0171veleteket gyakran gyorsabban v\u00e9gre tudjuk hajtani parancssorb\u00f3l, mint a GUI fel\u00fcleteken t\u00f6rt\u00e9n\u0151 kattintgat\u00e1sokkal. Az al\u00e1bbiakban egy egyszer\u0171 l\u00e9p\u00e9ssorozattal illusztr\u00e1ljuk ezt. Ezeket a t\u00e1rgy keret\u00e9ben nem kell tudni, de hosszabb t\u00e1von mindenk\u00e9ppen hasznos (\u00e9s az ipar\u00e1gban elv\u00e1r\u00e1s is) az ismeret\u00fck.</p> <ol> <li> <p>Repository clone (ezt csak egyszer)</p> <p><code>git clone https://github.com/bmeviauab00/hazi1-2022-myusername</code></p> </li> <li> <p>V\u00e1ltoztat\u00e1sok v\u00e9grehajt\u00e1sa a helyi rep\u00f3ban (f\u00e1jlrendszerben, fejleszt\u0151eszk\u00f6zben).</p> </li> <li> <p>V\u00e1ltoztat\u00e1sok megtekint\u00e9se, mutatja melyek az \u00faj/t\u00f6r\u00f6lt/m\u00f3dosult f\u00e1jlok (nem k\u00f6telez\u0151, csak ha k\u00edv\u00e1ncsiak vagyunk r\u00e1)*</p> <p><code>git status</code></p> </li> <li> <p>Minden v\u00e1ltoztat\u00e1s felt\u00e9tele a staging area-ra</p> <p><code>git add -A</code></p> <p>Ha ezt k\u00f6vet\u0151en ism\u00e9t kiadjuk <code>git status</code> parancsot (nem k\u00f6telez\u0151), l\u00e1tjuk, hogy minden v\u00e1ltoz\u00e1s stage-elve van.</p> </li> <li> <p>Commit</p> <p><code>git commit -m \"megjegyz\u00e9s a commithoz\"</code></p> </li> <li> <p>Push</p> <p><code>git push</code></p> </li> </ol> <p>Megjegyz\u00e9sek:</p> <ul> <li>Ha t\u00f6bben is dolgozunk az adott git \u00e1gon, akkor a 6. push el\u0151tt sz\u00fcks\u00e9g lehet/van egy <code>git pull</code>-ra, hogy m\u00e1sok v\u00e1ltoztat\u00e1sai megjelenjenek a mi helyi rep\u00f3nkban (en\u00e9lk\u00fcl nem fogunk tudni push-olni). A pull-nak c\u00e9lszer\u0171 lehet megadni a <code>--rebase</code> opci\u00f3t is, hogy ne sz\u00fclessen a merge-hez egy plusz merge commit, ennek magyar\u00e1zat\u00e1ra itt nem t\u00e9r\u00fcnk ki.</li> <li> <p>Mint kor\u00e1bban eml\u00edtett\u00fck, a commit sor\u00e1n a commithoz hozz\u00e1rendel\u0151dik egy felhaszn\u00e1l\u00f3n\u00e9v \u00e9s e-mail c\u00edm. Ha ezek nincsenek a git sz\u00e1m\u00e1ra bekonfigur\u00e1lva, akkor a git a commit sor\u00e1n ezt hiba\u00fczenetben jelzi. Ekkor az al\u00e1bbi parancsokkal - \u00e9rtelemszer\u0171en a saj\u00e1t felhaszn\u00e1l\u00f3nev\u00fcnket \u00e9s e-mail c\u00edm\u00fcnket megadva - tudjuk ezeket a git glob\u00e1lis konfigur\u00e1ci\u00f3j\u00e1ban be\u00e1ll\u00edtani (ezt csak egyszer kell megtenni):</p> <pre><code>git config --global user.email \"you@example.com\"\ngit config --global user.name \"myusername\"\n</code></pre> </li> <li> <p>Windows parancssorban \u00f6sszevonhatunk t\u00f6bb parancsot is egy sorba, pl. egy l\u00e9p\u00e9sben minden v\u00e1ltoz\u00e1sra stage/commit/push:</p> <p><code>git add -A &amp; git commit -m \"All tests run\" &amp; git push</code></p> <p>Powershell haszn\u00e1latakor a <code>&amp;</code> helyett <code>;</code>-t kell szepar\u00e1tork\u00e9nt haszn\u00e1lni.</p> </li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/","title":"1. A modell \u00e9s a k\u00f3d kapcsolata","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja:</p> <ul> <li>Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel</li> <li>A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa</li> <li>Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel.</li> <li>Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok</li> <li>Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se</li> <li>Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja</li> </ul> Gyakorlatvezet\u0151knek <p>B\u00e1r a hallgat\u00f3k k\u00f6z\u00f6tt biztosan vannak olyanok, akik kor\u00e1bban, a Prog2 (C++) t\u00e1rgy keret\u00e9ben vagy m\u00e1s okb\u00f3l kifoly\u00f3lag m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezetet, szinte biztosan lesznek olyanok is, akik m\u00e9g nem haszn\u00e1lt\u00e1k, vagy m\u00e1r kev\u00e9sb\u00e9 eml\u00e9keznek r\u00e1. A c\u00e9l jelen esetben a fel\u00fclettel val\u00f3 ismerked\u00e9s, ez\u00e9rt a feladatok megold\u00e1sa sor\u00e1n folyamatosan ismertess\u00fck a haszn\u00e1lt dolgokat (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat stb.), hogy elk\u00e9sz\u00edts\u00fck \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1t.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 (https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben).</p> <p>Visual Studio Class Diagram t\u00e1mogat\u00e1s</p> <p>Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa</li> <li> <p>A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva.</p> <p></p> </li> </ol> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket:</p> <ul> <li>A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3</li> <li>Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3.</li> </ul> <p>Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C#  hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#1-feladat-hello-world-net-konzol-alkalmazas-elkeszitese","title":"1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se","text":"<p>A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget.</p> <p>Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti.</p> <p>A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n:</p> <ol> <li>\u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van<ul> <li>Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel<ol> <li>Ind\u00edtsuk el a Visual Studio-t</li> <li>A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban Create new project</li> </ol> </li> <li>M\u00e1r fut\u00f3 Visual Studio-ban<ol> <li>File / New-Project</li> </ol> </li> </ul> </li> <li> <p>A Create new project var\u00e1zsl\u00f3ban a Console app (\u00e9s NEM a Console app (.NET Framework) sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d.</p> <p></p> </li> <li> <p>Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon:</p> <ol> <li>Project name: Hello World</li> <li>Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. <li>Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk)</li> <li>Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge).</li> <li> <p>Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon:</p> <ol> <li>Framework: .NET 8 (Long-term support).</li> <li>A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk).</li> </ol> </li> <p>A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy <code>.sln</code> kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy <code>.exe</code> vagy <code>.dll</code> f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n <code>.csproj</code>.</p> <p>A <code>Program.cs</code> f\u00e1jlunk tartalma a k\u00f6vetkez\u0151:</p> Program.cs<pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> <p>Vegy\u00fcnk fel egy <code>Console.ReadKey()</code> sort:</p> <pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val).</p> <p>A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vteret defini\u00e1lni a <code>namespace</code> kulcssz\u00f3val tudunk. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a <code>using</code> kulcssz\u00f3val tudjuk.  pl.:</p> <pre><code>using System.Collections.Generic;\n</code></pre> </li> <li> <p>Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus <code>Main</code> nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy <code>Program</code> nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A <code>Main</code> f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy <code>string[]</code>-\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat.</p> </li> <li>.NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a <code>System</code> n\u00e9vt\u00e9r <code>Console</code> oszt\u00e1lya haszn\u00e1land\u00f3. A <code>WriteLine</code> statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a <code>ReadKey</code> m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk.</li> </ol> <p>Top level statements, Implicit \u00e9s static usings \u00e9s n\u00e9vterek</p> <p>A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a <code>Program.cs</code> f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna:</p> <pre><code>// See https://aka.ms/new-console-template for more information\nConsole.WriteLine(\"Hello World!\");\n</code></pre> <p>Ez  m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti <code>Program</code> oszt\u00e1lyt \u00e9s ebben <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g):</p> <ul> <li>Top level statements. Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/<code>Main</code> \u00e9s egy\u00e9b  f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus <code>Main</code> f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d.</li> <li>Implicit global usings. Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a global using utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. <code>System.IO</code>, <code>System.Collections.Generic</code> stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni.</li> <li> <p>Static using. Lehet\u0151s\u00e9g\u00fcnk van C#-ban n\u00e9vterek helyett statikus oszt\u00e1lyokat is usingolni, \u00edgy azokat a haszn\u00e1latuk sor\u00e1n nem fontos ki\u00edrni. Gyakori eset erre a <code>Console</code> vagy a <code>Math</code> oszt\u00e1ly usingol\u00e1sa.</p> <pre><code>using static System.Console;\n\nnamespace ConsoleApp12\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine(\"Hello, World!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>F\u00e1jl szint\u0171 n\u00e9vterek. C# 10-ben szint\u00e9n egy egyszer\u0171s\u00edt\u00e9st kapunk a n\u00e9vterek deklar\u00e1l\u00e1sa sor\u00e1n, mert m\u00e1r nem k\u00f6telez\u0151 a kapcsos z\u00e1r\u00f3jeleket kitenni, \u00edgy az adott namespace a teljes f\u00e1jlra \u00e9rv\u00e9nyes lesz pl.:</p> <pre><code>namespace HelloWorld;\n\ninternal class Program\n{\n    // ...\n}\n</code></pre> </li> </ul> <p>Inconsistent visibility vagy inconsistent accessibility hiba</p> <p>A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk inconsistent visibility-re vagy inconsistent accessibility-re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra:</p> <ul> <li><code>internal</code> vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten,  bel\u00fcl l\u00e1that\u00f3</li> <li><code>public</code>: a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3</li> </ul> <p>A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.:</p> <pre><code>public class HardDisk\n{\n    // ...\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#elmeleti-attekintes","title":"Elm\u00e9leti \u00e1ttekint\u00e9s","text":"<p>Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#a-az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete-hallgato","title":"A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]*","text":"<p>Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata. Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#b-interfesz-es-absztrakt-ososztaly-hallgato","title":"B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]*","text":"<p>Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly.</p> <p>T\u00e9mak\u00f6r\u00f6k:</p> <ul> <li>Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven</li> <li>Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven</li> <li>Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#2-feladat-az-uml-es-a-kod-kapcsolatanak-szemleltetese","title":"2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#feladat-leirasa-equipment-inventory","title":"Feladat le\u00edr\u00e1sa - Equipment inventory","text":"<p>Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben:</p> <ul> <li>K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a <code>HardDisk</code>, <code>SoundCard</code> \u00e9s <code>LedDisplay</code> t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal.</li> <li>Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a <code>HardDisk</code> eset\u00e9ben a kapacit\u00e1s).</li> <li>Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is.</li> <li>List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket.</li> <li>A <code>LedDisplay</code> oszt\u00e1lynak k\u00f6telez\u0151en egy <code>DisplayBase</code> oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a <code>DisplayBase</code> oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer  - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a <code>DisplayBase</code>-b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk.</li> </ul> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra.</p> <p>A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#class-diagram","title":"Class Diagram","text":"<p>Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t, melyet a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket k\u00f6vetve tudunk megtenni.</p> <p>Ehhez kl\u00f3nozzuk le a kiindul\u00f3 projekt online GitHub rendszerben el\u00e9rhet\u0151 Git repositoryj\u00e1t a <code>C:\\Work</code> mapp\u00e1n bel\u00fcl egy \u00faj saj\u00e1t mapp\u00e1ba: pl.: <code>C:\\Work\\NEPTUN\\lab1</code>. Ebben az \u00faj mapp\u00e1ban nyissunk meg egy command line-t vagy powershellt \u00e9s futtassuk az al\u00e1bbi git parancsot:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git\n</code></pre> <p>Note</p> <p>A Git-r\u0151l, mint forr\u00e1sk\u00f3dkezel\u0151 rendszerr\u0151l, az els\u0151 h\u00e1zi feladat kontextus\u00e1ban olvashatunk majd b\u0151vebben.</p> <p>Nyissuk meg a lekl\u00f3nozott mapp\u00e1ban tal\u00e1lhat\u00f3 src/EquipmentInventory.sln Visual Studio solutiont.</p> <p>A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot.</p> <p>Class Diagram hi\u00e1nyz\u00f3 sablon</p> <p>Ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben.</p> <p>Ekkor a Solution Explorerben megjelenik a <code>Main.cd</code> diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&amp;drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el):</p> <p></p> <p>Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk:</p> <ul> <li>A <code>SoundCard</code>, <code>HardDisk</code> \u00e9s <code>LedDisplay</code> oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel.</li> <li>Az <code>LedDisplay</code> a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a <code>DisplayBase</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik.</li> <li>Az <code>EquipmentInventory</code> felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva.</li> <li>Tal\u00e1lunk egy <code>IEquipment</code> interf\u00e9szt, <code>GetAge</code> \u00e9s <code>GetPrice</code> m\u0171veletekkel</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#equipmentinventory","title":"EquipmentInventory","text":"<p>\u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az <code>EquipmentInventory</code> oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen.</p> <p>Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. <code>EquipmentBase</code>) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az <code>LedDisplay</code> oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt <code>DisplayBase</code>, \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett <code>EquipmentBase</code>. Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a <code>DisplayBase</code>-t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az <code>IEquipment</code> interf\u00e9szt.</p> <p>Vegy\u00fcnk fel egy <code>IEquipment</code> t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az <code>EquipmentInventory</code> oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen <code>private</code>. A neve legyen <code>equipment</code> (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View / Other Windows / Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg.</p> <p></p> <p>A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t <code>List&lt;IEquipment&gt;</code>. A .NET <code>List</code> t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az <code>ArrayList</code>). A diagramon az <code>EquipmentInventory</code> oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature-t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja.</p> <p></p> <p>Az <code>EquipmentInventory</code> oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban:</p> <pre><code>class EquipmentInventory\n{\n    private List&lt;IEquipment&gt; equipment;\n</code></pre> <p>Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont. M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az <code>IEquipment</code> interf\u00e9szt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re:</p> <p></p> <p>A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy  a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az <code>IEquipment</code> v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve.</p> <p>Navig\u00e1ljunk el az <code>EquipmentInventory</code> forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az <code>equipment</code> gy\u0171jtem\u00e9nyt!</p> <pre><code>public EquipmentInventory()\n{\n    equipment = new List&lt;IEquipment&gt;();\n}\n</code></pre> <p>Ezut\u00e1n \u00edrjuk meg a <code>ListAll</code> met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket:</p> <pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Az elemeken a <code>foreach</code> utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A <code>foreach</code> utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az <code>in</code> kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az <code>in</code> el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben <code>IEquipment eq</code>), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel.</p> <p>A <code>Console.WriteLine</code> m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket <code>{}</code> k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek <code>$</code> jellel kell kezd\u0151dnie.</p> <p>\u00cdrjunk meg egy <code>AddEquipment</code> nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe:</p> <pre><code>public void AddEquipment(IEquipment eq)\n{\n     equipment.Add(eq);\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#iequipment-megvalositok","title":"IEquipment megval\u00f3s\u00edt\u00f3k","text":"<p>Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az <code>IEquipment</code> interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a <code>SoundCard</code>, mind a <code>HardDisk</code> oszt\u00e1ly rendelkezik <code>GetAge()</code> \u00e9s <code>GetPrice()</code> met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az <code>IEquipment</code> interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat:</p> <pre><code>public class SoundCard : IEquipment\n</code></pre> <pre><code>public class HardDisk : IEquipment\n</code></pre> <p>Ezt k\u00f6vet\u0151en a <code>SoundCard</code> \u00e9s <code>HardDisk</code> oszt\u00e1lyban implement\u00e1lnunk kell az <code>IEquipment</code> interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a <code>GetPrice</code> \u00e9s <code>GetAge</code> f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen.</p> <p>Pr\u00f3bak\u00e9ppen a <code>Program.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy <code>EquipmentInventory</code> objektumot, t\u00f6lts\u00fck fel <code>HardDisk</code> \u00e9s <code>SoundCard</code> objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra!</p> <pre><code>static void Main( string[] args )\n{\n    EquipmentInventory ei = new EquipmentInventory();\n\n    ei.AddEquipment(new HardDisk(2021, 30000, 80));\n    ei.AddEquipment(new HardDisk(2020, 25000, 120));\n    ei.AddEquipment(new HardDisk(2020, 25000, 250));\n\n    ei.AddEquipment(new SoundCard(2021, 8000));\n    ei.AddEquipment(new SoundCard(2020, 7000));\n    ei.AddEquipment(new SoundCard(2020, 6000));\n\n    ei.ListAll();\n}\n</code></pre> <p>Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik:</p> <p></p> <p>Folytassuk a munk\u00e1t a <code>LedDisplay</code> oszt\u00e1llyal. A <code>DisplayBase</code> \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a <code>LedDisplay</code> oszt\u00e1lyunk fogja az <code>IEquipment</code> interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en:</p> <pre><code>public class LedDisplay : DisplayBase, IEquipment\n</code></pre> <p>A <code>LedDisplay</code> oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket:</p> <pre><code>public double GetPrice()\n{\n    return this.price;\n}\n\npublic int GetAge()\n{\n    return DateTime.Today.Year - this.manufacturingYear;\n}\n</code></pre> <p>B\u0151v\u00edts\u00fck a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t <code>LedDisplay</code> objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra!</p> <pre><code>ei.AddEquipment(new LedDisplay(2020, 80000, 17, 16));\nei.AddEquipment(new LedDisplay (2021, 70000, 17, 12));\n\nei.ListAll();\nConsole.ReadKey();\n</code></pre> <p>Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#3-feladat-az-interfesz-es-az-absztrakt-ososztaly-alkalmazastechnikaja","title":"3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#interfesz-problematikaja","title":"Interf\u00e9sz problematik\u00e1ja","text":"<p>\u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat.</p> <p>Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val:</p> <ul> <li>A <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis <code>LedDisplay</code>-t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni.</li> <li>A <code>GetAge</code> f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis <code>LedDisplay</code>-t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d.</li> <li>A konstruktorok <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban.</li> </ul> <p>B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak.</p> <p>A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy <code>GetDescription</code> nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel.  Vegy\u00fcnk is fel egy <code>GetDescription</code> f\u00fcggv\u00e9nyt az interf\u00e9szbe!</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription();\n}\n</code></pre> <p>Ekkor minden <code>IEquipment</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A Build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a <code>GetDescription</code> felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk.</p> <p>Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa</p> <p>\u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja. B\u0151vebben inform\u00e1ci\u00f3 itt:  default interface methods.</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription() { return \"EquipmentBase\"; }\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#absztrakt-osztaly","title":"Absztrakt oszt\u00e1ly","text":"<p>Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az <code>LedDisplay</code> oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett <code>GetDescription</code> m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve <code>EquipmentBase</code>. K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az <code>IEquipment</code> interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj <code>EquipmentBase</code> oszt\u00e1llyal. Az <code>IEquipment</code> interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a <code>DisplayBase</code>: emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is <code>IEquipment</code> interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre.</p> <p>\u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox-b\u00f3l drag&amp;drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen <code>EquipmentBase</code>.</p> <p></p> <p>A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a <code>SoundCard</code> \u00e9s a <code>HardDisk</code> oszt\u00e1lyok sz\u00e1rmazzanak az <code>EquipmentBase</code>-b\u0151l (a <code>LedDisplay</code>-nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox-ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a <code>SoundCard</code> \u00e9s <code>HardDisk</code> eset\u00e9ben egyar\u00e1nt.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a <code>HardDisk</code> \u00e9s <code>SoundCard</code> val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az <code>IEquipment</code> interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az <code>EquipmentBase</code> egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az <code>EquipmentBase</code>-b\u0151l az <code>IEquipment</code>-be, vagy az <code>EquipmentBase</code> forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az <code>IEquipment</code> megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja).</p> <p>A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki:</p> <p></p> <pre><code>public abstract class EquipmentBase : IEquipment\n</code></pre> <pre><code>public class HardDisk : EquipmentBase\n</code></pre> <pre><code>public class SoundCard : EquipmentBase\n</code></pre> <p>A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az <code>EquipmentBase</code> implement\u00e1lja az <code>IEquipment</code> interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en:</p> <ul> <li>A <code>newPrice</code> \u00e9s <code>yearOfCreation</code> duplik\u00e1lva vannak a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s <code>EquipmentBase</code> \u0151sbe, \u00e9s <code>protected</code> l\u00e1that\u00f3s\u00e1got adjunk meg.</li> <li>A <code>GetAge</code> m\u0171velet duplik\u00e1lva van a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az <code>EquipmentBase</code> oszt\u00e1lyba.</li> <li>A <code>GetPrice</code> m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet.</li> <li>A <code>GetDescription</code> eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra.</li> </ul> <p>A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151:</p> <pre><code>public abstract class EquipmentBase : IEquipment\n{\n    protected int yearOfCreation;\n    protected int newPrice;\n\n    public int GetAge()\n    {\n        return DateTime.Today.Year - yearOfCreation;\n    }\n\n    public abstract double GetPrice();\n\n    public virtual string GetDescription()\n    {\n        return \"EquipmentBase\";\n    }\n}\n</code></pre> <p>N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an:</p> <ul> <li>Az absztrakt oszt\u00e1lyok eset\u00e9ben az <code>abstract</code> kulcssz\u00f3t ki kell \u00edrni a <code>class</code> sz\u00f3 el\u00e9.</li> <li>Az absztrakt m\u0171veletek eset\u00e9ben az <code>abstract</code> kulcssz\u00f3t kell megadni</li> <li>.NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a <code>virtual</code> kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#leszarmazottak","title":"Lesz\u00e1rmazottak","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az <code>EquipmentBase</code> lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az <code>override</code> kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a <code>GetPrice</code> m\u0171veletet defini\u00e1ljuk fel\u00fcl:</p> HardDisk.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0\n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 5000;\n}\n</code></pre> SoundCard.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0 \n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 2000;\n}\n</code></pre> <p>A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a <code>GetDescription</code> m\u0171veletet \u00edrjuk meg a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az <code>override</code> kulcssz\u00f3t:</p> HardDisk.cs<pre><code>public override string GetDescription()\n{\n    return \"Hard Disk\";\n}\n</code></pre> SoundCard.cs<pre><code>public override string GetDescription()\n{\n    return \"Sound Card\";\n}\n</code></pre> <p>Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az <code>override</code> sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#leddisplay-ose","title":"LedDisplay \u0151se","text":"<p>A <code>LedDisplay</code> oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmaztatni. A <code>GetAge</code> m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a <code>LedDisplay</code> eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!).</p> <p>Note</p> <p>Val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. <code>EquipmentBase</code>) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az <code>EquipmentBase.GetAge</code> \u00e9s a <code>LedDisplay.GetAge</code> ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra.</p> <p>A <code>LedDisplay</code> oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a <code>GetDescription</code> meg\u00edr\u00e1s\u00e1val:</p> LedDisplay.cs<pre><code>public string GetDescription()\n{\n    return \"Led Display\";\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy itt NEM adtuk meg az <code>override</code> kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az <code>override</code>-ot nem kell/szabad ki\u00edrni.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#getdescription-hasznalata","title":"GetDescription haszn\u00e1lata","text":"<p>M\u00f3dos\u00edtsuk az <code>EquipmentInventory.ListAll</code> m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre:</p> EquipmentInventory.cs<pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" +\n            $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>\u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor:</p> <p></p>"},{"location":"labor/1-model-es-kod-kapcsolata/#konstruktor-kodduplikacio","title":"Konstruktor k\u00f3dduplik\u00e1ci\u00f3","text":"<p>A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi <code>EquipmentBase</code> lesz\u00e1rmazott (<code>HardDisk</code>, <code>SoundCard</code>) konstruktor\u00e1ban ott van ez a k\u00e9t sor:</p> <pre><code> this.yearOfCreation = yearOfCreation;\n this.newPrice = newPrice;\n</code></pre> <p>Ha belegondolunk, ezek a <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az <code>EquipmentBase</code>-ben:</p> EquipmentBase.cs<pre><code>public EquipmentBase(int yearOfCreation, int newPrice)\n{\n    this.yearOfCreation = yearOfCreation;\n    this.newPrice = newPrice;\n}\n</code></pre> <p>A <code>HardDisk</code> \u00e9s <code>SoundCard</code> lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a <code>base</code> kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t:</p> HardDisk.cs<pre><code>public HardDisk(int yearOfCreation, int newPrice, int capacityGB)\n    : base(yearOfCreation, newPrice)\n{\n    this.capacityGB = capacityGB;\n}\n</code></pre> SoundCard.cs<pre><code>public SoundCard(int yearOfCreation, int newPrice)\n    : base(yearOfCreation, newPrice)\n{\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#ertekeles","title":"\u00c9rt\u00e9kel\u00e9s","text":"<p>Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk:</p> <ul> <li><code>IEquipment</code> interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni).</li> <li>Az <code>EquipmentBase</code> absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t.</li> <li>Az <code>EquipmentBase</code> absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett <code>IEquipment</code> m\u0171veletek eset\u00e9ben (pl. <code>GetDescripton</code>), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden <code>IEquipment</code> implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni.</li> </ul> <p>Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra:</p> <p></p> <p>C# 11 - Statikus interf\u00e9szek</p> <p>A C# 11 leg\u00fajabb \u00fajdons\u00e1ga a statikus interf\u00e9sz tagok defini\u00e1l\u00e1sa, amivel olyan tagokat k\u00f6vetelhet\u00fcnk meg az implement\u00e1l\u00f3 oszt\u00e1lyt\u00f3l, amelyek nem az objektum p\u00e9ld\u00e1nyra vonatkoznak, hanem az oszt\u00e1lynak kell egy adott statikus taggal rendelkeznie. B\u0151vebben</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#megjegyzes-opcionalis-hazi-gyakorlo-feladat","title":"Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat","text":"<p>Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. <code>HardDisk</code> eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az <code>EqipmentInventory</code> oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en:</p> <ul> <li>Bevezethet\u00fcnk ehhez az <code>IEquipment</code> interf\u00e9szbe egy <code>GetFormattedString</code> m\u0171veletet, mely egy <code>string</code> t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a <code>System.Object ToString()</code> m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a <code>System.Object</code>-b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis <code>ToString()</code> m\u0171velete.</li> <li>Az <code>EquipmentBase</code>-ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t.</li> <li>Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a <code>base</code> kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/","title":"1. Relationship between the model and the code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#the-goal-of-the-exercise","title":"The goal of the exercise","text":"<p>The goal of the exercise:</p> <ul> <li>Getting to know the students/trainer</li> <li>Clarification of the requirements for exercises</li> <li>Getting started with Visual Studio and .NET application development.</li> <li>Building a simple Hello World .NET application, C# basics</li> <li>Illustrating the relationship between UML and code</li> <li>The interface and the abstract primitive class application technique</li> </ul> For teachers <p>While there will certainly be some students who have used the Visual Studio environment before, in Prog2 (C++) or for other reasons, there will almost certainly be others who have not used it or who remember it less. The goal here is to get familiar with the interface, so as you work through the exercises, you will be introduced to the things you use (e.g. Solution Explorer, F5 running, using breakpoints, etc.) to build your first C# application.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#prerequisites","title":"Prerequisites","text":"<p>The tools needed to carry out the exercise:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>The latest version of Visual Studio should be installed. The Community Edition, Professional and Enterprise versions are also suitable. The Community Edition is free and can be downloaded from the Microsoft website. The Professional is paid, but it is also available free of charge to students of the university (on the website, as part of the Azure Dev Tools for Teaching programme).</p> <p>Visual Studio Class Diagram support</p> <p>For some of the exercises in this exercise (and also for the first homework) we will use the Visual Studio Class Designer support. Visual Studio does not always add the Class Designer component during installation. If it is not possible to add a Class Diagram to your Visual Studio project (because the Class Diagram is not listed in the list of the window that appears during the Add New Item command - more on this later in this guide), you will need to install the Class Diagram component later:</p> <ol> <li>Start the Visual Studio installer (e.g. by typing \"Visual Studio Installer\" in the Windows Start menu).</li> <li>In the window that appears, select the \"Individual components\" tab</li> <li> <p>In the search box, type \"class designer\" and then make sure that \"Class Designer\" is unchecked in the filtered list.</p> <p></p> </li> </ol> <p>What you should check out:</p> <ul> <li>The exercise does not include a lecture on the subject. At the same time, the exercise builds on basic UML knowledge and the basics of mapping UML class diagrams to code.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#course-of-exercise","title":"Course of exercise","text":"<p>The trainer will summarise the requirements for the exercises at the beginning of the exercise:</p> <ul> <li>Most of these can be found in the fact sheet</li> <li>Information on homework is available on the subject's website.</li> </ul> <p>Using Visual Studio development tool, we will build .NET applications in C#. C# is similar to Java, we will gradually learn the differences. The tutorial is guided, with instructions from the tutor, and the tasks are done together.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#solution","title":"Solution","text":"Download the finished solution <p> It is essential that you follow the lab guide during the lab, it is forbidden (and pointless) to download the ready-made solution. However, during subsequent self-practice, it can be useful to review the ready-made solution, so we make it available.</p> <p>The solution is available on GitHub. The easiest way to download it is to clone it from the command line to your machine using the <code>git clone</code> command:</p> <p><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo -b solved</code></p> <p>You need to have git installed on your machine, more information here.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#1-task-build-a-hello-world-net-console-application","title":"1. Task - Build a \"Hello world\" .NET console application","text":"<p>The task is to create a C# console application that prints the text \"Hello world!\" to the console.</p> <p>The application is written in C#. The compiled application is run by the .NET runtime. The theoretical background of compiling/running and the basics of .NET are covered in the first lecture.</p> <p>The steps to create a solution and a project within it in Visual Studio 2022:</p> <ol> <li>Start a new project wizard, which can be done in two ways<ul> <li>Using the startup window<ol> <li>Launch Visual Studio</li> <li>In the right-hand sidebar of the launch window that appears Create new project</li> </ol> </li> <li>Already running in Visual Studio<ol> <li>File / New-Project</li> </ol> </li> </ul> </li> <li> <p>In the Create new project wizard, select the Console app (and NOT the Console app (.NET Framework) template, including the C# one. That it is C# is indicated by the top left corner of the template icon. If you don't see it in the list, you have to search/filter for it. You can search for it by typing \"console\" in the top search bar. Or by using the drop-down boxes below: in the first (language selector) \"C#\", in the third (project type selector) \"Console\".</p> <p>Creating a project</p> </li> <li> <p>Next button at the bottom of the wizard window, on the next wizard page:</p> <ol> <li>Project name: Hello World</li> <li>Location: in the labs, work in the c:\\work\\ folder, you have write access to it. <li>Solution name: Hello World (this should be written in by the time we get here)</li> <li>Place solution and project in the same directory: no tick (but not particularly significant).</li> <li> <p>Next button at the bottom of the wizard window, on the next wizard page:</p> <ol> <li>Framework: .NET 8 (Long-term support).</li> <li>Check the \"Do not use top level statements\" checkbox (we'll explain this in a moment).</li> </ol> </li> <p>The project also creates a new solution, whose structure can be viewed in the Visual Studio Solution Explorer window. A solution can consist of several projects, and a project can consist of several files. A solution is a summary of the entire working environment (it includes a file with the extension <code>.sln</code>), while the output of a project is typically a file <code>.exe</code> or <code>.dll</code>, i.e. a component of a complex application/system. The project file extension for C# applications is <code>.csproj</code>.</p> <p>The content of our <code>Program.cs</code> file is as follows:</p> Program.cs<pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> <p>Take a <code>Console.ReadKey()</code> line:</p> <pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Run the application (e.g. using the F5 key).</p> <p>The structure of the code is very similar to Java and C++. Our classes are organised into namespaces. You can define a namespace with the keyword <code>namespace</code>. You can \"scope\" namespaces with the <code>using</code> keyword. e.g:</p> <pre><code>using System.Collections.Generic;\n</code></pre> </li> <li> <p>In a console C# application, you specify the entry point of your application by writing a static function called <code>Main</code>. Our class name can be anything, VS generated a class called <code>Program</code> in our case. The parameter list of the <code>Main</code> function is bound: either no parameters are given, or a <code>string[]</code> is given, in which the command line arguments are given at runtime.</p> </li> <li>in .NET, the <code>Console</code> class of the <code>System</code> namespace is used to handle standard input and output. With the static operation <code>WriteLine</code> you can write a line, with <code>ReadKey</code> you can wait for a key to be pressed.</li> </ol> <p>Top level statements, Implicit and static usings and namespaces</p> <p>When the project was created, we previously checked the \"Do not use top level statements\" checkbox. If we had not done this, we would have found only one meaningful line in our <code>Program.cs</code> file:</p> <pre><code>// See https://aka.ms/new-console-template for more information\nConsole.WriteLine(\"Hello World!\");\n</code></pre> <p>This is functionally equivalent to the code above containing the <code>Program</code> class and its <code>Main</code> function. Let's look at what makes this possible (you can read more about them here https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements, both new in C# 10):</p> <ul> <li>Top level statements. The idea is that you can write code directly in a single source file without any class/<code>Main</code> and other function definitions in the project. In this case, behind the scenes, the compiler puts this into a static <code>Main</code> function of a class we don't see. The motivation for its introduction was to reduce boilerplate code for very simple, \"script-like\" applications.</li> <li>Implicit global usings. Depending on exactly what project type you have created, certain base namespaces will be automatically using behind the scenes in all source files (the compiler uses the global using directive for this). The point is: this way, developers don't have to use certain frequently used namespaces (e.g. <code>System.IO</code>, <code>System.Collections.Generic</code>, etc.) as source files.</li> <li> <p>Static using. It is possible to use static classes instead of namespaces in C#, so it is not important to write them when using them. A common case is the use of the <code>Console</code> or <code>Math</code> class.</p> <pre><code>using static System.Console;\n\nnamespace ConsoleApp12\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine(\"Hello, World!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>File-level namespaces. In C# 10, we also get a simplification when declaring namespaces, because it is no longer mandatory to use brackets, so the given namespace will be valid for the whole file, e.g.:</p> <pre><code>namespace HelloWorld;\n\ninternal class Program\n{\n    // ...\n}\n</code></pre> </li> </ul> <p>Inconsistent visibility or inconsistent accessibility error</p> <p>During the semester, you may encounter translation error messages complaining about inconsistent visibility or inconsistent accessibility when implementing programming tasks. This phenomenon is due to the possibility to control the visibility of each type (class, interface, etc.) in a .NET environment:</p> <ul> <li><code>internal</code> or no visibility is specified: the type is visible only inside the assembly (.exe, .dll)/project</li> <li><code>public</code>: the type is visible to other assemblies/projects</li> </ul> <p>The easiest way to avoid this error is to define all our types as public, e.g.:</p> <pre><code>public class HardDisk\n{\n    // ...\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#theoretical-overview","title":"Theoretical overview","text":"<p>The sub-chapters do not contain exercises, but provide students with an introduction to the related theoretical topics, illustrated with examples.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#a-theory-of-the-relationship-between-the-uml-class-diagram-and-code-student","title":"A) Theory of the relationship between the UML class diagram and code [student]*","text":"<p>The material is available here: The relationship between the UML class diagram and code. The relationship between the UML class diagram and code. This topic was covered in the previous semester in the Software Engineering course.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#b-interface-and-abstract-parent-class-student","title":"B) Interface and abstract (parent) class [student]*","text":"<p>The material is available here: Interface and abstract (base) class.   Interface and abstract (base) class.</p> <p>Topics:</p> <ul> <li>Abstract class concept and definition in C#</li> <li>Interface concepts and definitions in C#</li> <li>Comparison of abstract base class and interface</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#2-task-illustrate-the-relationship-between-uml-and-code","title":"2. Task - Illustrate the relationship between UML and code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#task-description-equipment-inventory","title":"Task description - Equipment inventory","text":"<p>Task: We were asked to develop a computer parts inventory application. Read more:</p> <ul> <li>You need to be able to handle different types of parts. Initially, <code>HardDisk</code>, <code>SoundCard</code> and <code>LedDisplay</code> types should be supported, but the system should be easily extensible to new types.</li> <li>The data related to the parts are: year of purchase, age (calculated), purchase price and current price (calculated), but may also include type-specific data (e.g. capacity for <code>HardDisk</code>).</li> <li>The actual price depends on the type of part, the purchase price and the year of production of the part. For example, the older the part, the bigger the discount, but the discount depends on the part type.</li> <li>You must be able to list the parts in stock.</li> <li>The <code>LedDisplay</code> class must be derived from an <code>DisplayBase</code> class, and the source code of the <code>DisplayBase</code> class cannot be changed. In this example this does not make much sense, but in practice we often encounter similar situations where the framework/platform we are using requires us to derive from a built-in class. Typically, this is the case when working with windows, forms, custom control types: we have to derive them from the framework's built-in classes, and we don't have (or at least certainly don't want to change) the source code of the framework - e.g. Java, .NET. In our example, we simulate this situation by specifying a derivation from <code>DisplayBase</code>.</li> </ul> <p>The implementation is simplified considerably: the parts are only stored in memory, and the listing is as simple as possible, simply by writing the data of the registered parts to the console.</p> <p>During the initial discussions, we receive the following information from the client: an internal staff member has already started the development, but due to lack of time, they have only reached a half-finished solution. Part of our task is to understand the semi-finished solution and to implement the task from there.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#class-diagram","title":"Class Diagram","text":"<p>Let's open the source code solution from our customer, which we can do by following the steps below.</p> <p>To do this, clone the Git repository of the initial project, available online on GitHub, to a new folder of its own within <code>C:\\Work</code>: e.g: <code>C:\\Work\\NEPTUN\\lab1</code>. In this new folder, open a command line or powershell and run the following git command:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git\n</code></pre> <p>Note</p> <p>You will read more about Git as a source code management system in the context of the first homework assignment.</p> <p>Open the Visual Studio solution src/EquipmentInventory.sln in the cloned folder.</p> <p>In Solution Explorer, run through the files by eye. It would help to understand the relationships between classes by displaying them on a class diagram. Let's include a class diagram in our project. In the Solution Explorer, right-click on the project (not the solution!), select Add/New Item from the pop-up menu, then in the window that appears, select Class Diagram, enter Main.cd as the name of the diagram at the bottom of the window, and OK-close the window.</p> <p>Missing Class Diagram template</p> <p>If the Class Diagram item does not appear in the list, then the appropriate component of VS is not installed. You can read more about this in the Prerequisites section of this document.</p> <p>The chart file <code>Main.cd</code> will then appear in Solution Explorer, double-click on it to open it. Our chart is currently empty. From Solution Explorer, drag&amp;drop the .cs source files onto the diagram. VS then looks at what classes are in these source files and decomposes them into UML classes. Build the layout as shown in the following figure (you can display the members of the classes by clicking on the double arrow in the top right corner of their rectangle):</p> <p>Starting class diagram</p> <p>You can also view the source code for the classes, either by double-clicking on the corresponding class on the diagram or by opening the .cs files from Solution Explorer. Here's what we see:</p> <ul> <li>The <code>SoundCard</code>, <code>HardDisk</code> and <code>LedDisplay</code> classes are relatively well developed, with the necessary attributes and query functions.</li> <li>The <code>LedDisplay</code> is derived from the <code>DisplayBase</code> class as required.</li> <li><code>EquipmentInventory</code> is responsible for the inventory of parts in stock, but practically none of this is implemented.</li> <li>We find an interface <code>IEquipment</code> with operations <code>GetAge</code> and <code>GetPrice</code></li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#equipmentinventory","title":"EquipmentInventory","text":"<p>Let's start working on a solution. First, let's lay down the basic concepts. In the <code>EquipmentInventory</code> class, we store a heterogeneous collection of different types of equipment. This is the key to consistent parts management, so that our solution can be easily extended with new parts types.</p> <p>As discussed earlier, unified management can be achieved either by implementing a common base class or a common interface. In our case, the common base class (e.g. <code>EquipmentBase</code>) seems to be dropped, because by introducing it, the <code>LedDisplay</code> class would have two base classes: the mandatory <code>DisplayBase</code>, and the <code>EquipmentBase</code> that we introduce for uniform management. This is not possible, in a .NET environment a class can have only one base class. The solution to modify <code>DisplayBase</code> to be derived from <code>EquipmentBase</code> is not possible according to our requirement (it was a requirement that its source code cannot be modified). This leaves the interface-based approach. This was probably the conclusion of the previous developer of the application, which is why he introduced the <code>IEquipment</code> interface.</p> <p>Add a generic list of items of type <code>IEquipment</code> (not property but field!) to the <code>EquipmentInventory</code> class. Its visibility - in an effort to be unified - should be <code>private</code>. The name should be <code>equipment</code> (no \"s\" at the end, in English the plural of equipment is also equipment). To add a member variable, we use the Visual Studio Class Details window. If the window is not visible, it can be displayed by selecting View / Other Windows / Class Details.</p> <p>Class Details</p> <p>The member variable type is therefore <code>List</code>. The type of .NET <code>List</code> is a dynamically stretching generic array (like <code>ArrayList</code> in Java). Looking at the <code>EquipmentInventory</code> class in the diagram, we see that only the name of the member variable is displayed, not the type. Right-click on the background of the diagram and select Display Full Signature from the Change Members Format menu. The chart will then display the type of member variables and the full signature of the operations.</p> <p>EquipmentInventory</p> <p>By double-clicking on the <code>EquipmentInventory</code> class, you can navigate to the source code, and as you can see, it does indeed appear in the code as a member variable of type list:</p> <pre><code>class EquipmentInventory\n{\n    private List&lt;IEquipment&gt; equipment;\n</code></pre> <p>On the one hand, we're happy about this because Visual Studio supports round-trip engineering: changes to the model are immediately reflected in the code, and vice versa. On the other hand, we have previously discussed that if a class has a collection of members from another class, then it \"fits\" in the UML model as a type 1-more association relation between the two classes. This is not yet the case in our model. Fortunately, the VS modelling interface can be made to display this type of connection in this form. To do this, right-click on the equipment tag variable on the diagram and select Show as Collection Association from the menu. The <code>IEquipment</code> interface should then be moved to the right to allow enough space on the diagram to display the association relationship and the role on the relationship:</p> <p>Collection association</p> <p>The double arrow ending on the \"plural\" side is not standard UML, but don't be too sad about it, it's not important. We are certainly pleased that the arrow representing the relationship at the end of the <code>IEquipment</code> role shows the name (and even the exact type) of the member variable.</p> <p>Navigate to the source code of <code>EquipmentInventory</code> and write the constructor that initializes the <code>equipment</code> collection</p> <pre><code>public EquipmentInventory()\n{\n    equipment = new List&lt;IEquipment&gt;();\n}\n</code></pre> <p>Then write the <code>ListAll</code> method, which prints the age of the elements and their current values:</p> <pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Age: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Iterate through the elements using the <code>foreach</code> statement. When using the <code>foreach</code> statement, the <code>in</code> keyword should be followed by a collection and preceded by a variable declaration (in this case <code>IEquipment eq</code>), where type is the element type of the collection. In each iteration, this variable takes the iteration value of the collection.</p> <p><code>Console.WriteLine</code> is either a simple string or, as in this case, a formatting string. The substitutions are solved by string interpolation: the values to be substituted must be given between <code>`. If string interpolation is used, the string must start with</code>$`.</p> <p>Write a function called <code>AddEquipment</code> that adds a new device to the inventory:</p> <pre><code>public void AddEquipment(IEquipment eq)\n{\n     equipment.Add(eq);\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#iequipment-implementers","title":"IEquipment implementers","text":"<p>We have previously decided to use the <code>IEquipment</code> interface to manage the different component types in a uniform way. In our example, both <code>SoundCard</code> and <code>HardDisk</code> have <code>GetAge()</code> and <code>GetPrice()</code> methods, yet we cannot manage them in a unified way (e.g., store them in a common list). To do this, we need to get both classes to implement the <code>IEquipment</code> interface. Change their source:</p> <pre><code>public class SoundCard : IEquipment\n</code></pre> <pre><code>public class HardDisk : IEquipment\n</code></pre> <p>Then we need to implement the methods in the <code>IEquipment</code> interface in the <code>SoundCard</code> and <code>HardDisk</code> classes. We find that there is nothing to do with this now, the <code>GetPrice</code> and <code>GetAge</code> functions are already written in both places.</p> <p>As a test, in our <code>Main</code> function in <code>Program.cs</code>, create an <code>EquipmentInventory</code> object, populate it with <code>HardDisk</code> and <code>SoundCard</code> objects, and then list the object on the console. If 2021 is not the current year, in the following rows, copy the year 2021 to the current year and the year 2020 to a smaller number!</p> <pre><code>static void Main( string[] args )\n{\n    EquipmentInventory ei = new EquipmentInventory();\n\n    ei.AddEquipment(new HardDisk(2021, 30000, 80));\n    ei.AddEquipment(new HardDisk(2020, 25000, 120));\n    ei.AddEquipment(new HardDisk(2020, 25000, 250));\n\n    ei.AddEquipment(new SoundCard(2021, 8000));\n    ei.AddEquipment(new SoundCard(2020, 7000));\n    ei.AddEquipment(new SoundCard(2020, 6000));\n\n    ei.ListAll();\n}\n</code></pre> <p>Running the application, we find that although our solution is rudimentary, it works:</p> <p>Console output</p> <p>Continue with the <code>LedDisplay</code> class. The <code>DisplayBase</code> base class source code cannot be modified due to requirements. But this doesn't cause any problems, our <code>LedDisplay</code> class will implement the <code>IEquipment</code> interface, so modify the code accordingly:</p> <pre><code>public class LedDisplay : DisplayBase, IEquipment\n</code></pre> <p>In the <code>LedDisplay</code> class, the functions in the interface must already be written:</p> <pre><code>public double GetPrice()\n{\n    return this.price;\n}\n\npublic int GetAge()\n{\n    return DateTime.Today.Year - this.manufacturingYear;\n}\n</code></pre> <p>Let's extend our <code>Main</code> function by adding two <code>LedDisplay</code> objects to our set (again, if 2021 is not the current year, we should rewrite 2021 to the current year in the following lines, and 2020 to a smaller number!</p> <pre><code>ei.AddEquipment(new LedDisplay(2020, 80000, 17, 16));\nei.AddEquipment(new LedDisplay (2021, 70000, 17, 12));\n\nei.ListAll();\nConsole.ReadKey();\n</code></pre> <p>As a test, run the application.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#3-task-application-of-the-interface-and-the-abstract-primitive-class","title":"3. Task - Application of the interface and the abstract primitive class","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#interface-problems","title":"Interface problems","text":"<p>Evaluate our current interface-based solution.</p> <p>One of the main problems is that our code is full of code duplication that destroys maintainability and extensibility:</p> <ul> <li>The <code>yearOfCreation</code> and <code>newPrice</code> tags are common to all part types (except the special <code>LedDisplay</code>), and must be copy-pasted when a new type is introduced.</li> <li>The implementation of the <code>GetAge</code> function is the same for all component types (except for the special <code>LedDisplay</code>), also copy-paste \"propagated\".</li> <li>The lines of the constructors <code>yearOfCreation</code> and <code>newPrice</code> initializing tags are also duplicated in each class.</li> </ul> <p>Although this code duplication does not seem significant at the moment, the situation is getting worse as new component types are introduced, and it is better to prevent future pains in time.</p> <p>The other problem is that the listing of parts data is currently painfully incomplete, with no part type (only age and price). To display the type, the IEquipment interface must be extended, e.g. by introducing an operation called <code>GetDescription</code>.  Let's add a <code>GetDescription</code> function to the interface!</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription();\n}\n</code></pre> <p>Then every class implementing the <code>IEquipment</code> interface would have to implement this method, which is a lot of work for many classes (and often not even feasible for a multi-component application, i.e. one with several DLLs, when they are not in the hands of a single developer). Run the Build command to check that after adding <code>GetDescription</code>, you get compilation errors in three places.</p> <p>Specifying default implementation in interface</p> <p>It is worth knowing that starting from C# 8 (or .NET or .NET Core runtime, not supported under .NET Framework), interface operations can be given default implementation (default interface methods), so to solve the above problem you don't need an abstract class, but interface can no longer have member variables. More information here: default interface methods.</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription() { return \"EquipmentBase\"; }\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#abstract-class","title":"Abstract class","text":"<p>A solution to both problems is the introduction of a common abstract base class (except for the <code>LedDisplay</code> class, which we will come back to). We can move the code common to descendants into it, and provide a default implementation for the newly introduced <code>GetDescription</code> operation. Let our new abstract base class be called <code>EquipmentBase</code>. The question is whether the <code>IEquipment</code> interface is still needed, or whether it can be completely replaced by the new <code>EquipmentBase</code> class. We need to keep the <code>IEquipment</code> interface, because we cannot derive our LedDisplay class from <code>EquipmentBase</code>: it already has a mandatory base class, <code>DisplayBase</code>: for this reason, EquipmentInventory in our enhanced solution also refers to the various components as <code>IEquipment</code> interface.</p> <p>Let's start the transformation. Let our class diagram be the active tab. From the Toolbox, drag&amp;drop an Abstract Class element onto the diagram, name it <code>EquipmentBase</code>.</p> <p>Toolbox - abstract class</p> <p>In the following, we need to make the <code>SoundCard</code> and <code>HardDisk</code> classes derive from <code>EquipmentBase</code> (<code>LedDisplay</code> already has another base class, so we cannot do this there). To do this, select the Inheritance link in the Toolbox, then draw a line from the child class to the base class for both <code>SoundCard</code> and <code>HardDisk</code>.</p> <p>In the next step, let's modify the code so that <code>HardDisk</code> and <code>SoundCard</code> do not implement the <code>IEquipment</code> interface separately, but rather their common base class <code>EquipmentBase</code> implement it once. To do this, modify the EquipmentBase class to implement the interface (either by drawing an inheritance link from <code>EquipmentBase</code> to <code>IEquipment</code> on the diagram, or by modifying the source code of <code>EquipmentBase</code>). Delete the implementation of <code>IEquipment</code> from the <code>HardDisk</code> and <code>SoundCard</code> classes (the base class already implements it).</p> <p>The relevant parts of our diagram and source code will then look like this:</p> <p>EquipmentBase and HardDisk/SoundCard</p> <pre><code>public abstract class EquipmentBase : IEquipment\n</code></pre> <pre><code>public class HardDisk : EquipmentBase\n</code></pre> <pre><code>public class SoundCard : EquipmentBase\n</code></pre> <p>Our code is not yet turning, for several reasons. The <code>EquipmentBase</code> implements the <code>IEquipment</code> interface, but it does not yet implement the interface operations. Either generate the methods using the smart tag, or type them according to the following principles:</p> <ul> <li>The <code>newPrice</code> and <code>yearOfCreation</code> are duplicated in the <code>HardDisk</code> and <code>SoundCard</code> classes: move (not copy!) them to the common <code>EquipmentBase</code> base class and give <code>protected</code> visibility.</li> <li>The <code>GetAge</code> operation is duplicated in the <code>HardDisk</code> and <code>SoundCard</code> classes, delete the implementation from these and move it to the <code>EquipmentBase</code> class.</li> <li>The <code>GetPrice</code> operation is included in the base class as an abstract operation. This is a deliberate design decision, so we force descendant classes to override this operation anyway.</li> <li>In the case of <code>GetDescription</code>, the opposite is true: it is defined as virtual (and not abstract), i.e. we provide an implementation in the base class. This way, descendants are not forced to override the operation.</li> </ul> <p>The code corresponding to the above is:</p> <pre><code>public abstract class EquipmentBase : IEquipment\n{\n    protected int yearOfCreation;\n    protected int newPrice;\n\n    public int GetAge()\n    {\n        return DateTime.Today.Year - yearOfCreation;\n    }\n\n    public abstract double GetPrice();\n\n    public virtual string GetDescription()\n    {\n        return \"EquipmentBase\";\n    }\n}\n</code></pre> <p>Some additional thoughts on the code fragment:</p> <ul> <li>For abstract classes, the keyword <code>abstract</code> must be written before the word <code>class</code>.</li> <li>For abstract operations, the keyword <code>abstract</code> must be specified</li> <li>in a .NET environment, you can control whether an operation is virtual or not. In this respect, it is similar to C++. To make an operation virtual, the keyword <code>virtual</code> must be specified for the operation. Reminder: define an operation as virtual if its descendants overdefine it. Only then is it guaranteed that the descendant version will be called when invoking the given operation on an ancestor reference.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#descendants","title":"Descendants","text":"<p>In the next step, let's move on to the <code>EquipmentBase</code> descendants. When overriding abstract and virtual operations in C#, you must specify the <code>override</code> keyword in the descendant. First, the <code>GetPrice</code> operation is redefined:</p> HardDisk.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0\n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 5000;\n}\n</code></pre> SoundCard.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0 \n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 2000;\n}\n</code></pre> <p>In the next step, the <code>GetDescription</code> operation is written in the <code>HardDisk</code> and <code>SoundCard</code> classes. Since the virtual function of the base class is being overridden here, the <code>override</code> keyword must also be specified:</p> HardDisk.cs<pre><code>public override string GetDescription()\n{\n    return \"Hard Disk\";\n}\n</code></pre> SoundCard.cs<pre><code>public override string GetDescription()\n{\n    return \"Sound Card\";\n}\n</code></pre> <p>One might ask why the designers of the C# language decided to add an extra keyword to the definition of operations, which was not necessary in the case of C++. The reason is simple: the code is more expressive. Looking at the descendant code, the word <code>override</code> immediately makes it clear whether this operation is abstract or virtual in one of the base classes, without having to look at the code of all the ancestors.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#base-class-of-leddisplay","title":"Base class of LedDisplay","text":"<p>The base class of our <code>LedDisplay</code> class is bound, its code cannot be modified, so we cannot derive it from <code>EquipmentBase</code>. We cannot delete the <code>GetAge</code> operation, this code duplication is preserved here (but only for <code>LedDisplay</code>, which is only one class among many!).</p> <p>Note</p> <p>In fact, with a little extra work we could get rid of this duplication. This would require a static helper function in one of the classes (e.g. <code>EquipmentBase</code>), which would get the year of manufacture and return the age. <code>EquipmentBase.GetAge</code> and <code>LedDisplay.GetAge</code> would use this helper function to produce their output.</p> <p>In our <code>LedDisplay</code> class, we are yet to write <code>GetDescription</code>:</p> LedDisplay.cs<pre><code>public string GetDescription()\n{\n    return \"Led Display\";\n}\n</code></pre> <p>Note that we have NOT specified the <code>override</code> keyword here. When an interface function is implemented, <code>override</code> is not required/allowed to be written.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#use-getdescription","title":"Use GetDescription","text":"<p>Modify the <code>EquipmentInventory.ListAll</code> operation to also write the description of the items to the output:</p> EquipmentInventory.cs<pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Description: {eq.GetDescription()}\\t\" +\n            $\"Age: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>This gives a more informative output when the application is run:</p> <p>Console output</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#constructor-code-duplication","title":"Constructor code duplication","text":"<p>Looking at our code, there is one more duplication. All <code>EquipmentBase</code> descendants (<code>HardDisk</code>, <code>SoundCard</code>) have these two lines in their constructor:</p> <pre><code> this.yearOfCreation = yearOfCreation;\n this.newPrice = newPrice;\n</code></pre> <p>If you think about it, these <code>yearOfCreation</code> and <code>newPrice</code> members are defined in the base class, so it should be his responsibility to initialize them anyway. Let's add a corresponding constructor in <code>EquipmentBase</code>:</p> EquipmentBase.cs<pre><code>public EquipmentBase(int yearOfCreation, int newPrice)\n{\n    this.yearOfCreation = yearOfCreation;\n    this.newPrice = newPrice;\n}\n</code></pre> <p>Remove the initialization of the two members from the constructor of the descendants <code>HardDisk</code> and <code>SoundCard</code>, and instead invoke the base class\u2019s constructor by referencing the <code>base</code> keyword:</p> HardDisk.cs<pre><code>public HardDisk(int yearOfCreation, int newPrice, int capacityGB)\n    : base(yearOfCreation, newPrice)\n{\n    this.capacityGB = capacityGB;\n}\n</code></pre> SoundCard.cs<pre><code>public SoundCard(int yearOfCreation, int newPrice)\n    : base(yearOfCreation, newPrice)\n{\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#evaluation","title":"Evaluation","text":"<p>By using a combination of interface and abstract base class, we have managed to develop the solution with the least compromise:</p> <ul> <li>By referring to <code>IEquipment</code> as an interface, we can uniformly handle all types of parts, even those where the base class was bound (using abstract base classes alone would not have achieved this).</li> <li>By introducing the <code>EquipmentBase</code> abstract base class, we were able to put the code common to different part types into a common base, with one exception, thus avoiding code duplication.</li> <li>By introducing the <code>EquipmentBase</code> abstract ancestor, we can specify a default implementation for newly introduced <code>IEquipment</code> operations (e.g. <code>GetDescripton</code>), so we are not forced to specify it in every <code>IEquipment</code> implementation class.</li> </ul> <p>Finally, let's take a look at the UML (like) class diagram of our solution:</p> <p>Ultimate class diagram</p> <p>Static interfaces</p> <p>The latest addition to C# 11 is the definition of static interface members, which allows you to require an implementing class to have members that do not refer to the object instance, but rather the class must have a specific static member. Read more</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#note-optional-homework-exercise","title":"Note - optional homework exercise","text":"<p>Our solution does not support the display of component specific data (e.g. capacity for <code>HardDisk</code>) during listing. To do this, the writing of component data to a formatted string should be moved from the <code>EqipmentInventory</code> class to the component classes, following the principles below:</p> <ul> <li>To do this, we can introduce an <code>GetFormattedString</code> operation in the <code>IEquipment</code> interface, which returns an object of type <code>string</code>. Alternatively, you can override the ToString()<code>operation of</code>System.Object. indeed, in .NET, all types are implicitly derived from <code>System.Object</code>, which has a virtual <code>ToString()</code> operation.</li> <li>In <code>EquipmentBase</code> we write the formatting of the common tags (description, price, age) into a string.</li> <li>If a component also has type-specific data, then its class overrides the function that formats it into a string: this function must first call its ancestor (using the <code>base</code> keyword), then append its own formatted data to it, and return with this string.</li> </ul>"},{"location":"labor/2-nyelvi-eszkozok/","title":"2. Nyelvi eszk\u00f6z\u00f6k","text":""},{"location":"labor/2-nyelvi-eszkozok/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k:</p> <ul> <li>Tulajdons\u00e1g (property)</li> <li>Deleg\u00e1t (delegate, met\u00f3dusreferencia)</li> <li>Esem\u00e9ny (event)</li> <li>Attrib\u00fatum (attribute)</li> <li>Lambda kifejez\u00e9s (lambda expression)</li> <li>Generikus t\u00edpus (generic type)</li> <li>N\u00e9h\u00e1ny tov\u00e1bbi nyelvi konstrukci\u00f3</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 Nyelvi eszk\u00f6z\u00f6k.</p>"},{"location":"labor/2-nyelvi-eszkozok/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Gyakorlat Linuxon vagy macOS alatt</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de az elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is m\u00e1s fejleszt\u0151eszk\u00f6z\u00f6kkel (pl. VS Code, Rider, Visual Studio for Mac), vagy ak\u00e1r egy sz\u00f6vegszerkeszt\u0151vel \u00e9s CLI (parancssori) eszk\u00f6z\u00f6kkel. Ezt az teszi lehet\u0151v\u00e9, hogy a p\u00e9ld\u00e1k egy egyszer\u0171 Console alkalmaz\u00e1s kontextus\u00e1ban ker\u00fclnek ismertet\u00e9sre (nincsenek Windows specifikus elemek),  a .NET 6 SDK pedig t\u00e1mogatott Linuxon \u00e9s macOS alatt. Hello World Linuxon</p>"},{"location":"labor/2-nyelvi-eszkozok/#bevezeto","title":"Bevezet\u0151","text":"<p>Kitekint\u0151 r\u00e9szek</p> <p>Jelen \u00fatmutat\u00f3 t\u00f6bb helyen is b\u0151v\u00edtett ismeretanyagot, illetve extra magyar\u00e1zatot ad meg jelen megjegyz\u00e9ssel egyez\u0151 sz\u00ednnel keretezett \u00e9s ugyanilyen ikonnal ell\u00e1tott form\u00e1ban. Ezek hasznos kitekint\u00e9sek, de nem k\u00e9pezik az alap tananyag r\u00e9sz\u00e9t.</p>"},{"location":"labor/2-nyelvi-eszkozok/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-nyelvieszkozok-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/2-nyelvi-eszkozok/#0-feladat-var-kulcsszo-implicit-tipusu-lokalis-valtozok-implicitly-typed-local-variables","title":"0. Feladat - var kulcssz\u00f3 - Implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3k (implicitly typed local variables)","text":"<p>Egy egyszer\u0171, bemeleg\u00edt\u0151 feladattal kezd\u00fcnk. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l.</p> <ol> <li>Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET alap\u00fat (vagyis ne .NET Framework-\u00f6set):<ul> <li>Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel.</li> <li>A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n.</li> </ul> </li> <li>Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz <code>Person</code> n\u00e9ven.     (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az Add / Class men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk <code>Person.cs</code>-re, majd nyomjuk meg az Add gombot.)</li> <li> <p>Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a <code>public</code> kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor egy k\u00e9s\u0151bbi feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni.</p> <pre><code>public class Person\n{\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat.</p> <pre><code>static void Main(string[] args)\n{\n    Person p = new Person();\n}\n</code></pre> </li> <li> <p>A lok\u00e1lis v\u00e1ltoz\u00f3k t\u00edpus\u00e1nak explicit megad\u00e1sa helyett haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t is:</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n}\n</code></pre> <p>Ezt implicitly typed local variables-nek, magyarul implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3-nak nevezz\u00fck. Ilyenkor a ford\u00edt\u00f3 a kontextusb\u00f3l, az egyenl\u0151s\u00e9gjel jobb oldal\u00e1b\u00f3l megpr\u00f3b\u00e1lja kital\u00e1lni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t, fenti esetben ez egy <code>Person</code> lesz. Fontos, hogy ett\u0151l a nyelv m\u00e9g statikusan tipusos marad (teh\u00e1t nem \u00fagy m\u0171k\u00f6dik mint a JavaScript-es <code>var</code> kulcssz\u00f3), mert a <code>p</code> v\u00e1ltoz\u00f3 t\u00edpusa a k\u00e9s\u0151bbiekben nem v\u00e1ltozhat meg, ez csak egy egyszer\u0171 szintaktikai \u00e9des\u00edt\u0151szer annek \u00e9rdek\u00e9ben, hogy t\u00f6m\u00f6rebben tudjunk lok\u00e1lis v\u00e1ltoz\u00f3kat defini\u00e1lni (ne kelljen a t\u00edpust \"dupl\u00e1n\", az <code>=</code> bal \u00e9s jobb oldal\u00e1n is megadni).</p> <p>Target-typed <code>new</code> expressions</p> <p>Egy m\u00e1sik megk\u00f6zel\u00edt\u00e9s lehet a a C# 9-ben megjelent Target-typed <code>new</code> expressions, ahol a new oper\u00e1tor eset\u00e9n hagyhat\u00f3 el a t\u00edpus, ha az a ford\u00edt\u00f3 \u00e1ltal kital\u00e1lhat\u00f3 a kontextusb\u00f3l (pl.: \u00e9rt\u00e9kad\u00e1s bal oldala, param\u00e9ter t\u00edpusa stb.). A fenti <code>Person</code> konstruktorunk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9zne ki:</p> <pre><code>Person p = new();\n</code></pre> <p>Ennek a megk\u00f6zel\u00edt\u00e9snek az el\u0151nye a <code>var</code>-ral szemben, hogy tagv\u00e1ltoz\u00f3k eset\u00e9ben is alkalmazhat\u00f3.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#1-feladat-tulajdonsag-property","title":"1. Feladat \u2013 Tulajdons\u00e1g (property)","text":"<p>A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de mint l\u00e1tni fogjuk, nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktika tekintet\u00e9ben hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t, s\u0151t k\u00fcl\u00f6n k\u00fcl\u00f6n is meghat\u00e1rozhatjuk a lek\u00e9rdez\u00e9s \u00e9s a be\u00e1ll\u00edt\u00e1s l\u00e1that\u00f3s\u00e1g\u00e1t.</p>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsag-szintaktikaja","title":"Tulajdons\u00e1g szintaktik\u00e1ja","text":"<p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, <code>name</code> \u00e9s <code>age</code>. A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a <code>Name</code>, illetve <code>Age</code> publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert <code>SetX(\u2026)</code> illetve <code>GetX()</code> t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott.</p> <ol> <li> <p>Az el\u0151z\u0151 feladatban bevezetett <code>Person</code> oszt\u00e1lyon bel\u00fcl hozzunk l\u00e9tre egy <code>int</code> t\u00edpus\u00fa <code>age</code> nev\u0171 tagv\u00e1ltoz\u00f3t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 <code>Age</code> tulajdons\u00e1got.</p> <pre><code>public class Person\n{\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set { age = value; }\n    }\n}\n</code></pre> <p>Visual Studio snippetek</p> <p>A laboron ugyan a gyakorl\u00e1s kedv\u00e9\u00e9rt k\u00e9zzel g\u00e9pelt\u00fck be a teljes tulajdons\u00e1got, de a Visual Studio-ban a gyakran el\u0151fordul\u00f3 k\u00f3dr\u00e9szletek l\u00e9trehoz\u00e1s\u00e1ra \u00fagynevezett code snippetek \u00e1llnak rendelkez\u00e9s\u00fcnkre, melyekkel a gyakori nyelvi konstrukci\u00f3kat tudjuk sablonszer\u0171en felhaszn\u00e1lni. A fenti property k\u00f3dr\u00e9szletet a <code>propfull</code> snippettel tudjuk el\u0151csalni. G\u00e9pelj\u00fck be a snippet nev\u00e9t (<code>propfull</code>), majd addig nyomjuk a Tab billenty\u0171t am\u00edg a snippet nem aktiv\u00e1l\u00f3dik (tipikusan 2x).</p> <p>Eml\u00edt\u00e9sre m\u00e9lt\u00f3 egy\u00e9b snippetek a teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl:</p> <ul> <li><code>ctor</code>: konstruktor</li> <li><code>for</code>: for ciklus</li> <li><code>foreach</code>: foreach ciklus</li> <li><code>prop</code>: auto property (l\u00e1sd k\u00e9s\u0151bb)</li> <li><code>switch</code>: switch utas\u00edt\u00e1s</li> <li><code>cw</code>: Console.WriteLine</li> </ul> <p>Ilyen snippeteket egy\u00e9bk\u00e9nt mi is k\u00e9sz\u00edthet\u00fcnk.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj tulajdons\u00e1gunkat.</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n    p.Age = 17;\n    p.Age++;\n    Console.WriteLine(p.Age);\n}\n</code></pre> </li> <li> <p>Futtassuk a programunkat (F5)</p> <p>L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>get</code> r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>set</code> r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis <code>value</code> v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel.</p> <p>Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a <code>p.setAge(p.getAge() + 1)</code> form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok/lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l.</p> </li> <li> <p>Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a <code>get</code> \u00e9s <code>set</code> r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva.</p> </li> <li> <p>Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st.</p> <p>L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik.</p> </li> <li> <p>A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az <code>Age</code> tulajdons\u00e1g setter-\u00e9t.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\n        age = value; \n    }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck.</p> </li> <li> <p>Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9ben.</p> <pre><code>p.Age = -2;\n</code></pre> </li> <li> <p>Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort.</p> <pre><code>p.Age = 2;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#autoimplementalt-tulajdonsag-auto-implemented-property","title":"Autoimplement\u00e1lt tulajdons\u00e1g (auto-implemented property)","text":"<p>A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben:</p> <ul> <li>nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat,</li> <li>nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re.</li> </ul> <p>Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t.</p> <ol> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Person</code> oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property). K\u00e9sz\u00edts\u00fcnk egy <code>string</code> t\u00edpus\u00fa <code>Name</code> nev\u0171 tulajdons\u00e1got.</p> <pre><code>public string Name { get; set; }\n</code></pre> <p>A szintaktikai k\u00fcl\u00f6nbs\u00e9g a kor\u00e1bbiakhoz k\u00e9pest: a get \u00e9s a set \u00e1gnak sem adtunk implement\u00e1ci\u00f3t (nincsenek kapcsos z\u00e1r\u00f3jelek). Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Hangs\u00falyozand\u00f3, hogy ez nem a kor\u00e1bban bevezetett <code>name</code> tagv\u00e1ltoz\u00f3t \u00e1ll\u00edtja \u00e9s k\u00e9rdezi le (az ki is t\u00f6r\u00f6lhetn\u00e9nk), hanem egy rejtett, \u00faj v\u00e1ltoz\u00f3n dolgozik!</p> </li> <li> <p>Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a <code>Main</code> f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel.</p> <pre><code>static void Main(string[] args)\n{\n    // ...\n    p.Name = \"Luke\";\n    // ...\n    Console.WriteLine(p.Name);\n}\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#alapertelmezett-ertek-default-value","title":"Alap\u00e9rtelmezett \u00e9rt\u00e9k (default value)","text":"<p>Az autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9ben megadhat\u00f3 a kezdeti \u00e9rt\u00e9k\u00fck is a deklar\u00e1ci\u00f3 sor\u00e1n.</p> <ol> <li> <p>Adjunk kiindul\u00f3 \u00e9rt\u00e9ket a <code>Name</code> tulajdons\u00e1gnak.</p> <pre><code>public string Name { get; set; } = \"anonymous\";\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsagok-lathatosaga","title":"Tulajdons\u00e1gok l\u00e1that\u00f3s\u00e1ga","text":"<p>A tulajdons\u00e1gok nagy el\u0151nye a teljesen szabad implement\u00e1ci\u00f3 mellett, hogy a getter \u00e9s a setter l\u00e1that\u00f3s\u00e1g\u00e1t k\u00fcl\u00f6n k\u00fcl\u00f6n is lehet \u00e1ll\u00edtani.</p> <ol> <li> <p>\u00c1ll\u00edtsuk a <code>Name</code> tulajdons\u00e1g setter\u00e9nek a l\u00e1that\u00f3s\u00e1g\u00e1t priv\u00e1tra.</p> <pre><code>public string Name { get; private set; }\n</code></pre> <p>Ilyenkor a <code>Program</code> oszt\u00e1lyban ford\u00edt\u00e1si hib\u00e1t kapunk a <code>p.Name = \"Luke\";</code> utas\u00edt\u00e1sra. Az alapvet\u0151 szab\u00e1ly az, hogy a getter \u00e9s a setter \u00f6r\u00f6kli a property l\u00e1that\u00f3s\u00e1g\u00e1t, mely tov\u00e1bb sz\u0171k\u00edthet\u0151, de nem laz\u00edthat\u00f3. A l\u00e1that\u00f3s\u00e1g szab\u00e1lyoz\u00e1sa autoimplement\u00e1lt \u00e9s nem autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9n is haszn\u00e1lhat\u00f3.</p> </li> <li> <p>\u00c1ll\u00edtsuk vissza a l\u00e1that\u00f3s\u00e1got (t\u00e1vol\u00edtsuk el a <code>private</code> kulcssz\u00f3t a <code>Name</code> tulajdons\u00e1g settere el\u0151l), hogy megsz\u0171nj\u00f6n a ford\u00edt\u00e1si hiba.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#csak-olvashato-tulajdonsag-readonly-property","title":"Csak olvashat\u00f3 tulajdons\u00e1g (readonly property)","text":"<p>A setter elhagyhat\u00f3, \u00edgy egy olyan tulajdons\u00e1got kapunk, mely csak olvashat\u00f3. Autoimplement\u00e1lt tulajdons\u00e1g eset\u00e9n ennek is adhat\u00f3 kezd\u0151\u00e9rt\u00e9k: erre csak konstruktorban, vagy alap\u00e9rtelmezett \u00e9rt\u00e9kkel val\u00f3 ell\u00e1t\u00e1ssal (l\u00e1sd fent) van lehet\u0151s\u00e9g, ellent\u00e9tben a priv\u00e1t setterrel rendelkez\u0151 tulajdons\u00e1gokkal, melyek settere b\u00e1rmely, az oszt\u00e1lyban tal\u00e1lhat\u00f3 tagf\u00fcggv\u00e9nyb\u0151l h\u00edvhat\u00f3.</p> <p>Csak olvashat\u00f3 tulajdons\u00e1g defini\u00e1l\u00e1s\u00e1t a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletek illusztr\u00e1lj\u00e1k (a k\u00f3dunkba NE vezess\u00fck be):</p> <p>a) Autoimplement\u00e1lt eset</p> <pre><code>public string Name { get; }\n</code></pre> <p>b) Nem autoimplement\u00e1lt eset</p> <pre><code>private string name;\n...\npublic string Name { get {return name; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#szamitott-ertek-calculated-value","title":"Sz\u00e1m\u00edtott \u00e9rt\u00e9k (calculated value)","text":"<p>A csak getterrel rendelkez\u0151 tulajdons\u00e1goknak van m\u00e9g egy haszn\u00e1lati m\u00f3dja. Valamilyen sz\u00e1m\u00edtott \u00e9rt\u00e9k meghat\u00e1roz\u00e1s\u00e1ra is haszn\u00e1lhat\u00f3, mely mindig kisz\u00e1mol egy megadott logika alapj\u00e1n egy \u00e9rt\u00e9ket, de a \"csak olvashat\u00f3 tulajdons\u00e1g\"-gal szemben nincs m\u00f6g\u00f6tte k\u00f6zvetlen\u00fcl a tulajdons\u00e1ghoz tartoz\u00f3 adattag. Ezt a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet illusztr\u00e1lja (a k\u00f3dunkba NE vezess\u00fck be):</p> <pre><code>public int AgeInDogYear { get { return Age * 7; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#2-feladat-delegat-delegate-metodusreferencia","title":"2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia)","text":"<p>Forduljon a k\u00f3d!</p> <p>A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t.</p> <p>A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t seg\u00edts\u00e9g\u00e9vel egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t defini\u00e1lhatunk, amellyel met\u00f3dusokra tudunk mutatni/hivatkozni. Nem ak\u00e1rmilyenre, hanem - a C++ f\u00fcggv\u00e9nypointerekkel anal\u00f3g m\u00f3don - olyanokra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t v\u00e1ltoz\u00f3 \"megh\u00edv\u00e1s\u00e1val\" az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni.</p> <p>N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra:</p> <ul> <li>egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek  param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa,</li> <li>egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba,</li> <li>a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l.</li> </ul> <p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott <code>Person</code> oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust (<code>AgeChangingDelegate</code>), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott <code>Person</code> p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r.</p> <ol> <li> <p>Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust, mely <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab <code>int</code> param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a <code>Person</code> oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk!</p> <pre><code>namespace PropertyDemo\n{\n    public delegate void AgeChangingDelegate(int oldAge, int newAge);\n\n    public class Person\n    {\n        // ...\n</code></pre> <p>Az <code>AgeChangingDelegate</code> egy t\u00edpus (figyelj\u00fck a VS sz\u00ednez\u00e9s\u00e9t is), mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.).</p> </li> <li> <p>Tegy\u00fck lehet\u0151v\u00e9, hogy a <code>Person</code> objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban!</p> <pre><code>public class Person\n{\n    public AgeChangingDelegate AgeChanging;\n</code></pre> <p>Ez \u00edgy most mennyire objektumorient\u00e1lt?</p> <p>A publikus tagv\u00e1ltoz\u00f3k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az objektumorint\u00e1lt egys\u00e9gbez\u00e1r\u00e1si/inform\u00e1ci\u00f3rejt\u00e9si elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g.</p> </li> <li> <p>H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az <code>Age</code> tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\n        if (AgeChanging != null)\n            AgeChanging(age, value);\n        age = value; \n    }\n}\n</code></pre> <p>A  fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l:</p> <ul> <li>A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t.</li> <li>Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \"changing\" sz\u00f3 egy folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st, a bek\u00f6vetkez\u00e9st m\u00falt id\u0151 jelezni: \"changed\")</li> <li>Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3hoz m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a tagv\u00e1ltoz\u00f3 \u00e9rt\u00e9ke <code>null</code>-e.</li> <li>Az esem\u00e9ny els\u00fct\u00e9sekor a <code>null</code> vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb, \u00e9s sz\u00e1lbiztosabb form\u00e1ban is meg tudjuk tenni a \"<code>?.</code>\" null-conditional oper\u00e1torral (C# 6-t\u00f3l):</li> </ul> <pre><code>if (AgeChanging != null)\n    AgeChanging(age, value);\n</code></pre> <p>helyett</p> <pre><code>AgeChanging?.Invoke(age, value);\n</code></pre> <p>Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem <code>null</code>, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l.</p> </li> <li> <p>Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel:</p> <pre><code>if (age == value) \n    return;\n\u2026\n</code></pre> </li> <li> <p>K\u00e9sz vagyunk a <code>Person</code> oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a <code>Program</code> oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel.</p> <pre><code>class Program\n{\n    // ...\n\n    private static void PersonAgeChanging(int oldAge, int newAge)\n    {\n        Console.WriteLine(oldAge + \" =&gt; \" + newAge);\n    }\n}\n</code></pre> <p>Tipp</p> <p>Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! M\u00edg a delegate t\u00edpust az oszt\u00e1lyon k\u00edv\u00fclre (de namespace-en bel\u00fclre) helyezt\u00fck el, a f\u00fcggv\u00e9nyt az oszt\u00e1lyon bel\u00fclre helyezz\u00fck!</p> </li> <li> <p>V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a <code>Main</code> f\u00fcggv\u00e9nyben!</p> <pre><code>static void Main(string[] args)\n{\n  Person p = new Person();\n  p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\n  // ...\n</code></pre> </li> <li> <p>Futtassuk a programot!</p> <p>Pl. az <code>AgeChanging?.Invoke(age, value);</code> sorra t\u00f6r\u00e9spontot helyezve, az alkalmaz\u00e1st debuggolva futtatva, \u00e9s a k\u00f3dot l\u00e9ptetve figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1s sor\u00e1n egyar\u00e1nt lefut.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal (a <code>+=</code> oper\u00e1torral lehet \u00faj feliratkoz\u00f3t felvenni a megl\u00e9v\u0151k mell\u00e9), majd futtassuk a programot.</p> <pre><code>p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += PersonAgeChanging; // T\u00f6m\u00f6rebb szintaktika\n</code></pre> <p>L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9nyreferenci\u00e1t, hanem egy f\u00fcggv\u00e9nyreferencia-list\u00e1t tartalmaznak (\u00e9s tartanak karban).</p> <p>Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a <code>+=</code> oper\u00e1tor ut\u00e1n, a <code>new AgeChangingDelegate(...)</code> n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy <code>AgeChangingDelegate</code> objektum fogja becsomagolni a <code>PersonAgeChanging</code> f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. A  gyakorlatban ezt a t\u00f6m\u00f6rebb szintaktik\u00e1t szoktuk haszn\u00e1lni.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot.</p> <pre><code>p.AgeChanging -= PersonAgeChanging;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#3-feladat-esemeny-event","title":"3. Feladat \u2013 Esem\u00e9ny (event)","text":"<p>Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni.</p> <ol> <li> <p>Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veleteib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hiszen \u00edgy az esem\u00e9ny hamis m\u00f3don akkor is kiv\u00e1lthat\u00f3,  r\u00e1ad\u00e1sul val\u00f3tlan adatokkal, amikor az a gyakorlatban be sem k\u00f6vetkezett, becsapva az \u00f6sszes el\u0151fizet\u0151t. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re.</p> <pre><code>p.AgeChanging(67, 12);\n</code></pre> <p>Itt a <code>p</code> <code>Person</code> objektum vonatkoz\u00e1s\u00e1ban egy val\u00f3tlan \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki, becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a <code>Person</code> oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani.</p> </li> <li> <p>Egy m\u00e1sik probl\u00e9ma a k\u00f6vetkez\u0151. B\u00e1r a <code>+=</code> \u00e9s a <code>-=</code> tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az <code>=</code> oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be).</p> <pre><code>p.AgeChanging = null;\n</code></pre> </li> <li> <p>L\u00e1ssuk el az <code>event</code> kulcssz\u00f3val az <code>AgeChanging</code> tagv\u00e1ltoz\u00f3t <code>Person.cs</code>-ben!</p> Person.cs<pre><code>public event AgeChangingDelegate AgeChanging;\n</code></pre> <p>Az <code>event</code> kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t probl\u00e9m\u00e1t kiz\u00e1rva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli.</p> <p></p> </li> <li> <p>T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat!</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#4-feladat-attributumok","title":"4. Feladat \u2013 Attrib\u00fatumok","text":""},{"location":"labor/2-nyelvi-eszkozok/#sorositas-testreszabasa-attributummal","title":"Soros\u00edt\u00e1s testreszab\u00e1sa attrib\u00fatummal","text":"<p>Az attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat. Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz stb.). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k.</p> <p>property vs. attrib\u00fatum vs. static</p> <p>Felmer\u00fcl a k\u00e9rd\u00e9s, hogy milyen oszt\u00e1lyjellemz\u0151k ker\u00fcljenek tulajdons\u00e1gokba \u00e9s melyek attrib\u00fatumokba egy oszt\u00e1ly eset\u00e9ben. A tulajdons\u00e1gok mag\u00e1ra az objektum p\u00e9ld\u00e1nyra vonatkoznak, m\u00edg az attrib\u00fatum az azt le\u00edr\u00f3 oszt\u00e1lyra (vagy annak valamilyen tagj\u00e1ra).</p> <p>Ilyen szempontb\u00f3l az attrib\u00fatumok k\u00f6zelebb \u00e1llnak a statikus tulajdons\u00e1gokhoz, m\u00e9gis megfontoland\u00f3, hogy egy adott adatot statikus tagk\u00e9nt vagy attrib\u00fatumk\u00e9nt defini\u00e1ln\u00e1nk. Attrib\u00fatummal sokkal deklarat\u00edvabb a le\u00edr\u00e1s, \u00e9s nem szennyezz\u00fck olyan r\u00e9szletekkel a k\u00f3dot, melyeknek nem kellene az oszt\u00e1ly publikus interf\u00e9sz\u00e9n megjelennie.</p> <p>A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat.</p> <ol> <li> <p>Sz\u00farjuk be a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat!</p> <pre><code>var serializer = new XmlSerializer(typeof(Person));\nvar stream = new FileStream(\"person.txt\", FileMode.Create);\nserializer.Serialize(stream, p);\nstream.Close();\nProcess.Start(new ProcessStartInfo\n{\n    FileName = \"person.txt\",\n    UseShellExecute = true,\n});\n</code></pre> <p>A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 <code>Process.Start</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a <code>person.txt</code> f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a *\\bin\\Debug\\* alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. <li> <p>N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve.</p> </li> <li> <p>.NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a <code>Person</code> oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az <code>XmlRoot</code> attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a <code>Person</code> oszt\u00e1ly f\u00f6l\u00e9!</p> <pre><code>[XmlRoot(\"Szem\u00e9ly\")]\npublic class Person \n{\n    // ...\n}\n</code></pre> </li> <li> <p>Az <code>XmlAttribute</code> attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az <code>Age</code> tulajdons\u00e1got (\u00e9s ne a tagv\u00e1ltoz\u00f3t!)!</p> <pre><code>[XmlAttribute(\"Kor\")]\npublic int Age\n</code></pre> </li> <li> <p>Az <code>XmlIgnore</code> attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a <code>Name</code> tulajdons\u00e1g f\u00f6l\u00f6tt.</p> <pre><code>[XmlIgnore]\npublic string Name { get; set; }\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal.</p> </li>"},{"location":"labor/2-nyelvi-eszkozok/#5-feladat-delegat-2","title":"5. Feladat \u2013 Deleg\u00e1t 2.","text":"<p>A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk.</p> <p>A be\u00e9p\u00edtett generikus lista oszt\u00e1ly (<code>List&lt;T&gt;</code>) <code>FindAll</code> f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny, pontosabban delegate form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (ez a <code>FindAll</code> minden elemre megh\u00edvja), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny param\u00e9ter\u00e9nek a t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus (nem kell beg\u00e9pelni/l\u00e9trehozni, hiszen m\u00e1r l\u00e9tezik):</p> <pre><code>public delegate bool Predicate&lt;T&gt;(T obj)\n</code></pre> <p>Note</p> <p>A fenti teljes defin\u00edci\u00f3 megjelen\u00edt\u00e9s\u00e9hez csak g\u00e9pelj\u00fck be valahova, pl. a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a <code>Predicate</code> t\u00edpusnevet, kattintsunk rajta eg\u00e9rrel, \u00e9s az F12 billenty\u0171vel navig\u00e1ljunk el a defin\u00edci\u00f3j\u00e1hoz.</p> <p>Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai (bool) \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani.</p> <ol> <li> <p>Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza:</p> <pre><code>private static bool MyFilter(int n)\n{\n    return n % 2 == 1;\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val:</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nlist = list.FindAll(MyFilter);\n\nforeach (int n in list)\n{\n    Console.WriteLine($\"Value: {n}\");\n}\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg.</p> </li> <li>\u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a <code>MyFilter</code> f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben, \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik.</li> </ol> <p>Collection initializer szintaxis</p> <p>Minden <code>Add</code> met\u00f3dussal rendelkez\u0151, az <code>IEnumerable</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyra (tipikusan kollekci\u00f3k) a collection initializer szintaxis az al\u00e1bbi m\u00f3don:</p> <pre><code>var list = new List&lt;int&gt;() { 1, 2, 3 };\n</code></pre> <p>C# 12-t\u0151l kezdve m\u00e9g egyszer\u0171bb szintaxis (\u00fan. collection expression) is haszn\u00e1lhat\u00f3 egy gy\u0171jtem\u00e9ny inicializ\u00e1l\u00e1s\u00e1ra, ha v\u00e1ltoz\u00f3 t\u00edpus\u00e1ra a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni, hogy gy\u0171jetm\u00e9nyr\u0151l van sz\u00f3. Pl.:</p> <pre><code>List&lt;int&gt; list = [1, 2, 3];\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#6-feladat-lambda-kifejezesek","title":"6. Feladat \u2013 Lambda kifejez\u00e9sek","text":"<p>Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \"Lambda expression (lambda kifejez\u00e9s)\" fejezete. A kulcselem a <code>=&gt;</code> (lambda oper\u00e1tor), mely seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek, vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1s\u00e1ra van lehet\u0151s\u00e9g.</p> <p><code>Action \u00e9s Func</code></p> <p>A .NET be\u00e9p\u00edtett <code>Func</code> \u00e9s <code>Action</code> generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1ban nem t\u00e9r\u00fcnk ki. Ett\u0151l m\u00e9g beletartoznak az alapanyagba!</p> <p>Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a <code>FindAll</code> m\u0171veletnek.</p> <p>Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni:</p> <pre><code>list = list.FindAll((int n) =&gt; { return n % 2 == 1; });\n</code></pre> <p>Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a <code>FindAll</code> m\u0171veletnek:</p> <ul> <li>ez egy lambda kifejez\u00e9s,</li> <li>a <code>=&gt;</code> bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt),</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n adtuk meg a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi <code>MyFilter</code> t\u00f6rzse).</li> </ul> <p>A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk:</p> <pre><code>list = list.FindAll(n =&gt; n % 2 == 1);\n</code></pre> <p>A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck:</p> <ul> <li>a param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki: a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a <code>FindAll</code> delegate param\u00e9teram\u00e9ter\u00e9nek t\u00edpus\u00e1b\u00f3l, mely a kor\u00e1bban vizsg\u00e1lt <code>Predicate</code>.</li> <li>a param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk (mert csak egy param\u00e9ter van)</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code>-t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r).</li> </ul>"},{"location":"labor/2-nyelvi-eszkozok/#7-tovabbi-nyelvi-konstrukciok","title":"7. Tov\u00e1bbi nyelvi konstrukci\u00f3k","text":"<p>Az al\u00e1bbiakban kitekint\u00fcnk n\u00e9h\u00e1ny olyan C# nyelvi elemre, melyek a napi programoz\u00e1si feladatok sor\u00e1n egyre gyakrabban haszn\u00e1latosak. A gyakorlat sor\u00e1n j\u00f3 es\u00e9llyel m\u00e1r nem marad id\u0151 ezek \u00e1ttekint\u00e9s\u00e9re.</p>"},{"location":"labor/2-nyelvi-eszkozok/#kifejezestorzsu-tagok-expression-bodied-members","title":"Kifejez\u00e9st\u00f6rzs\u0171 tagok (Expression-bodied members)","text":"<p>Id\u0151nk\u00e9nt olyan r\u00f6vid f\u00fcggv\u00e9nyeket, illetve tulajdons\u00e1gok eset\u00e9n kifejezetten gyakran olyan r\u00f6vid get/set/init defin\u00edci\u00f3kat \u00edrunk, melyek egyetlen kifejez\u00e9sb\u0151l \u00e1llnak. Ez esetben a f\u00fcggv\u00e9ny, illetve tulajdons\u00e1g eset\u00e9n a get/set/init t\u00f6rzse megadhat\u00f3 \u00fan. kifejez\u00e9st\u00f6rzs\u0171 tagok (expression-bodied members) szintaktik\u00e1val is, a <code>=&gt;</code> alkalmaz\u00e1s\u00e1val. Ez akkor is megtehet\u0151, ha az adott kontextusban van visszat\u00e9r\u00e9si \u00e9rt\u00e9k (return utas\u00edt\u00e1s), ak\u00e1r nincs.</p> <p>A p\u00e9ld\u00e1kban l\u00e1tni fogjuk, hogy a kifejez\u00e9stest\u0171 tagok alkalmaz\u00e1sa nem t\u00f6bb, mint egy kisebb szintaktikai \"csavar\" annak \u00e9rdek\u00e9ben, hogy ilyen egyszer\u0171 esetekben min\u00e9l kevesebb k\u00f6r\u00edt\u0151 k\u00f3dot kelljen \u00edrni.</p> <p>N\u00e9zz\u00fcnk el\u0151sz\u00f6r egy f\u00fcggv\u00e9ny p\u00e9ld\u00e1t (feltessz\u00fck, hogy az oszt\u00e1lyban van egy <code>Age</code> tagv\u00e1ltoz\u00f3 vagy tulajdons\u00e1g):</p> <p><pre><code>public int GetAgeInDogYear() =&gt; Age * 7; \npublic void DisplayName() =&gt; Console.WriteLine(ToString());\n</code></pre> Mint l\u00e1that\u00f3, elhagytuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code> utas\u00edt\u00e1st, \u00edgy t\u00f6m\u00f6rebb a szintaktika.</p> <p>Fontos</p> <p>B\u00e1r itt is a <code>=&gt;</code> tokent haszn\u00e1ljuk, ennek semmi k\u00f6ze nincs a kor\u00e1bban t\u00e1rgyalt lambda kifejez\u00e9sekhez: egyszer\u0171en csak arr\u00f3l van sz\u00f3, hogy ugyanazt a <code>=&gt;</code> tokent (szimb\u00f3lump\u00e1rt) k\u00e9t teljesen elt\u00e9r\u0151 dologra haszn\u00e1lja a C# nyelv.</p> <p>P\u00e9lda tulajdons\u00e1g getter megad\u00e1s\u00e1ra:</p> <pre><code>public int AgeInDogYear { get =&gt; Age * 7; }\n</code></pre> <p>S\u0151t, ha csak getterje van a tulajdons\u00e1gnak, a <code>get</code> kulcssz\u00f3t \u00e9s a kapcsos z\u00e1r\u00f3jeleket is lehagyhatjuk.</p> <pre><code>public int AgeInDogYear =&gt; Age * 7;\n</code></pre> <p>Ezt az k\u00fcl\u00f6nb\u00f6zteti meg a kor\u00e1bban l\u00e1tott f\u00fcggv\u00e9nyek hasonl\u00f3 szintaktik\u00e1j\u00e1t\u00f3l, hogy itt nem \u00edrtuk ki a kerek z\u00e1r\u00f3jeleket.</p> <p>Note</p> <p>A Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1nak magyar ford\u00edt\u00e1s\u00e1ban az \"expression-bodied members\" nem \"kifejez\u00e9st\u00f6rzs\u0171\", hanem \"kifejez\u00e9stest\u0171\" tagk\u00e9nt szerepel. K\u00f6sz\u00f6nj\u00fck sz\u00e9pen, de a f\u00fcggv\u00e9nyeknek sokkal ink\u00e1bb t\u00f6rzse, mint teste van a magyar terminol\u00f3gi\u00e1ban, \u00edgy ezt nem vessz\u00fck \u00e1t...</p>"},{"location":"labor/2-nyelvi-eszkozok/#objektuminicializalo-object-initializer","title":"Objektuminicializ\u00e1l\u00f3 (Object initializer)","text":"<p>A publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k inicializ\u00e1l\u00e1sa \u00e9s a konstruktorh\u00edv\u00e1s kombin\u00e1lhat\u00f3 egy \u00fagynevezett objektuminicializ\u00e1l\u00f3 (object initializer) szintaxis seg\u00edts\u00e9g\u00e9vel. Ennek alkalmaz\u00e1sa sor\u00e1n a konstruktorh\u00edv\u00e1s ut\u00e1n kapcsos z\u00e1r\u00f3jelekkel blokkot nyitunk, ahol a publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k \u00e9rt\u00e9ke adhat\u00f3 meg, az al\u00e1bbi szintaktik\u00e1val.</p> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Luke\",\n};\n</code></pre> <p>Az tulajdons\u00e1gok/tagok inicializ\u00e1l\u00e1sa a konstruktor lefut\u00e1sa ut\u00e1n t\u00f6rt\u00e9nik (amennyiben tartozik az oszt\u00e1lyhoz konstruktor). Ez a szintaktika az\u00e9rt is el\u0151ny\u00f6s, mert egy kifejez\u00e9snek sz\u00e1m\u00edt (azon h\u00e1rommal szemben, mintha l\u00e9trehozn\u00e1nk egy inicializ\u00e1latlan, <code>Person</code> objektumot, \u00e9s k\u00e9t tov\u00e1bbi l\u00e9p\u00e9sben adn\u00e1nk \u00e9rt\u00e9ket az <code>Age</code> \u00e9s <code>Name</code> tagoknak). \u00cdgy ak\u00e1r k\u00f6zvetlen\u00fcl f\u00fcggv\u00e9nyh\u00edv\u00e1s param\u00e9terek\u00e9nt \u00e1tadhat\u00f3 egy inicializ\u00e1lt objektum, an\u00e9lk\u00fcl, hogy k\u00fcl\u00f6n v\u00e1ltoz\u00f3t kellene deklar\u00e1lni.</p> <pre><code>void Foo(Person p)\n{\n    // do something with p\n}\n</code></pre> <pre><code>Foo(new Person() { Age = 17, Name = \"Luke\" });\n</code></pre> <p>A szintaxis r\u00e1ad\u00e1sul copy-paste bar\u00e1t, mert ahogy a fenti p\u00e9ld\u00e1kban is l\u00e1tszik, hogy nem sz\u00e1m\u00edt, hogy az utols\u00f3 tulajdons\u00e1g megad\u00e1sa ut\u00e1n van-e vessz\u0151, vagy nincs.</p>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsagok-init-only-setter","title":"Tulajdons\u00e1gok - Init only setter","text":"<p>Az el\u0151z\u0151 pontban l\u00e9v\u0151 objektuminicializ\u00e1l\u00f3 szintaxis nagyon k\u00e9nyelmes, viszont azt k\u00f6veteli meg a tulajdons\u00e1gt\u00f3l, hogy publikus legyen. Ha azt akarjuk, hogy egy tulajdons\u00e1g \u00e9rt\u00e9ke csak az objektum l\u00e9trehoz\u00e1sakor legyen megadhat\u00f3, ahhoz konstruktor param\u00e9tert kell bevezess\u00fcnk, \u00e9s egy csak olvashat\u00f3 (csak getterrel rendelkez\u0151) tulajdons\u00e1gnak kell azt \u00e9rt\u00e9k\u00fcl adjuk. Erre a probl\u00e9m\u00e1ra ad egyszer\u0171bb megold\u00e1st az \u00fan. Init only setter szintaxis, ahol olyan \"settert\" tudunk k\u00e9sz\u00edteni az <code>init</code> kulcssz\u00f3val, mely \u00e1ll\u00edt\u00e1sa  csak a konstruktorban \u00e9s az el\u0151z\u0151 fejezetben ismertetett objektuminicializ\u00e1l\u00f3 szintaxis alkalmaz\u00e1sa sor\u00e1n enged\u00e9lyezett, ezt k\u00f6vet\u0151en m\u00e1r nem.</p> <pre><code>public string Name { get; init; }\n</code></pre> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Luke\",\n};\n\np.Name = \"Test\"; // build hiba, ut\u00f3lag nem megv\u00e1ltoztathat\u00f3\n</code></pre> <p>Tov\u00e1bb\u00e1 lehet\u0151s\u00e9g\u00fcnk van az init only setter k\u00f6telez\u0151s\u00e9g\u00e9t is be\u00e1ll\u00edtani a tulajdons\u00e1gon alkalmazott <code>required</code> kulcssz\u00f3val. Ekkor a tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t mindenk\u00e9ppen meg kell adni az objektuminicializ\u00e1l\u00f3 szintaxisban, k\u00fcl\u00f6nben ford\u00edt\u00e1si hib\u00e1t kapunk.</p> <pre><code>public required string Name { get; init; }\n</code></pre> <p>Ez az\u00e9rt is hasznos, mert ha egy\u00e9bk\u00e9nt is szeretn\u00e9nk tulajdons\u00e1gokat publik\u00e1lni az oszt\u00e1lyb\u00f3l, \u00e9s egy\u00e9bk\u00e9nt is szeretn\u00e9nk t\u00e1mogatni az objektum inicializ\u00e1l\u00f3 szintaxist, akkor \u00edgy meg tudjuk sp\u00f3rolni a k\u00f6telez\u0151 konstruktor param\u00e9tereket.</p>"},{"location":"labor/2-nyelvi-eszkozok/#8-feladat-generikus-osztalyok","title":"8. Feladat \u2013 Generikus oszt\u00e1lyok","text":"<p>Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni.</p> <p>A .NET generikus oszt\u00e1lyai hasonl\u00edtanak C++ nyelv template oszt\u00e1lyaihoz, de k\u00f6zelebb \u00e1llnak a Java-ban m\u00e1r megismert generikus oszt\u00e1lyokhoz. A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor <code>object</code> t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az <code>object</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az <code>ArrayList</code>-tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, <code>object</code> t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az <code>ArrayList</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>var list = new ArrayList();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    // Castolni kell, k\u00fcl\u00f6nben nem fordul\n    int i = (int)list[n];\n    Console.WriteLine($\"Value: {i}\");\n}\n</code></pre> <p>A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak:</p> <ul> <li>Az <code>ArrayList</code> minden egyes elemet <code>object</code>-k\u00e9nt t\u00e1rol.</li> <li>Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni.</li> <li>Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az <code>int</code> t\u00edpus\u00fa adatok mell\u00e9  besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem <code>int</code> t\u00edpust <code>int</code> t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek.</li> <li>\u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az <code>object</code>-k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen.</li> </ul> <p>A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban):</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    int i = list[n]; // Nem kell cast-olni\n    Console.WriteLine($\"Value: {i}\");\n}\n</code></pre>"},{"location":"labor/3-felhasznaloi-felulet/","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa","text":""},{"location":"labor/3-felhasznaloi-felulet/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja megismerkedni a vastagkliens alkalmaz\u00e1sok fejleszt\u00e9s\u00e9nek alapjaival a deklarat\u00edv XAML fel\u00fcletle\u00edr\u00f3 technol\u00f3gi\u00e1n kereszt\u00fcl. Az itt tanult alapok az \u00f6sszes XAML dialektusra (WinUI, WPF, UWP, Xamarin.Forms, MAUI) igazak lesznek, vagy nagyon hasonl\u00f3an lehet \u0151ket alkalmazni, mi viszont a mai \u00f3r\u00e1n specifikusan a WinAppSDK / WinUI 3 keretrendszeren kereszt\u00fcl fogjuk haszn\u00e1lni a XAML-t.</p>"},{"location":"labor/3-felhasznaloi-felulet/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> <li>Visual Studio 2022</li> <li> <p>Windows Desktop Development Workload</p> <p></p> </li> </ul>"},{"location":"labor/3-felhasznaloi-felulet/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el a <code>megoldas</code> \u00e1gon. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre a <code>megoldas</code> \u00e1gat:</p> <p><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/3-felhasznaloi-felulet/#kiindulo-projekt","title":"Kiindul\u00f3 projekt","text":"<p>Az els\u0151 feladatban kialak\u00edtjuk a k\u00f6rnyezetet, amelyben a tov\u00e1bbiakban a XAML nyelv \u00e9s a WinUI keretrendszer m\u0171k\u00f6d\u00e9s\u00e9t vizsg\u00e1ljuk. A kiindul\u00f3 projektet a Visual Studi\u00f3val is legener\u00e1lhatn\u00e1nk (WinUI 3 projekt, Blank App, Packaged (WinUI 3 in Desktop) t\u00edpus), de az \u00f3ra g\u00f6rd\u00fcl\u00e9kenys\u00e9ge \u00e9rdek\u00e9ben az el\u0151re elk\u00e9sz\u00edtett projektet fogjuk haszn\u00e1lni.</p> <p>A projektet a k\u00f6vetkez\u0151 parancs kiad\u00e1s\u00e1val tudjuk lekl\u00f3nozni a g\u00e9p\u00fcnkre:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo.git\n</code></pre> <p>Nyissuk meg a <code>HelloXaml.sln</code>-t.</p> <p>Tekints\u00fck \u00e1t milyen f\u00e1jlokat tartalmaz a projekt:</p> <ul> <li>App<ul> <li>K\u00e9t f\u00e1jl <code>App.xaml</code> \u00e9s <code>App.xaml.cs</code>(k\u00e9s\u0151bb tiszt\u00e1zzuk k\u00e9t f\u00e1jl tartozik hozz\u00e1)</li> <li>Alkalmaz\u00e1s bel\u00e9p\u00e9si pontja: <code>OnLaunched</code> fel\u00fcldefini\u00e1lt met\u00f3dus az <code>App.xaml.cs</code>-ben</li> <li>Eset\u00fcnkben itt inicializ\u00e1ljuk az alkalmaz\u00e1s egyetlen ablak\u00e1t a <code>MainWindow</code>-t</li> </ul> </li> <li>MainWindow<ul> <li>Alkalmaz\u00e1sunk f\u0151ablak\u00e1hoz tartoz\u00f3 .xaml \u00e9s .xaml.cs f\u00e1jlok.</li> </ul> </li> </ul> Tov\u00e1bbi solution elemek <p>A kiindul\u00f3 VS solution a k\u00f6vetkez\u0151 elemeket tartalmazza m\u00e9g:</p> <ul> <li>Dependencies<ul> <li>Frameworks<ul> <li><code>Microsoft.AspNetCore.App</code>: .NET SDK metapackage (Microsoft .NET \u00e9s SDK alapcsomagokat hivatkozza be)</li> <li>Windows specifikus .NET SDK</li> </ul> </li> <li>Packages<ul> <li>Windows SDK Build Tools</li> <li>WindowsAppSDK</li> </ul> </li> </ul> </li> <li>Assets<ul> <li>Alkalmaz\u00e1s log\u00f3i</li> </ul> </li> <li>app.manifest, Package.appxmanifest<ul> <li>Az alkalmaz\u00e1s metaadatait tartalmaz\u00f3 XML \u00e1llom\u00e1ny, melyben t\u00f6bbek k\u00f6z\u00f6tt megadhatjuk a log\u00f3kat, vagy pl. Androidhoz hasonl\u00f3an itt kell jogot k\u00e9rj\u00fcnk a biztons\u00e1gkritikus rendszerer\u0151forr\u00e1sokhoz.</li> </ul> </li> </ul> <p>Futtassuk az alkalmaz\u00e1st!</p>"},{"location":"labor/3-felhasznaloi-felulet/#xaml-bevezetes","title":"XAML bevezet\u00e9s","text":"<p>A fel\u00fclet le\u00edr\u00e1s\u00e1t egy XML alap\u00fa le\u00edr\u00f3 nyelvben, XAML-ben (ejtsd: zem\u00f6l) fogjuk megadni.</p> <p>Grafikus designer fel\u00fclet</p> <p>Bizonyos XAML dialektusok eset\u00e9ben (pl.: WPF) rendelkez\u00e9s\u00fcnkre \u00e1ll grafikus designer eszk\u00f6z is a fel\u00fclet kialak\u00edt\u00e1s\u00e1hoz, de az \u00e1ltal\u00e1ban kev\u00e9sb\u00e9 hat\u00e9kony XAML le\u00edr\u00e1st szokott gener\u00e1lni. R\u00e1ad\u00e1sul m\u00e1r a Visual Studio is t\u00e1mogatja a Hot Reload m\u0171k\u00f6d\u00e9st XAML esetben, \u00edgy nem sz\u00fcks\u00e9ges le\u00e1ll\u00edtani az alkalmaz\u00e1st a XAML szerkeszt\u00e9se k\u00f6zben, a v\u00e1ltoztat\u00e1sokat pedig azonnal l\u00e1thatjuk a fut\u00f3 alkalmaz\u00e1sban. Ez\u00e9rt WinUI eset\u00e9ben m\u00e1r nem is kapunk designer t\u00e1mogat\u00e1st a Visual Studioban. A tapasztalatok alapj\u00e1n vannak limit\u00e1ci\u00f3i, \"nagyobb\" l\u00e9pt\u00e9k\u0171 v\u00e1ltoztat\u00e1sok eset\u00e9n sz\u00fcks\u00e9g van az alkalmaz\u00e1s \u00fajraind\u00edt\u00e1s\u00e1ra.</p>"},{"location":"labor/3-felhasznaloi-felulet/#xaml-nyelvi-alapok","title":"XAML nyelvi alapok","text":"<p>A XAML nyelv:</p> <ul> <li>Objektump\u00e9ld\u00e1nyos\u00edt\u00f3 nyelv</li> <li>Szabv\u00e1nyos XML</li> <li>XML elemek/tagek: objektumokat p\u00e9ld\u00e1nyos\u00edtanak, melyek oszt\u00e1lyai szabv\u00e1nyos .NET oszt\u00e1lyok</li> <li>XML attrib\u00fatumok: tulajdons\u00e1gokat (dependency property-ket) \u00e1ll\u00edtanak be</li> <li>Deklarat\u00edv</li> </ul> <p>N\u00e9zz\u00fck meg, milyen XAML-t gener\u00e1lt a projekt sablon (<code>MainWindow.xaml</code>). L\u00e1thatjuk, hogy a XAML-ben minden vez\u00e9rl\u0151h\u00f6z l\u00e9trehozott egy XML elemet/taget. A vez\u00e9rl\u0151k tagjein pedig be vannak \u00e1ll\u00edtva a vez\u00e9rl\u0151 tulajdons\u00e1gai. Pl. <code>HorizontalAlignment</code>: igaz\u00edt\u00e1s a kont\u00e9neren (eset\u00fcnkben ablakon) bel\u00fcl. Vez\u00e9rl\u0151k tartalmazhatnak m\u00e1s vez\u00e9rl\u0151ket, \u00edgy vez\u00e9rl\u0151kb\u0151l \u00e1ll\u00f3 fa j\u00f6n l\u00e9tre.</p> <p>N\u00e9zz\u00fck meg r\u00e9szletesebben a <code>MainWindow.xaml</code>-t:</p> <ul> <li>Gy\u00f6k\u00e9r tagen n\u00e9vterek: meghat\u00e1rozz\u00e1k, hogy az XML-ben milyen tageket \u00e9s attrib\u00fatumokat haszn\u00e1lhatunk<ul> <li>Alap\u00e9rtelmezett n\u00e9vt\u00e9r: XAML elemek/vez\u00e9rl\u0151k (pl. <code>Button</code>, <code>TextBox</code> stb.) n\u00e9vtere</li> <li><code>x</code> n\u00e9vt\u00e9r: XAML parser n\u00e9vtere (pl.: <code>x:Class</code>, <code>x:Name</code>)</li> <li>Egy\u00e9b tetsz\u0151leges n\u00e9vterek hivatkozhat\u00f3k</li> </ul> </li> <li><code>Window</code> gy\u00f6k\u00e9r tag<ul> <li>Az ablakunk/oldalunk alapj\u00e1n egy .NET oszt\u00e1ly j\u00f6n l\u00e9tre, mely a <code>Window</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik.</li> <li>A lesz\u00e1rmaztatott oszt\u00e1lyunk nev\u00e9t az <code>x:Class</code> attrib\u00fatum hat\u00e1rozza meg: az <code>x:Class=\"HelloXaml.MainWindow\"</code> alapj\u00e1n egy <code>HelloXaml</code> n\u00e9vt\u00e9rben egy <code>MainWindow</code> nev\u0171 oszt\u00e1ly lesz.</li> <li>Ez egy partial class, az oszt\u00e1ly \"m\u00e1sik fele\" az ablakhoz/oldalhoz tartoz\u00f3 \u00fan. a code-behind f\u00e1jlban (<code>MainWindow.xaml.cs</code>) tal\u00e1lhat\u00f3. L\u00e1sd k\u00f6vetkez\u0151 pont.</li> </ul> </li> <li>Code-behind f\u00e1jl (<code>MainWindow.xaml.cs</code>):<ul> <li>A partial classunk m\u00e1sik \"fele\": ellen\u0151rizz\u00fck, hogy itt az oszt\u00e1ly neve \u00e9s n\u00e9vtere megegyezik a .xaml f\u00e1jlban megadottal (partial class!).</li> <li>Esem\u00e9nykezel\u0151 \u00e9s seg\u00e9df\u00fcggv\u00e9nyeket tessz\u00fck ide (t\u00f6bbek k\u00f6z\u00f6tt).</li> <li><code>this.InitializeComponent();</code>: a konstruktorban mindig meg kell h\u00edvni, ez olvassa majd be fut\u00e1s k\u00f6zben a XAML-t, ez p\u00e9ld\u00e1nyos\u00edtja, inicializ\u00e1lja az ablak/oldal tartalm\u00e1t (vagyis a XAML-f\u00e1jlban megadott vez\u00e9rl\u0151ket az ott meghat\u00e1rozott tulajdons\u00e1gokkal).</li> </ul> </li> </ul> <p>T\u00f6r\u00f6lj\u00fck ki a <code>Window</code> tartalm\u00e1t \u00e9s a code-behind f\u00e1jlb\u00f3l az esem\u00e9nykezel\u0151t (<code>myButton_Click</code> f\u00fcggv\u00e9ny). Most k\u00e9zzel fogunk XAML-t \u00edrni \u00e9s ezzel a fel\u00fcletet kialak\u00edtani. Vegy\u00fcnk fel egy <code>Grid</code>-et a <code>Window</code>-ba, mellyel a k\u00e9s\u0151bbiekben egy t\u00e1bl\u00e1zatos elrendez\u00e9st (layout) fogunk tudunk kialak\u00edtani:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;Window\n    x:Class=\"HelloXaml.MainWindow\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloXaml\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"&gt;\n\n    &lt;Grid&gt;\n\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> <p>Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171vel). A <code>Grid</code> most kit\u00f6lti a teljes ablakot, a sz\u00edne megegyezik az ablak h\u00e1tt\u00e9rsz\u00edn\u00e9vel, ez\u00e9rt szemmel nem tudjuk megk\u00fcl\u00f6nb\u00f6ztetni.</p> <p>A k\u00f6vetkez\u0151 feladatok sor\u00e1n hagyjuk futni az alkalmaz\u00e1st, hogy azonnal l\u00e1thassuk a fel\u00fcleten eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat.</p> <p>Hot Reload limit\u00e1ci\u00f3k</p> <p>Tartsuk szem el\u0151tt a Hot Reload limit\u00e1ci\u00f3it: ha egy v\u00e1ltoz\u00e1sunk nem akar a fut\u00f3 alkalmaz\u00e1s fel\u00fclet\u00e9n megjelenni, akkor ind\u00edtsuk majd \u00fajra az alkalmaz\u00e1st!</p>"},{"location":"labor/3-felhasznaloi-felulet/#objektum-peldanyok-es-tulajdonsagaik","title":"Objektum p\u00e9ld\u00e1nyok \u00e9s tulajdons\u00e1gaik","text":"<p>Most azt n\u00e9zz\u00fck meg, hogyan tudunk XAML alapokon objektumokat p\u00e9ld\u00e1nyos\u00edtani \u00e9s ezen objektumok tulajdons\u00e1gait be\u00e1ll\u00edtani.</p> <p>Vegy\u00fcnk fel a <code>Grid</code> belsej\u00e9be egy <code>Button</code>-t. A <code>Content</code> tulajdons\u00e1ggal adhatjuk meg a gomb sz\u00f6veg\u00e9t, pontosabban a tartalm\u00e1t.</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Ez azon a helyen, ahol deklar\u00e1ltuk, fut\u00e1s k\u00f6zben l\u00e9trehoz egy <code>Button</code> objektumot, \u00e9s a <code>Content</code> tulajdons\u00e1g\u00e1t a \"Hello WinUI App!\" sz\u00f6vegre \u00e1ll\u00edtja. Ezt megtehett\u00fck volna a code-behind f\u00e1jlban C# nyelven is k\u00f6vetkez\u0151k\u00e9ppen (de ez kev\u00e9sb\u00e9 olvashat\u00f3 k\u00f3dot eredm\u00e9nyezne):</p> <pre><code>// Pl. a konstruktor v\u00e9g\u00e9re be\u00edrva:\n\nButton b = new Button();\nb.Content = \"Hello WinUI App!\";\nrootGrid.Children.Add(b); \n// Az el\u0151z\u0151 a sorhoz XAML f\u00e1jlban a Gridnek meg kellene adni az x:Name=\"rootGrid\" \n// attrib\u00fatumot, hogy rootGrid n\u00e9ven el\u00e9rhet\u0151 legyen a code-behind f\u00e1jlban\n</code></pre> <p> Ez a p\u00e9lda nagyon j\u00f3l szeml\u00e9lteti, hogy a XAML alapvet\u0151en egy objektump\u00e9ld\u00e1nyos\u00edt\u00f3 nyelv, \u00e9s t\u00e1mogatja objektumok tulajdons\u00e1gainak be\u00e1ll\u00edt\u00e1s\u00e1t.</p> <p>A <code>Content</code> tulajdons\u00e1g k\u00fcl\u00f6nleges, nem csak XML attrib\u00fatumban lehet megadni, hanem tagen (XML elemen) bel\u00fcl is.</p> <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre> <p>S\u0151t! A gombra nem csak feliratot rakhatunk, hanem tetsz\u0151leges m\u00e1s elemet. Pl. rakjunk bele egy piros k\u00f6rt. A k\u00f6r 10 pixel sz\u00e9les, 10 pixel magas, a sz\u00edn (<code>Fill</code>) pedig piros.</p> <pre><code>&lt;Button&gt;\n    &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n&lt;/Button&gt;\n</code></pre> <p>Ezt kor\u00e1bbi .NET UI technol\u00f3gi\u00e1k eset\u00e9ben (pl. Windows Forms) nem lett volna ilyen egyszer\u0171 megval\u00f3s\u00edtani.</p> <p>Legyen most a piros k\u00f6r mellett a Record felirat (hogy \u00e9rtelme is legyen a piros k\u00f6r\u00f6s gombnak). A gombnak csak egy gyereke lehet, ez\u00e9rt egy layout vez\u00e9rl\u0151be (pl. egy <code>StackPanel</code>-be) kell beraknunk a k\u00f6rt \u00e9s a sz\u00f6veget (<code>TextBlock</code>). Adjunk egy bal oldali marg\u00f3t is a <code>TextBlock</code>-nak, hogy ne \u00e9rjenek \u00f6ssze.</p> <pre><code>&lt;Button&gt;\n    &lt;StackPanel Orientation=\"Horizontal\"&gt;\n        &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n        &lt;TextBlock Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n    &lt;/StackPanel&gt;\n&lt;/Button&gt;\n</code></pre> <p>A <code>StackPanel</code> egy egyszer\u0171, vez\u00e9rl\u0151k elrendez\u00e9s\u00e9re szolg\u00e1l\u00f3 layout panel:  a tartalmazott vez\u00e9rl\u0151ket <code>Horizental</code> <code>Orientation</code> megad\u00e1sa eset\u00e9n egym\u00e1s mell\u00e9, <code>Vertical</code> <code>Orientation</code> eset\u00e9n egym\u00e1s al\u00e1 helyezi el. \u00cdgy a p\u00e9ld\u00e1nkban egyszer\u0171en egym\u00e1s mell\u00e9 teszi a k\u00e9t vez\u00e9rl\u0151t.</p> <p>Az eredm\u00e9ny a k\u00f6vetkez\u0151:</p> <p></p> <p>XAML vektorgrafikus vez\u00e9rl\u0151k</p> <p>L\u00e9nyeges, hogy a XAML vez\u00e9rl\u0151k nagy r\u00e9sze vektorgrafikus. Ez a gomb ugyanolyan \u00e9lesen fog kin\u00e9zni (nem tapasztalunk \"pixelesed\u00e9st\") b\u00e1rmilyen b\u00e1rmilyen DPI  ill. nagy\u00edt\u00e1s mellett n\u00e9zz\u00fck.</p> <p>A XAML-ben p\u00e9ld\u00e1nyos\u00edtott vez\u00e9rl\u0151k tulajdons\u00e1gainak megad\u00e1s\u00e1ra h\u00e1rom lehet\u0151s\u00e9g van (ezeket r\u00e9szben haszn\u00e1ltuk is m\u00e1r):</p> <ul> <li>Property ATTRIBUTE syntax</li> <li>Property ELEMENT syntax</li> <li>Property CONTENT syntax</li> </ul> <p>Tekints\u00fck \u00e1t most r\u00e9szletesebben ezeket a lehet\u0151s\u00e9geket:</p> <ol> <li> <p>Property ATTRIBUTE syntax.  M\u00e1r alkalmaztuk, m\u00e9gpedig a legels\u0151 p\u00e9ld\u00e1nkban:</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Az elnevez\u00e9s onnan ered, hogy a tulajdons\u00e1got XML attrib\u00fatum form\u00e1j\u00e1ban adjuk meg. Seg\u00edts\u00e9g\u00e9vel - mivel XML attrib\u00fatum csak string lehet! - csak sztring form\u00e1ban megadott egyszer\u0171 sz\u00e1m/sztring/stb. \u00e9rt\u00e9k, ill. code-behind f\u00e1jlban defini\u00e1lt tagv\u00e1ltoz\u00f3, esem\u00e9nykezel\u0151 \u00e9rhet\u0151 el. De t\u00edpuskonverterek seg\u00edts\u00e9g\u00e9vel \"\u00f6sszetett\" objektumok is megadhat\u00f3k. Err\u0151l sok sz\u00f3 nem lesz, de a be\u00e9p\u00edtett t\u00edpuskonvertereket sokszor haszn\u00e1ljuk, gyakorlatilag \"\u00f6szt\u00f6n\u00f6sen\". P\u00e9lda:</p> <p>Vegy\u00fcnk fel a <code>Grid</code>-re egy h\u00e1tt\u00e9rsz\u00ednt:</p> <pre><code>&lt;Grid Background=\"Azure\"&gt;\n</code></pre> <p>Vagy megadhatjuk hex\u00e1ban is:</p> <pre><code>&lt;Grid Background=\"#FFF0FFFF\"&gt;\n</code></pre> <p>A marg\u00f3 (<code>Margin</code>) is egy \u00f6sszetett \u00e9rt\u00e9k, a hozz\u00e1 tartoz\u00f3 t\u00edpuskonveter vessz\u0151vel (vagy sz\u00f3k\u00f6zzel) elv\u00e1lasztva v\u00e1rja a n\u00e9gy oldalra vonatkoz\u00f3 \u00e9rt\u00e9keket (bal, fent, jobb, lent). M\u00e1r haszn\u00e1ltuk is a <code>Record</code> felirat\u00fa TextBlockunk eset\u00e9ben. Megjegyz\u00e9s: marg\u00f3nak egyetlen sz\u00e1m is megadhat\u00f3, akkor mind a n\u00e9gy oldalra ugyanazt fogja alkalmazni.</p> </li> <li> <p>Property ELEMENT syntax. Seg\u00edts\u00e9g\u00e9vel egy tulajdons\u00e1got t\u00edpuskonverterek n\u00e9lk\u00fcl tudjuk egy \u00f6sszetett m\u00f3don p\u00e9ld\u00e1nyos\u00edtott/felparam\u00e9terezett objektumra \u00e1ll\u00edtani. N\u00e9zz\u00fck egy p\u00e9ld\u00e1n kereszt\u00fcl.</p> <ul> <li>A fenti p\u00e9ld\u00e1ban <code>Background</code> tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sakor az <code>Azure</code> val\u00f3j\u00e1ban egy <code>SolidColorBrush</code>-t hoz l\u00e9tre, melynek a sz\u00edn\u00e9t vil\u00e1gosk\u00e9kre \u00e1ll\u00edtja. Ezt t\u00edpuskonverter alkalmaz\u00e1sa n\u00e9lk\u00fcl az al\u00e1bbi m\u00f3don lehet megadni:</li> </ul> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush Color=\"Azure\" /&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p>Ez a <code>Grid</code> <code>Background</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtja be a megadott <code>SolidColorBrush</code>-ra. Ez az \u00fan. \"property element syntax\" alap\u00fa tulajdons\u00e1gmegad\u00e1s.</p> <ul> <li>A n\u00e9v onnan ered, hogy a tulajdons\u00e1got egy XML elem (\u00e9s pl. nem XML attrib\u00fatum) form\u00e1j\u00e1ban adjuk meg.</li> <li> Itt a <code>&lt;Grid.Background&gt;</code> elem nem objektump\u00e9ld\u00e1nyt hoz l\u00e9tre, hanem az adott (eset\u00fcnkben <code>Background</code>) property \u00e9rt\u00e9k\u00e9t \u00e1ll\u00edtja be a megfelel\u0151 objektum p\u00e9ld\u00e1ny\u00e1ra (eset\u00fcnkben egy <code>SolidColorBrush</code>-ra). Ezt az XML elem nev\u00e9ben lev\u0151 pont alapj\u00e1n lehet tudni.</li> <li>Ez \"terjeng\u0151sebb\" forma tulajdons\u00e1g megad\u00e1s\u00e1ra, de teljes rugalmass\u00e1got biztos\u00edt. </li> </ul> <p>Cser\u00e9lj\u00fck le a <code>SolidColorBrush</code>-t egy sz\u00edn\u00e1tmenetes <code>Brush</code>-ra (<code>LinearGradientBrush</code>):</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;LinearGradientBrush&gt;\n            &lt;LinearGradientBrush.GradientStops&gt;\n                &lt;GradientStop Color=\"Black\" Offset=\"0\" /&gt;\n                &lt;GradientStop Color=\"White\" Offset=\"1\" /&gt;\n            &lt;/LinearGradientBrush.GradientStops&gt;\n        &lt;/LinearGradientBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p><code>LinearGradientBrush</code>-ra nincs t\u00edpuskonverter, ezt csak az element syntax seg\u00edts\u00e9g\u00e9vel tudtuk megadni!</p> <p>K\u00e9rd\u00e9s, hogyan lehets\u00e9ges az, hogy a <code>Grid</code> vez\u00e9rl\u0151 <code>Background</code> tulajdons\u00e1g\u00e1nak <code>SolidColorBrush</code> \u00e9s <code>LinearGradientBrush</code> t\u00edpus\u00fa ecsetet is meg tudtunk adni? A v\u00e1lasz nagyon egyszer\u0171, a polimorfizmus teszi ezt lehet\u0151v\u00e9:</p> <ul> <li>A <code>SolidColorBrush</code> \u00e9s <code>LinearGradientBrush</code> oszt\u00e1lyok a be\u00e9p\u00edtett <code>Brush</code> oszt\u00e1ly lesz\u00e1rmazottai.</li> <li>A <code>Background</code> tulajdons\u00e1g egy <code>Brush</code> t\u00edpus\u00fa property, \u00edgy a polimorfizmus miatt b\u00e1rmely lesz\u00e1rmazottj\u00e1t lehet haszn\u00e1lni.</li> </ul> Note <ul> <li>A fenti p\u00e9ld\u00e1kban a <code>Color</code> (sz\u00edn) megad\u00e1s\u00e1n\u00e1l pl. a <code>Color=\"Azure\"</code> esetben az <code>Azure</code> sz\u00f3b\u00f3l is t\u00edpuskonverter k\u00e9sz\u00edt k\u00e9k <code>Color</code> p\u00e9ld\u00e1nyt. \u00cdgy n\u00e9zne a kor\u00e1bbi, <code>SolidColorBrush</code> alap\u00fa p\u00e9ld\u00e1nk teljesen kifejtve: <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush&gt;\n            &lt;SolidColorBrush.Color&gt;\n                &lt;Color&gt;#FFF0FFFF&lt;/Color&gt;\n            &lt;/SolidColorBrush.Color&gt;\n        &lt;/SolidColorBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre></li> <li>Ahol t\u00e1mogatott, \u00e9rdemes kihaszn\u00e1lni a t\u00edpuskonvertereket, \u00e9s attribute syntaxot haszn\u00e1lni, hogy ne legyen terjeng\u0151s a XAML le\u00edr\u00e1sunk.</li> <li>\u00c9rt\u00e9kt\u00edpusokn\u00e1l (<code>struct</code>), mint amilyen a <code>Color</code> is, m\u00e1r az objektum p\u00e9ld\u00e1nyos\u00edt\u00e1sakor (\"konstruktor id\u0151ben\") kell megadni az \u00e9rt\u00e9ket, ez\u00e9rt itt nem lehet a propertyket k\u00fcl\u00f6n \u00e1ll\u00edtgatni, musz\u00e1j t\u00edpuskonverterre b\u00edzni magunkat.</li> </ul> </li> <li> <p>Property CONTENT syntax. Annak \u00e9rdek\u00e9ben, hogy jobban meg\u00e9rts\u00fck, n\u00e9zz\u00fck meg, milyen h\u00e1romf\u00e9le m\u00f3don tudjuk be\u00e1ll\u00edtani egy gomb <code>Content</code> tulajdons\u00e1g\u00e1t valamilyen sz\u00f6vegre (ezt laboron nem kell megtenni, el\u00e9g, ha jelen \u00fatmutat\u00f3ban n\u00e9zz\u00fck k\u00f6z\u00f6sen):</p> <ul> <li>Property attribute syntax (m\u00e1r haszn\u00e1ltuk):     <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre></li> <li>\u00c1ll\u00edtsuk be az el\u0151z\u0151 pontban tanult property element syntax alapj\u00e1n:    <pre><code>&lt;Button&gt;\n    &lt;Button.Content&gt;\n    Hello WinUI App!\n    &lt;/Button.Content&gt;\n&lt;/Button&gt;\n</code></pre></li> <li>Minden vez\u00e9rl\u0151 meghat\u00e1rozhat mag\u00e1r\u00f3l egy kit\u00fcntetett \"Content\" tulajdons\u00e1got, melyn\u00e9l nem kell ki\u00edrni a nyit\u00f3 \u00e9s csuk\u00f3 tag-eket. Vagyis az el\u0151z\u0151 p\u00e9ld\u00e1ban alkalmazott <code>&lt;Button.Content&gt;</code> nyit\u00f3 \u00e9s z\u00e1r\u00f3 tag-ek enn\u00e9l az egy tulajdons\u00e1gn\u00e1l elhagyhat\u00f3k:    <pre><code>&lt;Button&gt;\n    Hello WinUI App!\n&lt;/Button&gt;\n</code></pre>    Vagy egy sorba \u00edrva:    <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre>    Ez ismer\u0151s, l\u00e1ttuk a bevezet\u0151 p\u00e9ld\u00e1nkban: ez az \u00fan. Property CONTENT syntax alap\u00fa tulajdons\u00e1gmegad\u00e1s. Az elnevez\u00e9s is sugallja, hogy ezt az egy tulajdons\u00e1got a vez\u00e9rl\u0151 \"tartalmi\" r\u00e9sz\u00e9ben, contentj\u00e9ben is megadhatjuk. Nem minden vez\u00e9rl\u0151 eset\u00e9ben <code>Content</code> ezen kit\u00fcntetett tulajdons\u00e1g neve:  <code>StackPanel</code>-n\u00e9l \u00e9s <code>Grid</code>-n\u00e9l <code>Children</code> a neve. Eml\u00e9kezz\u00fcnk vissza, ill. n\u00e9zz\u00fck meg a k\u00f3dot: ezeket m\u00e1r haszn\u00e1ltuk is:  ugyanakkor, nem \u00edrtuk ki a <code>StackPanel.Children</code>, ill. <code>Grid.Children</code> XML elemeket a <code>StackPanel</code>, ill. <code>Grid</code> belsej\u00e9nek megad\u00e1sakor (de megtehett\u00fck volna!)</li> </ul> </li> </ol> <p>\u00cdrjuk vissza a <code>Grid</code> h\u00e1tter\u00e9t valami szimpatikusan egyszer\u0171re, vagy t\u00f6r\u00f6lj\u00fck ki a h\u00e1tt\u00e9rsz\u00edn megad\u00e1s\u00e1t.</p>"},{"location":"labor/3-felhasznaloi-felulet/#esemenykezeles","title":"Esem\u00e9nykezel\u00e9s","text":"<p>A XAML applik\u00e1ci\u00f3k esem\u00e9nyvez\u00e9relt alkalmaz\u00e1sok. Minden felhaszn\u00e1l\u00f3i interakci\u00f3r\u00f3l esem\u00e9nyek seg\u00edts\u00e9g\u00e9vel \u00e9rtes\u00fcl\u00fcnk, ezek hat\u00e1s\u00e1ra friss\u00edthetj\u00fck a fel\u00fcletet.</p> <p>Most kezelj\u00fck le a gombon t\u00f6rt\u00e9n\u0151 kattint\u00e1st.</p> <p>El\u0151k\u00e9sz\u00edt\u0151 l\u00e9p\u00e9sk\u00e9nt adjunk nevet a <code>TextBlock</code> vez\u00e9rl\u0151nknek, hogy a code-behind f\u00e1jlb\u00f3l hivatkozni tudjunk majd r\u00e1 a k\u00e9s\u0151bbiekben:</p> <pre><code>&lt;TextBlock x:Name=\"recordTextBlock\" Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n</code></pre> <p>Az <code>x:Name</code> a XAML parsernek sz\u00f3l, \u00e9s ezen a n\u00e9ven fog l\u00e9trehozni egy tagv\u00e1ltoz\u00f3t az oszt\u00e1lyunkban, mely az adott vez\u00e9rl\u0151 referenci\u00e1j\u00e1t tartalmazza.  Gondoljuk \u00e1t: mivel tagv\u00e1ltoz\u00f3 lesz, a code-behind f\u00e1jlban el tudjuk \u00e9rni, hiszen az egy \"partial r\u00e9sze\" ugyanazon oszt\u00e1lynak!</p> <p>Elnevezett vez\u00e9rl\u0151k</p> <p>Ne adjunk nevet azoknak a vez\u00e9rl\u0151knek, melyekre nem akarunk hivatkozni. (Szoktassuk magunkat arra, hogy csak arra hivatkozunk k\u00f6zvetlen\u00fcl, amire nagyon musz\u00e1j. Ebben az adatk\u00f6t\u00e9s is seg\u00edt majd.)</p> <p>Kiv\u00e9tel: Ha nagyon bonyolult a vez\u00e9rl\u0151hierarchi\u00e1nk, seg\u00edthetnek a nevek a k\u00f3d \u00e1tl\u00e1that\u00f3bb\u00e1 t\u00e9tel\u00e9ben, mivel a Live Visual Tree ablakban megjelennek, illetve a gener\u00e1lt esem\u00e9nykezel\u0151-nevek is ehhez igazodnak.</p> <p>Kezelj\u00fck le a gomb <code>Click</code> esem\u00e9ny\u00e9t, majd pr\u00f3b\u00e1ljuk ki a k\u00f3dot.</p> MainWindow.xaml-be<pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> MainWindow.xaml.cs-be<pre><code>private void RecordButton_Click(object sender, RoutedEventArgs e)\n{\n    recordTextBlock.Text = \"Recording...\";\n}\n</code></pre> <p>Esem\u00e9nykezel\u0151k l\u00e9trehoz\u00e1sa</p> <p>Ha az esem\u00e9nykezel\u0151kn\u00e9l nem a New Event Handler-t v\u00e1lasztjuk, hanem be\u00edrjuk k\u00e9zzel a k\u00edv\u00e1nt nevet, majd F12-t nyomunk, vagy a jobb gomb / Go to Definition-t v\u00e1lasztjuk, az esem\u00e9nykezel\u0151 legener\u00e1l\u00e1sra ker\u00fcl a code-behind f\u00e1jlban.</p> <p>Az esem\u00e9nykezel\u0151nek k\u00e9t param\u00e9tere van: a k\u00fcld\u0151 objektum (<code>object sender</code>) \u00e9s az esem\u00e9ny param\u00e9tereit/k\u00f6r\u00fclm\u00e9nyeit tartalmaz\u00f3 param\u00e9ter (<code>EventArgs e</code>). N\u00e9zz\u00fck ezeket r\u00e9szletesebben:</p> <ul> <li><code>object sender</code>: Az esem\u00e9ny kiv\u00e1lt\u00f3ja. Eset\u00fcnkben ez maga a gomb, <code>Button</code>-ra kasztolva haszn\u00e1lhatn\u00e1nk is. Ritk\u00e1n haszn\u00e1ljuk ez a param\u00e9tert.</li> <li>A m\u00e1sodik param\u00e9ter mindig <code>EventArgs</code> t\u00edpus\u00fa, vagy annak lesz\u00e1rmazottja (ez az esem\u00e9ny t\u00edpus\u00e1t\u00f3l f\u00fcgg), melyben az esem\u00e9ny param\u00e9tereit kapjuk meg. A <code>Click</code> esem\u00e9ny eset\u00e9ben ez <code>RoutedEventArgs</code> t\u00edpus\u00fa.</li> </ul> <p>Esem\u00e9nyargumentumok</p> <p>N\u00e9h\u00e1ny esem\u00e9nyargumentum t\u00edpus:</p> <ul> <li><code>RoutedEventArgs</code>: pl. a <code>Click</code> esem\u00e9ny est\u00e9ben haszn\u00e1land\u00f3, ahogy a p\u00e9ld\u00e1nkban is volt. Az <code>OriginalSource</code> tulajdons\u00e1gban megkapjuk azt a vez\u00e9rl\u0151t, melyn\u00e9l el\u0151sz\u00f6r kiv\u00e1lt\u00f3dott az esem\u00e9ny.<ul> <li>Megjegyz\u00e9s: a fenti esetben ez maga a gomb, de ha pl. egy eg\u00e9rlenyom\u00e1s esem\u00e9nyt (nem a <code>Click</code>, hanem <code>PointerPressed</code>) kezeln\u00e9nk pl. a <code>StackPanel</code>-en, akkor lehet, hogy az egyik gyerekelem\u00e9t kapn\u00e1nk meg, ha arra kattintottak.</li> </ul> </li> <li><code>KeyRoutedEventArgs</code>: pl. <code>KeyDown</code> (billenty\u0171 lenyom\u00e1sa) esem\u00e9ny eset\u00e9ben megkapjuk benne a lenyomott billenty\u0171t.</li> <li><code>PointerRoutedEventArgs</code>: pl. <code>PointerPressed</code> (eg\u00e9r/toll lenyom\u00e1sa) esem\u00e9ny eset\u00e9ben haszn\u00e1ljuk, rajta kereszt\u00fcl lek\u00e9rdezhet\u0151k - t\u00f6bbek k\u00f6z\u00f6tt - a kattint\u00e1s koordin\u00e1t\u00e1i.</li> </ul> <p>A XAML esem\u00e9nykezel\u0151k teljes eg\u00e9sz\u00e9ben a C# nyelv esem\u00e9nyeire \u00e9p\u00fclnek (<code>event</code> kulcssz\u00f3, l\u00e1sd el\u0151z\u0151 gyakorlat):</p> <p>Pl. a</p> <pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> <p>erre k\u00e9pz\u0151dik le:</p> <pre><code>Button b = new Button();\nb.Click += RecordButton_Click;\n</code></pre>"},{"location":"labor/3-felhasznaloi-felulet/#layout-elrendezes","title":"Layout, elrendez\u00e9s","text":"<p>A vez\u00e9rl\u0151k elrendez\u00e9s\u00e9t k\u00e9t dolog hat\u00e1rozza meg:</p> <ol> <li>Layout (panel) vez\u00e9rl\u0151k \u00e9s kapcsolhat\u00f3 tulajdons\u00e1gaik (attached property)</li> <li>Sz\u00fcl\u0151 vez\u00e9rl\u0151n bel\u00fcli \u00e1ltal\u00e1nos poz\u00edci\u00f3 tulajdons\u00e1gok (pl. marg\u00f3, igaz\u00edt\u00e1s f\u00fcgg\u0151legesen vagy v\u00edzszintesen)</li> </ol> <p>Be\u00e9p\u00edtett layout vez\u00e9rl\u0151k p\u00e9ld\u00e1ul:</p> <ul> <li><code>StackPanel</code>: elemek egym\u00e1s alatt vagy mellett</li> <li><code>Grid</code>: defini\u00e1lhatunk egy r\u00e1csot, melyhez igazodnak az elemek</li> <li><code>Canvas</code>: explicit poz\u00edcion\u00e1lhat\u00f3k az elemek az X \u00e9s Y koordin\u00e1t\u00e1juk megad\u00e1s\u00e1val</li> <li><code>RelativePanel</code>: elemek egym\u00e1shoz k\u00e9pesti viszony\u00e1t hat\u00e1rozhatjuk meg k\u00e9nyszerekkel</li> </ul> <p>A <code>Grid</code>-et fogjuk kipr\u00f3b\u00e1lni (\u00e1ltal\u00e1ban ezt haszn\u00e1ljuk az ablakunk/oldalunk alapelrendez\u00e9s\u00e9nek kialak\u00edt\u00e1s\u00e1ra). Egy olyan fel\u00fcletet k\u00e9sz\u00edt\u00fcnk el, melyen szem\u00e9lyeket lehet egy list\u00e1ba felvenni, nev\u00fck \u00e9s \u00e9letkoruk megad\u00e1s\u00e1val. A k\u00f6vetkez\u0151 elrendez\u00e9s kialak\u00edt\u00e1sa a v\u00e9gs\u0151 c\u00e9lunk:</p> <p></p> <p>P\u00e1r l\u00e9nyeges viselked\u00e9sbeli megk\u00f6t\u00e9s:</p> <ul> <li>Az ablak \u00e1tm\u00e9retez\u00e9sekor az \u0171rlap fix sz\u00e9less\u00e9g\u0171 legyen, \u00e9s maradjon k\u00f6z\u00e9pre igaz\u00edtva.</li> <li>Az Age sorban a + gombbal n\u00f6velhet\u0151, a - gombbal cs\u00f6kkenthet\u0151 az \u00e9letkor.</li> <li>Az Add gombbal a fent meghat\u00e1rozott adatokkal felveszi a szem\u00e9lyt az als\u00f3 list\u00e1ba (az \u00e1br\u00e1n az als\u00f3 list\u00e1ban k\u00e9t szem\u00e9ly adatai l\u00e1that\u00f3k).</li> </ul> <p>Defini\u00e1ljunk a gy\u00f6k\u00e9r <code>Grid</code>-en 4 sort \u00e9s 2 oszlopot. Az els\u0151 oszlop\u00e1ba ker\u00fcljenek a c\u00edmk\u00e9k, a m\u00e1sodik oszlopba pedig a beviteli mez\u0151k. A megl\u00e9v\u0151 gombunkat is rakjuk a 3. sorba, \u00e9s \u00edrjuk \u00e1t a tartalm\u00e1t Add-ra, a k\u00f6r helyett pedig vegy\u00fcnk fel egy <code>SymbolIcon</code>-t. A 4. sorban pedig list\u00e1t helyezz\u00fcnk el, ami 2 oszlopot is foglaljon el.</p> <pre><code>&lt;Grid x:Name=\"rootGrid\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" /&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" /&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\" /&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\"/&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>A sor- \u00e9s oszlopdefin\u00edci\u00f3k eset\u00e9ben megadhatjuk, hogy az adott sor vegye fel a tartalm\u00e1nak a m\u00e9ret\u00e9t (<code>Auto</code>), vagy t\u00f6ltse ki a marad\u00e9k helyet (<code>*</code>), de ak\u00e1r fix sz\u00e9less\u00e9get is megadhatn\u00e1nk pixelben (<code>Width</code> tulajdons\u00e1g). Ha t\u00f6bb <code>*</code> is szerepel a defin\u00edci\u00f3kban, akkor azok ar\u00e1nyos\u00edthat\u00f3ak pl.: <code>*</code> \u00e9s <code>*</code> 1:1-es ar\u00e1nyt jelent, m\u00edg a <code>*</code> \u00e9s <code>3*</code> 1:3-at.</p> <p>A <code>Grid.Row</code>, <code>Grid.Column</code> \u00fagynevezett Attached Property-k (csatolt tulajdons\u00e1gok). Ez azt jelenti, hogy a vez\u00e9rl\u0151, melyn\u00e9l alkalmazzuk, nem rendelkezik ilyen tulajdons\u00e1ggal, \u00e9s ezt az inform\u00e1ci\u00f3t csak \u201ehozz\u00e1csatoljuk\u201d. Ez az inform\u00e1ci\u00f3 eset\u00fcnkben a <code>Grid</code>-nek lesz fontos, hogy el tudja helyezni a gyerekeit. A <code>Grid.Row</code> \u00e9s <code>Grid.Column</code> alap\u00e9rtelmezett \u00e9rt\u00e9ke a 0, teh\u00e1t ezt ki sem k\u00e9ne \u00edrnunk.</p> <p>Imperat\u00edv UI le\u00edr\u00e1s</p> <p>M\u00e1s UI keretrendszerekben, ahol imperat\u00edv a fel\u00fclet \u00f6ssze\u00e1ll\u00edt\u00e1sa, ezt egyszer\u0171en megoldj\u00e1k f\u00fcggv\u00e9nyparam\u00e9terekkel \u2013 pl.: <code>myPanel.Add(new TextBox(), 0, 1)</code>.</p> <p>M\u00e9g magyar\u00e1zatra szorulhat a <code>ListView</code>-n\u00e1l megadott <code>Grid.ColumnSpan=\"2\"</code> csatolt tulajdons\u00e1g: a <code>ColumnSpan</code> \u00e9s <code>RowSpan</code> azt hat\u00e1rozz\u00e1k meg, h\u00e1ny oszlopon illetve soron \"\u00e1t\u00edvel\u0151en\" helyezkedjen el a vez\u00e9rl\u0151. A p\u00e9ld\u00e1nkban a <code>ListView</code> mindk\u00e9t oszlopot kit\u00f6lti.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st (ha nem fordul a k\u00f3d, akkor t\u00f6r\u00f6lj\u00fck a code behind f\u00e1jlban a <code>RecordButton_Click</code> esem\u00e9nykezel\u0151t).</p> <p>Jelen \u00e1llapot\u00e1ban a <code>Grid</code> kit\u00f6lti a teljes teret v\u00edzszintesen \u00e9s f\u00fcgg\u0151legesen is. Mi ennek az oka? A vez\u00e9rl\u0151k elrendez\u00e9s\u00e9nek egyik alapil\u00e9re a <code>HorizontalAlignment</code> \u00e9s <code>VerticalAlignment</code>  tulajdons\u00e1guk. Ezek azt hat\u00e1rozz\u00e1k meg, hogy v\u00edzszintesen \u00e9s f\u00fcgg\u0151legesen hol helyezkedjen el az adott vez\u00e9rl\u0151 az \u0151t tartalmaz\u00f3 kont\u00e9nerben (vagyis a sz\u00fcl\u0151 vez\u00e9rl\u0151ben). A lehets\u00e9ges \u00e9rt\u00e9kek:</p> <ul> <li><code>HorizontalAlignment</code>: <code>Top</code>, <code>Center</code>, <code>Bottom</code>, <code>Stretch</code> (fel\u00fclre, k\u00f6z\u00e9pre, alulra igaz\u00edtva, vagy t\u00e9r kit\u00f6lt\u00e9se f\u00fcgg\u0151legesen)</li> <li><code>VerticalAlignment</code>: <code>Left</code>, <code>Center</code>, <code>Right</code>, <code>Stretch</code> (balra, k\u00f6z\u00e9pre, jobbra igaz\u00edtva, vagy t\u00e9r kit\u00f6lt\u00e9se v\u00edzszintesen)</li> </ul> <p>(Megjegyz\u00e9s: a Stretch eset\u00e9ben sz\u00fcks\u00e9ges, hogy ne legyen a <code>Height</code> ill. <code>Width</code> tujadons\u00e1g megadva a vez\u00e9rl\u0151re.)</p> <p>A <code>Grid</code>-\u00fcnknek nem adtunk meg <code>HorizontalAlignment</code> \u00e9s <code>VerticalAlignment</code> tulajdons\u00e1got, \u00edgy annak \u00e9rt\u00e9ke a Grid eset\u00e9ben alap\u00e9rtelmezett <code>Stretch</code>, emiatt a <code>Grid</code> mindk\u00e9t ir\u00e1nyban kit\u00f6lti a teret a sz\u00fcl\u0151 kont\u00e9ner\u00e9ben, vagyis az ablakban.</p> <p>A fel\u00fclet\u00fcnk m\u00e9g nem \u00fagy n\u00e9z ki, mint amit szeretn\u00e9nk, finom\u00edtsunk kicsit a kin\u00e9zet\u00e9n. Az eszk\u00f6zlend\u0151 v\u00e1ltoz\u00e1sok:</p> <ul> <li>Ne t\u00f6ltse ki az eg\u00e9sz k\u00e9perny\u0151t a t\u00e1bl\u00e1zat, hanem legyen v\u00edzszintesen k\u00f6z\u00e9pen<ul> <li><code>HorizontalAlignment=\"Center\"</code></li> </ul> </li> <li>Legyen 300px sz\u00e9les<ul> <li><code>Width=\"300\"</code></li> </ul> </li> <li>Legyen a sorok k\u00f6z\u00f6tt 10px, az oszlopok k\u00f6z\u00f6tt 5px t\u00e1vols\u00e1g \u00e9s tartsunk 20px t\u00e1vols\u00e1got a kont\u00e9ner sz\u00e9l\u00e9t\u0151l<ul> <li><code>RowSpacing=\"5\" ColumnSpacing=\"10\" Margin=\"20\"</code></li> </ul> </li> <li>Igaz\u00edtsuk a c\u00edmk\u00e9ket (<code>TexBlock</code>) f\u00fcgg\u0151legesen k\u00f6z\u00e9pre<ul> <li><code>VerticalAlignment=\"Center\"</code></li> </ul> </li> <li>Igaz\u00edtsuk a gombot jobbra<ul> <li><code>HorizontalAlignment=\"Right\"</code></li> </ul> </li> <li>Tegy\u00fck beazonos\u00edthat\u00f3v\u00e1 a list\u00e1t<ul> <li><code>BorderThickness=\"1\"</code> \u00e9s <code>BorderBrush=\"DarkGray\"</code></li> </ul> </li> </ul> <pre><code>&lt;Grid x:Name=\"rootGrid\"\n      Width=\"300\"\n      HorizontalAlignment=\"Center\"\n      Margin=\"20\"\n      RowSpacing=\"5\"\n      ColumnSpacing=\"10\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbName\" /&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\" HorizontalAlignment=\"Right\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\"/&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\" /&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\"\n              Grid.Column=\"0\"\n              Grid.ColumnSpan=\"2\"\n              BorderThickness=\"1\"\n              BorderBrush=\"DarkGray\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>B\u0151v\u00edts\u00fck ki m\u00e9g k\u00e9t gombbal az \u0171rlapunkat (\u00b1 gombok az \u00e9letkorhoz, l\u00e1sd kor\u00e1bbi anim\u00e1lt k\u00e9perny\u0151k\u00e9p):</p> <ul> <li>\u2019-\u2019: a <code>TextBox</code> bal oldal\u00e1n</li> <li>\u2019+\u2019 a<code>TextBox</code> jobb oldal\u00e1n</li> </ul> <p>Ehhez vegy\u00fcnk fel a</p> <pre><code>&lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n</code></pre> <p>sor hely\u00e9re (azt kit\u00f6r\u00f6lve) egy 1 soros, 3 oszloppal rendelkez\u0151 <code>Grid</code>-et:</p> <pre><code>&lt;Grid Grid.Row=\"1\" Grid.Column=\"1\" ColumnSpacing=\"5\"&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"0\" Content=\"-\" /&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbAge\" /&gt;\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"2\" Content=\"+\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>T\u00f6bb layout vez\u00e9rl\u0151 egym\u00e1sba \u00e1gyaz\u00e1sa</p> <p>Feltehetj\u00fck a k\u00e9rd\u00e9st, hogy mi\u00e9rt nem a k\u00fcls\u0151 <code>Grid</code>-ben vett\u00fcnk fel plusz oszlopokat \u00e9s sorokat (a <code>ColumnSpan</code> megfelel\u0151 alkalmaz\u00e1s\u00e1val a megl\u00e9v\u0151 vez\u00e9rl\u0151kre). Helyette egys\u00e9gbez\u00e1r\u00e1s elv\u00e9t k\u00f6vett\u00fck: az \u00fajonnan bevezetett vez\u00e9rl\u0151k alapvet\u0151en egybe tartoz\u00f3 elemek, \u00edgy \u00e1tl\u00e1that\u00f3bb megold\u00e1st kaptunk az\u00e1ltal, hogy k\u00fcl\u00f6n <code>Grid</code> vez\u00e9rl\u0151be tett\u00fck \u0151ket. A k\u00fcls\u0151 <code>Grid</code> b\u0151v\u00edt\u00e9se akkor lenne indokolt, ha sp\u00f3rolni akarn\u00e1nk a vez\u00e9rl\u0151k l\u00e9trehoz\u00e1s\u00e1val, teljes\u00edtm\u00e9nyokok miatt. Eset\u00fcnkben ez nem indokolt.</p> <p>K\u00e9szen is vagyunk az egyszer\u0171 \u0171rlapunk kin\u00e9zet\u00e9nek kialak\u00edt\u00e1s\u00e1val.</p>"},{"location":"labor/3-felhasznaloi-felulet/#adatkotes","title":"Adatk\u00f6t\u00e9s","text":""},{"location":"labor/3-felhasznaloi-felulet/#binding","title":"Binding","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben azt oldjuk meg, hogy az el\u0151bb elk\u00e9sz\u00edtett kis \u0171rlapon egy szem\u00e9ly adatait lehessen megadni, m\u00f3dos\u00edtani. Ehhez el\u0151sz\u00f6r k\u00e9sz\u00edts\u00fcnk egy adatoszt\u00e1lyt <code>Person</code> n\u00e9ven a project egy \u00fajonnan l\u00e9trehozott <code>Models</code> mapp\u00e1j\u00e1ba.</p> <pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n</code></pre> <p>Azt itt l\u00e9v\u0151 k\u00e9t tulajdons\u00e1got akarjuk a <code>TextBox</code> vez\u00e9rl\u0151kh\u00f6z k\u00f6tni, ehhez adatk\u00f6t\u00e9st fogunk alkalmazni. Az ablakunk code-behind f\u00e1jlj\u00e1ban vezess\u00fcnk be egy propertyt, mely egy <code>Person</code> objektumra hivatkozik, \u00e9s adjunk ennek kezd\u0151\u00e9rt\u00e9ket a konstruktorban:</p> <pre><code>public Person NewPerson { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n}\n</code></pre> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a fenti <code>NewPerson</code> objektum</p> <ul> <li><code>Name</code> tulajdons\u00e1g\u00e1t k\u00f6ss\u00fck hozz\u00e1 a <code>tbName</code> <code>Textbox</code> <code>Text</code> tulajdons\u00e1g\u00e1hoz</li> <li><code>Age</code> tulajdons\u00e1g\u00e1t k\u00f6ss\u00fck hozz\u00e1 a <code>tbAge</code> <code>Textbox</code> <code>Text</code> tulajdons\u00e1g\u00e1hoz , m\u00e9gpedig adatk\u00f6t\u00e9ssel (data binding):</li> </ul> <p><pre><code>Text=\"{x:Bind NewPerson.Name}\"\nText=\"{x:Bind NewPerson.Age}\"\n</code></pre> (a <code>tbName</code> ill. <code>tbAge</code> <code>TextBox</code>-ok soraiba vegy\u00fck fel a fenti 1-1 tulajdons\u00e1g be\u00e1ll\u00edt\u00e1st)</p> <p>Fontos</p> <p>Az adatk\u00f6t\u00e9snek az a l\u00e9nyege, hogy nem k\u00e9zzel, a code-behind f\u00e1jlb\u00f3l \u00e1ll\u00edtgatjuk a fel\u00fcleten megjelen\u0151 vez\u00e9rl\u0151k tulajdons\u00e1gait (eset\u00fcnkben a sz\u00f6veg\u00e9t), hanem \u00f6sszerendelj\u00fck/ \u00f6sszek\u00f6tj\u00fck a tulajdons\u00e1gokat a platform adatk\u00f6t\u00e9s mechanizmus\u00e1val. \u00cdgy azt is el\u00e9rhetj\u00fck, hogyha az egyik tulajdons\u00e1g megv\u00e1ltozik, akkor a m\u00e1sik is automatikusan v\u00e1ltozzon meg!</p> <p>A <code>Text=\"{x:Bind}\"</code> szintaktika az \u00fagynevezett markup extension: ez speci\u00e1lis jelent\u00e9ssel rendelkezik a XAML feldolgoz\u00f3 sz\u00e1m\u00e1ra. Els\u0151sorban emiatt haszn\u00e1lunk XAML \u00e9s nem sima XML-t. Lehet\u0151s\u00e9g\u00fcnk van ak\u00e1r saj\u00e1t Markup Extension-t is k\u00e9sz\u00edteni, de ez nem tananyag.</p> <p>Futtassuk! L\u00e1that\u00f3, hogy az adatk\u00f6t\u00e9s miatt automatikusan beker\u00fclt a k\u00e9t <code>TextBox</code> <code>Text</code> tulajdons\u00e1g\u00e1ba a <code>NewPerson</code> objektum (mint adatforr\u00e1s) <code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1gaiban megadott n\u00e9v \u00e9s \u00e9letkor.</p>"},{"location":"labor/3-felhasznaloi-felulet/#valtozasertesites","title":"V\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9s","text":"<p>Implement\u00e1ljuk a \u00b1 gombok <code>Click</code> esem\u00e9nykezel\u0151it.</p> <pre><code>&lt;Button Grid.Row=\"1\" Grid.Column=\"0\" Content=\"-\" Click=\"DecreaseButton_Click\"/&gt;\n&lt;!-- ... --&gt;\n&lt;Button Grid.Row=\"1\" Grid.Column=\"2\" Content=\"+\" Click=\"IncreaseButton_Click\"/&gt;\n</code></pre> <pre><code>private void DecreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age--;\n}\n\nprivate void IncreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age++;\n}\n</code></pre> <p>A kor\u00e1bbi pontban bevezetett adatk\u00f6t\u00e9s miatt azt v\u00e1rn\u00e1nk, hogy ha a <code>NewPerson</code> adatforr\u00e1s <code>Age</code> tulajdons\u00e1g\u00e1t v\u00e1ltoztatjuk a fenti esem\u00e9nykezel\u0151kben, akkor a fel\u00fclet\u00fcnk\u00f6n a <code>tbAge</code> <code>Textbox</code> vez\u00e9rl\u0151nk ezt lek\u00f6veti. Pr\u00f3b\u00e1ljuk ki! Ez m\u00e9g egyel\u0151re nem m\u0171k\u00f6dik, ugyanis ehhez sz\u00fcks\u00e9g van m\u00e9g az <code>INotifyPropertyChanged</code> interf\u00e9sz megval\u00f3s\u00edt\u00e1s\u00e1ra is.</p> <ol> <li> <p>Implement\u00e1ljuk az <code>INotifyPropertyChanged</code> interf\u00e9szt a <code>Person</code> oszt\u00e1lyunkban. Ha adatk\u00f6t\u00fcnk ehhez az oszt\u00e1lyhoz, akkor a rendszer a <code>PropertyChanged</code> esem\u00e9nyre fog feliratkozni, ennek az esem\u00e9nynek a els\u00fct\u00e9s\u00e9vel tudjuk \u00e9rtes\u00edteni a bindingot, ha egy property megv\u00e1ltozott.</p> <pre><code>public class Person : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        set\n        {\n            if (name != value)\n            {\n                name = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n            }\n        }\n    }\n\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set\n        {\n            if (age != value)\n            {\n                age = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Age)));\n            }\n        }\n    }\n}\n</code></pre> <p>Terjeng\u0151s a k\u00f3d?</p> <p>A k\u00e9s\u0151bbiekben ezt a logik\u00e1t ki is szervezhetn\u00e9nk egy \u0151soszt\u00e1lyba, de ez m\u00e1r az MVVM mint\u00e1t vezetn\u00e9 el\u0151, mely egy k\u00e9s\u0151bbi tematik\u00e1hoz kapcsol\u00f3dik. Teh\u00e1t ne ijedj\u00fcnk meg ett\u0151l a kiss\u00e9 cs\u00fany\u00e1nyka k\u00f3dt\u00f3l.</p> </li> <li> <p>Az adatk\u00f6t\u00e9sen kapcsoljuk be a v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9st a <code>Mode</code> <code>OneWay</code>-re t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1s\u00e1val, mivel az <code>x:Bind</code> alap\u00e9rtelmezett m\u00f3dja a <code>OneTime</code>, mely csak egyszeri adatk\u00f6t\u00e9st jelent.</p> <pre><code>Text=\"{x:Bind NewPerson.Age, Mode=OneWay}\"\n</code></pre> </li> </ol> <p>Pr\u00f3b\u00e1ljuk ki! Az esem\u00e9nykezel\u0151k v\u00e1ltoztatj\u00e1k az adatforr\u00e1st (<code>NewPerson</code>), ennek hat\u00e1s\u00e1ra most m\u00e1r v\u00e1ltozik a fel\u00fclet is a megfelel\u0151en el\u0151k\u00e9sz\u00edtett adatk\u00f6t\u00e9s miatt.</p>"},{"location":"labor/3-felhasznaloi-felulet/#vissza-vezerlobol-adatforrasba-iranyu-adatkotes","title":"Vissza (vez\u00e9rl\u0151b\u0151l adatforr\u00e1sba) ir\u00e1ny\u00fa adatk\u00f6t\u00e9s","text":"<p>Az Age mint\u00e1j\u00e1ra, a Name tulajdons\u00e1gra vonatkoz\u00f3 adatk\u00f6t\u00e9st is \u00e1ll\u00edtsuk egyir\u00e1ny\u00fara:</p> <pre><code>Text=\"{x:Bind NewPerson.Name, Mode=OneWay}\"\n</code></pre> <p>Ind\u00edtsuk ez az alkalmaz\u00e1st, majd ezt k\u00f6vet\u0151en tegy\u00fcnk egy t\u00f6r\u00e9spontot a <code>Person</code> oszt\u00e1ly <code>Name</code> tulajdons\u00e1g\u00e1nak setter\u00e9be (<code>if (name != value)</code> sor) , \u00e9s pr\u00f3b\u00e1ljuk, hogy vissza ir\u00e1nyba is m\u0171k\u00f6dik-e az adatk\u00f6t\u00e9s: ha megv\u00e1ltoztatjuk az egyik <code>TextBox</code> \u00e9rt\u00e9k\u00e9t, megv\u00e1ltozik-e a <code>NewPerson</code> objektum <code>Name</code> tulajdons\u00e1ga? G\u00e9pelj\u00fcnk valamit a Name-hez tartoz\u00f3 sz\u00f6vegdobozba, majd kattintsunk \u00e1t egy m\u00e1sik mez\u0151be: ekkor a Textbox tartalma \"v\u00e9gleges\u00edt\u0151dik\", tartalma vissza kellene \u00edr\u00f3djon az adatforr\u00e1sba, de m\u00e9gsem t\u00f6rt\u00e9nik meg, nem fut r\u00e1 a k\u00f3d a t\u00f6r\u00e9spontunkra.</p> <p>Ez az\u00e9rt van \u00edgy, mert fentebb <code>OneWay</code> adatk\u00f6t\u00e9st haszn\u00e1ltunk, mely csak az adatforr\u00e1sb\u00f3l a fel\u00fcletre ir\u00e1ny\u00fa adatk\u00f6t\u00e9st jelent. A vissza ir\u00e1nyhoz <code>TwoWay</code>-re kell \u00e1ll\u00edtsuk az adatk\u00f6t\u00e9s m\u00f3dj\u00e1t.</p> <pre><code>Text=\"{x:Bind Name, Mode=TwoWay}\"\nText=\"{x:Bind Age, Mode=TwoWay}\"\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki! \u00cdgy m\u00e1r m\u0171k\u00f6dik a vissza ir\u00e1ny\u00fa adatk\u00f6t\u00e9s is: a vez\u00e9rl\u0151 adott tulajdons\u00e1ga (eset\u00fcnkben sz\u00f6vege) \u00e9s az adatforr\u00e1s b\u00e1rmely ir\u00e1ny\u00fa v\u00e1ltoz\u00e1s eset\u00e9n szinkronban marad.</p>"},{"location":"labor/3-felhasznaloi-felulet/#listak","title":"List\u00e1k","text":"<p>A k\u00f6vetkez\u0151kben a list\u00e1s adatk\u00f6t\u00e9s alkalmaz\u00e1s\u00e1t fogjuk gyakorolni. Vegy\u00fck fel a <code>Person</code>-\u00f6k list\u00e1j\u00e1t a n\u00e9zet\u00fcnk code-behind f\u00e1jlj\u00e1ba, a konstruktor elej\u00e9n pedig adjunk neki kezd\u0151\u00e9rt\u00e9ket.</p> <pre><code>public List&lt;Person&gt; People { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n\n    People = new List&lt;Person&gt;()\n    {\n      new Person() { Name = \"Peter Griffin\", Age = 40 },\n      new Person() { Name = \"Homer Simpson\", Age = 42 },\n    };\n}\n</code></pre> <p>Adatk\u00f6t\u00e9ssel \u00e1ll\u00edtsuk be a <code>ListView</code> vez\u00e9rl\u0151 <code>ItemsSource</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl, milyen adatforr\u00e1sb\u00f3l dolgozzon.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"/&gt;\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>L\u00e1tjuk, hogy megjelent k\u00e9t elem a list\u00e1ban. Persze nem az van ki\u00edrva, amit mi szeretn\u00e9nk, de ezen k\u00f6nnyen seg\u00edthet\u00fcnk. Alap\u00e9rtelmezetten ugyanis a <code>ListView</code> a <code>ToString()</code>-et h\u00edv a listaelemeken, ami ha nem defini\u00e1ljuk fel\u00fcl, akkor az oszt\u00e1ly t\u00edpus\u00e1nak <code>FullName</code> tulajdons\u00e1ga (vagyis a t\u00edpus neve).</p> <p>\u00c1ll\u00edtsunk be a <code>ListView</code>-nk <code>ItemTemplate</code> tulajdons\u00e1g\u00e1t (a m\u00e1r j\u00f3l ismert property element syntax-szal), mely a listaelem megjelen\u00e9s\u00e9t adja meg egy sablon seg\u00edts\u00e9g\u00e9vel: eset\u00fcnkben legyen ez egycell\u00e1s <code>Grid</code>, ahol a <code>TextBlock</code>-ok a <code>Person</code> tulajdons\u00e1gait jelen\u00edtik meg, a nevet balra, az \u00e9letkort jobbra igaz\u00edtva.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"&gt;\n    &lt;ListView.ItemTemplate&gt;\n        &lt;DataTemplate x:DataType=\"model:Person\"&gt;\n            &lt;Grid&gt;\n                &lt;TextBlock Text=\"{x:Bind Name}\" /&gt;\n                &lt;TextBlock Text=\"{x:Bind Age}\" HorizontalAlignment=\"Right\" /&gt;\n            &lt;/Grid&gt;\n        &lt;/DataTemplate&gt;\n    &lt;/ListView.ItemTemplate&gt;\n&lt;/ListView&gt;\n</code></pre> <p>A <code>DataTemplate</code> egy olyan fel\u00fcletsablon, melyet a <code>ListView</code> (he megadjuk az <code>ItemTemplate</code> tulajdons\u00e1g\u00e1nak) minden elem\u00e9re alkalmazni fog a megjelen\u00edt\u00e9s sor\u00e1n.</p> <p>Mivel az <code>x:Bind</code> ford\u00edt\u00e1s idej\u0171 adatk\u00f6t\u00e9s, ez\u00e9rt az adatok t\u00edpus\u00e1t is meg kell adnunk az adatsablonban az <code>x:DataType</code> attrib\u00fatummal. A fenti p\u00e9ld\u00e1ban a <code>model:Person</code>-t adtuk meg, vagyis azt szeretn\u00e9nk, hogy a <code>model</code> prefix a k\u00f3dunk <code>HelloXaml.Models</code> n\u00e9vter\u00e9re k\u00e9pz\u0151dj\u00f6n le (hiszen ebben van a <code>Person</code> oszt\u00e1ly). Ehhez a XAML f\u00e1jlunk elej\u00e9n a <code>Window</code> tag attrib\u00fatumaihoz fel kell vegy\u00fck a k\u00f6vetkez\u0151 n\u00e9vt\u00e9r deklar\u00e1ci\u00f3t is: <code>xmlns:model=\"using:HelloXaml.Models\"</code> (ezt k\u00f6vet\u0151en a <code>model</code> prefix haszn\u00e1lhat\u00f3 lesz). Ezt megtehetj\u00fck k\u00e9zzel, vagy a Visual Studio seg\u00edts\u00e9g\u00e9vel is: csak kattintsunk bele az al\u00e1h\u00fazott (hib\u00e1snak megjel\u00f6lt) <code>model:Person</code>sz\u00f6vegbe, majd kattintsuk a sor elej\u00e9n megjelen\u0151 l\u00e1mp\u00e1csk\u00e1n (vagy <code>Ctrl</code> + <code>.</code> billenty\u0171kombin\u00e1ci\u00f3), \u00e9s v\u00e1lasszuk ki a megjelen\u0151 \"Add xmlns using:HelloXaml.Models\" elemet.</p> <p>Pr\u00f3b\u00e1ljuk ki! Most m\u00e1r j\u00f3l jelennek meg a list\u00e1ban az elemek.</p> <p>Az Add gomb hat\u00e1s\u00e1ra rakjuk bele a list\u00e1ba az \u0171rlapon tal\u00e1lhat\u00f3 szem\u00e9ly adataival egy \u00faj <code>Person</code> m\u00e1solat\u00e1t, majd t\u00f6r\u00f6lj\u00fck ki az \u0171rlap adatait a <code>NewPerson</code> objektumunkban.</p> <p>Ehhez vezess\u00fcnk be egy <code>Click</code> esem\u00e9nykezel\u0151t az Add gombunkra:</p> <pre><code>&lt;Button ... Click=\"AddButton_Click\"&gt;\n</code></pre> <pre><code>private void AddButton_Click(object sender, RoutedEventArgs e)\n{\n    People.Add(new Person()\n    { \n        Name = NewPerson.Name,\n        Age = NewPerson.Age,\n    });\n\n    NewPerson.Name = string.Empty;\n    NewPerson.Age = 0;\n}\n</code></pre> <p>Nem jelenik meg a list\u00e1ban az \u00faj elem, mert a <code>ListView</code> nem \u00e9rtes\u00fcl arr\u00f3l, hogy \u00faj elem ker\u00fclt a list\u00e1ba. Ezt k\u00f6nnyen orvosolhatjuk: a <code>List&lt;Persont&gt;</code>-t cser\u00e9lj\u00fck le <code>ObservableCollection&lt;Person&gt;</code>-re:</p> <pre><code>public ObservableCollection&lt;Person&gt; People { get; set; }\n</code></pre> <p><code>ObservableCollection&lt;T&gt;</code></p> <p>Fontos, hogy itt nem maga a <code>People</code> tulajdons\u00e1g \u00e9rt\u00e9ke v\u00e1ltozott, hanem a <code>List&lt;Person&gt;</code> objektum tartalma, ez\u00e9rt nem az <code>INotifyPropertyChanged</code> interf\u00e9sz a megold\u00e1s, hanem az <code>INotifyCollectionChanged</code> interf\u00e9sz, melyet az <code>ObservableCollection</code> implement\u00e1l.</p> <p>Teh\u00e1t m\u00e1r k\u00e9t v\u00e1ltoz\u00e1skezel\u00e9st t\u00e1mogat\u00f3 interf\u00e9szt ismer\u00fcnk \u00e9s haszn\u00e1lunk, melyek az adatk\u00f6t\u00e9st t\u00e1mogatj\u00e1k: <code>INotifyPropertyChanged</code> \u00e9s <code>INotifyCollectionChanged</code>.</p>"},{"location":"labor/3-felhasznaloi-felulet/#kitekintes-klasszikus-binding","title":"Kitekint\u00e9s: Klasszikus Binding","text":"<p>Az adatk\u00f6t\u00e9snek a klasszikus form\u00e1j\u00e1t a <code>Binding</code> markup extension jelenti.</p> <p>A legfontosabb k\u00fcl\u00f6nbs\u00e9gek az <code>x:Bind</code>-hoz k\u00e9pest:</p> <ul> <li>A <code>Binding</code> alap\u00e9rtelmezett m\u00f3dja a <code>OneWay</code> \u00e9s nem a <code>OneTime</code>: teh\u00e1t figyeli a v\u00e1ltoz\u00e1sokat alap\u00e9rtelmezetten, m\u00edg az <code>x:Bind</code>-n\u00e9l ezt explicit meg kell adni.</li> <li>A <code>Binding</code> alap\u00e9rtelmezetten a <code>DataContext</code>-b\u0151l dolgozik, de lehet\u0151s\u00e9g van \u00e1ll\u00edtani az adatk\u00f6t\u00e9s forr\u00e1s\u00e1t. M\u00edg az <code>x:Bind</code> alap\u00e9rtelmezetten a n\u00e9zet\u00fcnk oszt\u00e1ly\u00e1b\u00f3l (xaml.cs) k\u00f6t.</li> <li>A <code>Binding</code> fut\u00e1sid\u0151ben dolgozik reflection seg\u00edts\u00e9g\u00e9vel, \u00edgy egyr\u00e9szt nem kapunk ford\u00edt\u00e1s idej\u0171 hib\u00e1kat, ha valamit el\u00edrtunk volna, m\u00e1sr\u00e9szt pedig sok adatk\u00f6t\u00e9s (1000-es nagys\u00e1grend) jelent\u00e9sen lass\u00edthatja az alkalmaz\u00e1sunkat.</li> <li>Az <code>x:Bind</code> ford\u00edt\u00e1s idej\u0171, \u00edgy a ford\u00edt\u00f3 ellen\u0151rzi, hogy a megadott tulajdons\u00e1gok l\u00e9teznek-e. Adatsablonokban nyilatkozni kell a <code>DataTemplate</code> megad\u00e1sa sor\u00e1n, hogy az milyen adatokon fog dolgozni az <code>x:DataType</code> attrib\u00fatummal.</li> <li>Az <code>x:Bind</code> eset\u00e9ben lehet\u0151s\u00e9g van met\u00f3dusokat is k\u00f6tni, m\u00edg a <code>Binding</code>-n\u00e9l csak konvertereket lehet haszn\u00e1lni. F\u00fcggv\u00e9nyek k\u00f6t\u00e9se eset\u00e9n a v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9s a param\u00e9terek v\u00e1ltoz\u00e1s\u00e1ra is m\u0171k\u00f6dik.</li> </ul> <p>Aj\u00e1nl\u00e1s</p> <p>\u00d6k\u00f6lszab\u00e1lyk\u00e9nt elmondhat\u00f3, hogy pr\u00f3b\u00e1ljunk prefer\u00e1ltan <code>x:Bind</code>-ot haszn\u00e1lni, mert gyorsabb, \u00e9s ford\u00edt\u00e1s idej\u0171 hib\u00e1kat kapunk, viszont ha valami\u00e9rt probl\u00e9m\u00e1ba \u00fctk\u00f6zn\u00e9nk az <code>x:Bind</code>-dal, akkor <code>Binding</code>-ra \u00e9rdemes \u00e1tt\u00e9rni.</p>"},{"location":"labor/4-tobbszalu/","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se","text":""},{"location":"labor/4-tobbszalu/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt):</p> <ul> <li>Sz\u00e1lak ind\u00edt\u00e1sa (<code>Thread</code>)</li> <li>Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa</li> <li>Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a <code>lock</code> kulcssz\u00f3 alkalmaz\u00e1s\u00e1val</li> <li><code>ThreadPool</code> haszn\u00e1lata</li> <li>Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel (<code>WaitHandle</code>)</li> <li>WinUI sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok (<code>DispatcherQueue</code>)</li> </ul> <p>Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban.</p> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se.</p>"},{"location":"labor/4-tobbszalu/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022<ul> <li>Windows Desktop Development Workload</li> </ul> </li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/4-tobbszalu/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre a <code>megoldas</code> \u00e1gat:</p> <p><code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/4-tobbszalu/#bevezeto","title":"Bevezet\u0151","text":"<p>A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet minden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck.</p> <p>A feladat sor\u00e1n egyszer\u0171 WinUI alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.</p>"},{"location":"labor/4-tobbszalu/#0-feladat-ismerkedes-a-kiindulo-alkalmazassal-elokeszites","title":"0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Kl\u00f3nozzuk le a 4. gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo.git</code></li> <li>Nyissuk meg a SuperCalculator.sln solutiont Visual Studio-ban.</li> </ul> <p>A feladatunk az, hogy egy bin\u00e1ris form\u00e1ban megkapott algoritmus futtat\u00e1s\u00e1hoz WinUI technol\u00f3gi\u00e1val felhaszn\u00e1l\u00f3i fel\u00fcletet k\u00e9sz\u00edts\u00fcnk. A bin\u00e1ris forma .NET eset\u00e9ben egy .dll kiterjeszt\u00e9s\u0171 f\u00e1jlt jelent, ami programoz\u00f3i szemmel egy oszt\u00e1lyk\u00f6nyvt\u00e1r.  A f\u00e1jl neve eset\u00fcnkben Algorithms.dll, megtal\u00e1lhat\u00f3 a lekl\u00f3nozott Git repositoryban.</p> <p>A kiindul\u00f3 alkalmaz\u00e1sban a felhaszn\u00e1l\u00f3i fel\u00fclet el\u0151 is van k\u00e9sz\u00edtve. Futtassuk az alkalmaz\u00e1st:</p> <p></p> <p>Az alkalmaz\u00e1s fel\u00fclet\u00e9n meg tudjuk adni az algoritmus bemen\u0151 param\u00e9tereit (<code>double</code> sz\u00e1mok t\u00f6mbje): a p\u00e9ld\u00e1nkban mindig k\u00e9t <code>double</code> sz\u00e1m param\u00e9terrel h\u00edvjuk az algoritmust, ezt a k\u00e9t fels\u0151 sz\u00f6vegmez\u0151ben lehet megadni. A feladatunk az, hogy a Calculate Result gombra kattint\u00e1s sor\u00e1n futtassuk az algoritmust a megadott param\u00e9terekkel, majd, ha v\u00e9gzett, akkor a Result alatti list\u00e1z\u00f3 mez\u0151 \u00faj sor\u00e1ban jelen\u00edts\u00fck meg a kapott eredm\u00e9nyt a bemen\u0151 param\u00e9terekkel egy\u00fctt.</p> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben ismerkedj\u00fcnk meg a let\u00f6lt\u00f6tt Visual Studio solutionnel:</p> <p>A keretalkalmaz\u00e1s egy WinUI 3 alap\u00fa alkalmaz\u00e1s. A fel\u00fclet alapvet\u0151en k\u00e9sz, defin\u00edci\u00f3ja a <code>MainWindow.xaml</code> f\u00e1jlban tal\u00e1lhat\u00f3. Ez sz\u00e1munkra a gyakorlat c\u00e9lj\u00e1t tekintve kev\u00e9sb\u00e9 izgalmas, de otthon a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9rdemes \u00e1ttekinteni.</p> Fel\u00fclet kialak\u00edt\u00e1sa a <code>MainWindow.xaml</code>-ben <p>Az ablakfel\u00fclet kialak\u00edt\u00e1s\u00e1nak alapjai:</p> <ul> <li>A gy\u00f6k\u00e9relem (root) \"szok\u00e1sosan\" egy <code>Grid</code>. </li> <li>A gy\u00f6k\u00e9r <code>Grid</code>  fels\u0151 sor\u00e1ban tal\u00e1lhat\u00f3 a k\u00e9t <code>TextBox</code>-ot \u00e9s a <code>Button</code>-t tartalmaz\u00f3 <code>StackPanel</code>.</li> <li>A gy\u00f6k\u00e9r <code>Grid</code> als\u00f3 sor\u00e1ban egy m\u00e1sik <code>Grid</code> tal\u00e1lhat\u00f3. A <code>TextBox</code>-szal ellent\u00e9tben a <code>ListBox</code> nem rendelkezik <code>Header</code> tulajdons\u00e1ggal, \u00edgy ezt nek\u00fcnk kellett egy k\u00fcl\u00f6n\u00e1ll\u00f3 \"Result\" sz\u00f6veg\u0171 <code>TextBlock</code> form\u00e1j\u00e1ban bevezetni. Ezt a <code>Grid</code>-et az\u00e9rt vezett\u00fck be (egy \"egyszer\u0171bb\" <code>StackPanel</code> helyett), mert \u00edgy lehetett el\u00e9rni, hogy a fels\u0151 sor\u00e1ban a \"Result\" <code>TextBlock</code> fix magass\u00e1g\u00fa legyen, az als\u00f3 sorban pedig a <code>ListBox</code> t\u00f6ltse ki a teljes marad\u00f3 helyet (a fels\u0151 sor magass\u00e1ga <code>Auto</code>, az als\u00f3 sor magass\u00e1ga <code>*</code>).</li> <li>A \"Calculate Result\" sz\u00f6veg\u0171 gomb sz\u00e9p p\u00e9lda arra, hogy a <code>Button</code> <code>Content</code>-j\u00e9nek sokszor nemcsak egy egyszer\u0171 sz\u00f6veget adunk meg. A p\u00e9ld\u00e1ban egy <code>SymbolIcon</code> \u00e9s a <code>TextBlock</code> kompoz\u00edci\u00f3ja (<code>StackPanel</code> seg\u00edts\u00e9g\u00e9vel megval\u00f3s\u00edtva), ez\u00e1ltal tudjunk a egy megfelel\u0151 ikont/szimb\u00f3lumot rendelni, mely feldobja a megjelen\u00e9s\u00e9t.</li> <li>Arra is l\u00e1tunk p\u00e9ld\u00e1t, hogy a <code>ListBox</code> hogyan tehet\u0151 g\u00f6rgethet\u0151v\u00e9, ha m\u00e1r sok elem van benne (vagy t\u00fal sz\u00e9lesek az elemek). Ehhez a <code>ScrollViewer</code>-\u00e9t kell megfelel\u0151en param\u00e9terezni.</li> <li>A <code>ListBox</code> <code>ItemContainerStyle</code> tulajdons\u00e1g\u00e1val a <code>ListBox</code> elemre adhatunk meg st\u00edlusokat. A p\u00e9ld\u00e1ban a <code>Padding</code>-et vett\u00fck kisebbre az alap\u00e9rtelmezettn\u00e9l, en\u00e9lk\u00fcl a <code>ListBox</code> elemek magass\u00e1ga helypazarl\u00f3an nagy lenne.</li> </ul> <p>A <code>MainWindow.xaml.cs</code> forr\u00e1sf\u00e1jl a f\u0151ablakhoz tartoz\u00f3 code behind f\u00e1jl, ezt tekints\u00fck \u00e1t, f\u0151bb elemei a k\u00f6vetkez\u0151k:</p> <ul> <li>Az eredm\u00e9ny \u00e9s a param\u00e9terek <code>ListBox</code>-ba t\u00f6rt\u00e9n\u0151 napl\u00f3z\u00e1s\u00e1hoz tal\u00e1lunk egy <code>ShowResult</code> nev\u0171 seg\u00e9df\u00fcggv\u00e9nyt.</li> <li>A <code>CalculateResultButton_Click</code> a gomb a Calculate Result gomb kattint\u00e1s\u00e1hoz tartoz\u00f3 esem\u00e9nykezel\u0151. Azt l\u00e1tjuk, hogy a k\u00e9t sz\u00f6vegdobozb\u00f3l kiolvassa a param\u00e9terek \u00e9rt\u00e9k\u00e9t, \u00e9s megpr\u00f3b\u00e1lja sz\u00e1mm\u00e1 alak\u00edtani. Ha siker\u00fcl, akkor itt t\u00f6rt\u00e9nik majd az algoritmus h\u00edv\u00e1sa (ez nincs m\u00e9g megval\u00f3s\u00edtva), illetve, ha nem siker\u00fcl, akkor a <code>DisplayInvalidElementDialog</code> seg\u00edts\u00e9g\u00e9vel egy \u00fczenetablakban t\u00e1j\u00e9koztatja a felhaszn\u00e1l\u00f3t az \u00e9rv\u00e9nytelen param\u00e9terekr\u0151l.</li> <li>A konstruktorb\u00f3l h\u00edvott <code>AddKeyboardAcceleratorToChangeTheme</code> f\u00fcggv\u00e9ny sz\u00e1munkra nem relev\u00e1ns, a vil\u00e1gos \u00e9s s\u00f6t\u00e9t t\u00e9ma k\u00f6z\u00f6tti v\u00e1lt\u00e1st teszi lehet\u0151v\u00e9 (fut\u00e1s k\u00f6zben \u00e9rdemes kipr\u00f3b\u00e1lni, Ctrl+T billenty\u0171kombin\u00e1ci\u00f3).</li> </ul>"},{"location":"labor/4-tobbszalu/#a-dll-ben-levo-kod-felhasznalasa","title":"A DLL-ben lev\u0151 k\u00f3d felhaszn\u00e1l\u00e1sa","text":"<p>A kiindul\u00f3 projektben megtal\u00e1ljuk a Algorithm.dll-t. Ebben leford\u00edtott form\u00e1ban egy <code>Algorithms</code> n\u00e9vt\u00e9rben lev\u0151 <code>SuperAlgorithm</code> nev\u0171 oszt\u00e1ly tal\u00e1lhat\u00f3, melynek egy <code>Calculate</code> nev\u0171 statikus m\u0171velete van. Ahhoz, hogy egy projektben fel tudjuk haszn\u00e1lni a DLL-ben lev\u0151 oszt\u00e1lyokat, a DLL-re a projekt\u00fcnkben egy \u00fan. referenci\u00e1t kell felvegy\u00fcnk.</p> <ol> <li> <p>Solution Explorerben a projekt\u00fcnk Dependencies node-j\u00e1ra jobbklikkelve v\u00e1lasszuk az Add Project reference opci\u00f3t!</p> <p></p> <p>K\u00fcls\u0151 referenci\u00e1k</p> <p>Itt val\u00f3j\u00e1ban nem egy m\u00e1sik Visual Studio projektre adunk referenci\u00e1t, de \u00edgy a legegyszer\u0171bb el\u0151hozni ezt az ablakot.</p> <p>Megeml\u00edtend\u0151 m\u00e9g, hogy k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rak eset\u00e9ben m\u00e1r nem DLL-eket szoktunk refer\u00e1lni egy rendes projektben, hanem a .NET csomagkezel\u0151 rendeszer\u00e9b\u0151l a NuGet-r\u0151l szok\u00e1s a k\u00fcls\u0151 csomagokat beszerezni. Most az Algorithm.dll eset\u00fcnkben nincs NuGet-en publik\u00e1lva, ez\u00e9rt kell k\u00e9zzel felvegy\u00fck azt.</p> </li> <li> <p>Az el\u0151ugr\u00f3 ablak jobb als\u00f3 sarokban tal\u00e1lhat\u00f3 Browse gomb seg\u00edts\u00e9g\u00e9vel keress\u00fck meg \u00e9s v\u00e1lasszuk ki projekt External almapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 Algorithms.dll f\u00e1jlt, majd hagyjuk j\u00f3v\u00e1 a hozz\u00e1ad\u00e1st az OK gombbal!</p> </li> </ol> <p>A Solution Explorerben egy projekt alatti Dependencies csom\u00f3pontot lenyitva l\u00e1thatjuk a hivatkozott k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket. Itt most m\u00e1r megjelenik az Assemblyk k\u00f6z\u00f6tt el\u0151bb felvett Algorithms referencia is. A Frameworks kateg\u00f3ri\u00e1ban a .NET keretrendszer csomagjait tal\u00e1ljuk. Az Analyzerek pedig statikus k\u00f3delemz\u0151 eszk\u00f6z\u00f6k ford\u00edt\u00e1s id\u0151ben. Illetve itt lenn\u00e9nek m\u00e9g a projekt vagy a NuGet referenci\u00e1k is.</p> <p></p> <p>Kattintsunk Algorithms referenci\u00e1n jobb gombbal \u00e9s v\u00e1lasszuk a View in Object Browser funkci\u00f3t. Ekkor megny\u00edlik az Object Browser tabf\u00fcl, ahol megtekinthetj\u00fck, hogy az adott DLL-ben milyen n\u00e9vterek, oszt\u00e1lyok tal\u00e1lhat\u00f3k, illetve ezeknek milyen tagjaik (tagv\u00e1ltoz\u00f3, tagf\u00fcggv\u00e9ny, property, event) vannak. Ezeket a Visual Studio a DLL metaadataib\u00f3l az \u00fan. reflection mechanizmus seg\u00edts\u00e9g\u00e9vel olvassa ki (ilyen k\u00f3dot ak\u00e1r mi is \u00edrhatunk).</p> <p>Az al\u00e1bbi \u00e1br\u00e1nak megfelel\u0151en az Object Browserben baloldalt keress\u00fck ki az Algorithms csom\u00f3pontot, nyissuk le, \u00e9s l\u00e1that\u00f3v\u00e1 v\u00e1lik, hogy egy <code>Algorithms</code> n\u00e9vt\u00e9r van benne, abban pedig egy <code>SuperAlgorithm</code> oszt\u00e1ly. Ezt kiv\u00e1lasztva k\u00f6z\u00e9pen megjelennek az oszt\u00e1ly f\u00fcggv\u00e9nyei, itt egy f\u00fcggv\u00e9nyt kiv\u00e1lasztva pedig az adott f\u00fcggv\u00e9ny pontos szignat\u00far\u00e1ja:</p> <p></p>"},{"location":"labor/4-tobbszalu/#1-feladat-muvelet-futtatasa-a-foszalon","title":"1. Feladat \u2013 M\u0171velet futtat\u00e1sa a f\u0151sz\u00e1lon","text":"<p>Most m\u00e1r r\u00e1t\u00e9rhet\u00fcnk az algoritmus futtat\u00e1s\u00e1ra. Els\u0151 l\u00e9p\u00e9sben ezt az alkalmaz\u00e1sunk f\u0151 sz\u00e1l\u00e1n tessz\u00fck meg.</p> <ol> <li> <p>A f\u0151ablakon l\u00e9v\u0151 gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben h\u00edvjuk meg a sz\u00e1mol\u00f3 f\u00fcggv\u00e9ny\u00fcnket. Ehhez a Solution Explorerben nyissuk meg a <code>MainWindow.xaml.cs</code> code behind f\u00e1jlt, \u00e9s keress\u00fck meg a <code>CalculateResultButton_Click</code> esem\u00e9nykezel\u0151t. Eg\u00e9sz\u00edts\u00fck ki a k\u00f3dot az \u00fajonnan behivatkozott algoritmus megh\u00edv\u00e1s\u00e1val.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n        ShowResult(parameters, result);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az ablak a sz\u00e1mol\u00e1s ideje alatt nem reag\u00e1l a mozgat\u00e1sra, \u00e1tm\u00e9retez\u00e9sre, a fel\u00fclet gyakorlatilag befagy.</p> </li> </ol> <p>Az alkalmaz\u00e1sunk esem\u00e9nyvez\u00e9relt, mint minden Windows alkalmaz\u00e1s. Az oper\u00e1ci\u00f3s rendszer a k\u00fcl\u00f6nb\u00f6z\u0151 interakci\u00f3kr\u00f3l (pl. mozgat\u00e1s, \u00e1tm\u00e9retez\u00e9s, eg\u00e9rkattint\u00e1s) \u00e9rtes\u00edti az alkalmaz\u00e1sunkat: mivel a gombnyom\u00e1st k\u00f6vet\u0151en az alkalmaz\u00e1sunk egyetlen sz\u00e1la a kalkul\u00e1ci\u00f3val van elfoglalva, nem tudja azonnal feldolgozni a tov\u00e1bbi felhaszn\u00e1l\u00f3i utas\u00edt\u00e1sokat. Amint a sz\u00e1m\u00edt\u00e1s lefutott (\u00e9s az eredm\u00e9nyek megjelennek a list\u00e1ban) a kor\u00e1bban kapott parancsok is v\u00e9grehajt\u00e1sra ker\u00fclnek.</p>"},{"location":"labor/4-tobbszalu/#2-feladat-vegezzuk-a-szamitast-kulon-szalban","title":"2. Feladat \u2013 V\u00e9gezz\u00fck a sz\u00e1m\u00edt\u00e1st k\u00fcl\u00f6n sz\u00e1lban","text":"<p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a sz\u00e1m\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9re egy k\u00fcl\u00f6n sz\u00e1lat fogunk ind\u00edtani, hogy az ne blokkolja a felhaszn\u00e1l\u00f3i fel\u00fcletet.</p> <ol> <li> <p>K\u00e9sz\u00edts\u00fcnk egy \u00faj f\u00fcggv\u00e9nyt a <code>MainWindow</code> oszt\u00e1lyban, mely a feldolgoz\u00f3 sz\u00e1l bel\u00e9p\u00e9si pontja lesz.</p> <pre><code>private void CalculatorThread(object arg)\n{\n    var parameters = (double[])arg;\n    var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n    ShowResult(parameters, result);\n}\n</code></pre> </li> <li> <p>Ind\u00edtsuk el a sz\u00e1lat a gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben. Ehhez cser\u00e9lj\u00fck le a kor\u00e1bban hozz\u00e1adott k\u00f3dot:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var th = new Thread(CalculatorThread);\n        th.Start(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>A Thread objektum <code>Start</code> m\u0171velet\u00e9ben \u00e1tadott param\u00e9tert kapja meg a <code>CalculatorThread</code> sz\u00e1lf\u00fcggv\u00e9ny\u00fcnk.</p> </li> <li> <p>Futtassuk az alkalmaz\u00e1st F5-tel (most fontos, hogy \u00edgy, a debuggerben futtassuk)! The application called an interface that was marshalled for a different thread. (0x8001010E (RPC_E_WRONG_THREAD)) hiba\u00fczenetet kapunk a <code>ShowResult</code> met\u00f3dusban, ugyanis nem abb\u00f3l a sz\u00e1lb\u00f3l pr\u00f3b\u00e1lunk hozz\u00e1f\u00e9rni a UI elemhez / vez\u00e9rl\u0151h\u00f6z, amelyik l\u00e9trehozta (a vez\u00e9rl\u0151t). A k\u00f6vetkez\u0151 feladatban ezt a probl\u00e9m\u00e1t analiz\u00e1ljuk \u00e9s oldjuk meg.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#3-feladat-a-dispatcherqueuehasthreadaccess-es-dispatcherqueuetryenqueue-hasznalata","title":"3. Feladat \u2013 a <code>DispatcherQueue.HasThreadAccess</code> \u00e9s <code>DispatcherQueue.TryEnqueue</code> haszn\u00e1lata","text":"<p>Az el\u0151z\u0151 pontban a probl\u00e9m\u00e1t a k\u00f6vetkez\u0151 okozza. WinUI alkalmaz\u00e1sokn\u00e1l \u00e9l az al\u00e1bbi szab\u00e1ly: az ablakok/fel\u00fcletelemek/vez\u00e9rl\u0151elemek alapvet\u0151en nem sz\u00e1lv\u00e9dett (thread safe) objektumok, \u00edgy egy ablakhoz/fel\u00fcletelemhez/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l szabad hozz\u00e1f\u00e9rni (pl. propertyj\u00e9t olvasni, \u00e1ll\u00edtani, m\u0171velet\u00e9t megh\u00edvni), amelyik sz\u00e1l az adott ablakot/fel\u00fcletelemet/vez\u00e9rl\u0151t l\u00e9trehozta, m\u00e1sk\u00fcl\u00f6nben kiv\u00e9telt kapunk. Alkalmaz\u00e1sunkban az\u00e9rt kaptunk kiv\u00e9telt, mert a <code>resultListBox</code> vez\u00e9rl\u0151t a f\u0151 sz\u00e1lban hoztuk l\u00e9tre, a <code>ShowResult</code> met\u00f3dusban az eredm\u00e9ny megjelen\u00edt\u00e9sekor viszont egy m\u00e1sik sz\u00e1lb\u00f3l f\u00e9r\u00fcnk hozz\u00e1 (<code>resultListBox.Items.Add</code> m\u0171velet h\u00edv\u00e1sa).</p> <p>K\u00e9rd\u00e9s, hogyan lehet m\u00e9gis valamilyen m\u00f3don ezekhez a fel\u00fcletelemekhez/vez\u00e9rl\u0151kh\u00f6z egy m\u00e1sik sz\u00e1lb\u00f3l hozz\u00e1f\u00e9rni. A megold\u00e1st a <code>DispatcherQueue</code> alkalmaz\u00e1sa jelenti, mely abban ny\u00fajt seg\u00edts\u00e9get, hogy a vez\u00e9rl\u0151kh\u00f6z mindig a megfelel\u0151 sz\u00e1lb\u00f3l t\u00f6rt\u00e9njen a hozz\u00e1f\u00e9r\u00e9s:</p> <ul> <li><code>DispatcherQueue</code> objektum <code>TryEnqueue</code> f\u00fcggv\u00e9nye a vez\u00e9rl\u0151elemet l\u00e9trehoz\u00f3 sz\u00e1lon futtatja le a sz\u00e1m\u00e1ra param\u00e9terk\u00e9nt megadott f\u00fcggv\u00e9nyt (mely f\u00fcggv\u00e9nyb\u0151l \u00edgy m\u00e1r k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk a vez\u00e9rl\u0151h\u00f6z).</li> <li>A <code>DispatcherQueue</code> objektum <code>HasThreadAccess</code> tulajdons\u00e1ga azt seg\u00edt eld\u00f6nteni, sz\u00fcks\u00e9g van-e egy\u00e1ltal\u00e1n az el\u0151z\u0151 pontban eml\u00edtett <code>TryEnqueue</code> alkalmaz\u00e1s\u00e1ra. Ha a tulajdons\u00e1g \u00e9rt\u00e9ke<ul> <li>igaz, akkor a vez\u00e9rl\u0151h\u00f6z k\u00f6zvetlen\u00fcl is hozz\u00e1f\u00e9rhet\u00fcnk (mert az aktu\u00e1lis sz\u00e1l megegyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal), ellenben ha</li> <li>hamis, akkor a vez\u00e9rl\u0151h\u00f6z csak \"ker\u00fcl\u0151 \u00faton\", a <code>DispatcherQueue</code> objektum <code>TryEnqueue</code> seg\u00edts\u00e9g\u00e9vel f\u00e9rhet\u00fcnk hozz\u00e1 (mert az aktu\u00e1lis sz\u00e1l NEM egyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal).</li> </ul> </li> </ul> <p>A <code>DispatcherQueue</code> seg\u00edts\u00e9g\u00e9vel teh\u00e1t el tudjuk ker\u00fclni kor\u00e1bbi kiv\u00e9tel\u00fcnket (a vez\u00e9rl\u0151h\u00f6z, eset\u00fcnkben a <code>resultListBox</code>-hoz val\u00f3 hozz\u00e1f\u00e9r\u00e9st a megfelel\u0151 sz\u00e1lra tudjuk \"ir\u00e1ny\u00edtani\"). Ezt fogjuk a k\u00f6vetkez\u0151kben megtenni.</p> <p>Note</p> <p>A <code>DispatcherQueue</code> objektum a Window oszt\u00e1ly lesz\u00e1rmazottakban \u00e9rhet\u0151 el a<code>DispatcherQueue</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl (m\u00e1s oszt\u00e1lyokban pedig a <code>DispatcherQueue.GetForCurrentThread()</code> statikus m\u0171velet seg\u00edts\u00e9g\u00e9vel szerezhet\u0151 meg).</p> <p>M\u00f3dos\u00edtanunk kell a <code>ShowResult</code> met\u00f3dust annak \u00e9rdek\u00e9ben, hogy mell\u00e9ksz\u00e1lb\u00f3l t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1s eset\u00e9n se dobjon kiv\u00e9telt.</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    // Closing the window the DispatcherQueue property may return null, so we have to perform a null check\n    if (this.DispatcherQueue == null)\n        return;\n\n    if (this.DispatcherQueue.HasThreadAccess)\n    {\n        var item = new ListBoxItem()\n        {\n            Content = $\"{parameters[0]} #  {parameters[1]} = {result}\"\n        };\n        resultListBox.Items.Add(item);\n        resultListBox.ScrollIntoView(item);\n    }\n    else\n    {\n        this.DispatcherQueue.TryEnqueue( () =&gt; ShowResult(parameters, result) );\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>Ez a megold\u00e1s m\u00e1r m\u0171k\u00f6d\u0151k\u00e9pes, f\u0151bb elemei a k\u00f6vetkez\u0151k:</p> <ul> <li>A <code>DispatcherQueue</code> <code>null</code> vizsg\u00e1lat szerepe: a f\u0151ablak bez\u00e1r\u00e1sa ut\u00e1n a <code>DispatcherQueue</code> m\u00e1r <code>null</code>, nem haszn\u00e1lhat\u00f3.</li> <li>A <code>DispatcherQueue.HasThreadAccess</code> seg\u00edts\u00e9g\u00e9vel megn\u00e9zz\u00fck, hogy a h\u00edv\u00f3 sz\u00e1l hozz\u00e1f\u00e9rhet-e k\u00f6zvetlen\u00fcl a vez\u00e9rl\u0151kh\u00f6z (eset\u00fcnkben a <code>ListBox</code>-hoz):<ul> <li>Ha igen, minden \u00fagy t\u00f6rt\u00e9nik, mint eddig, a <code>ListBox</code>-ot kezel\u0151 k\u00f3d v\u00e1ltozatlan.</li> <li>Ha nem, a <code>DispatcherQueue.TryEnqueue</code> seg\u00edts\u00e9g\u00e9vel f\u00e9r\u00fcnk hozz\u00e1 a vez\u00e9rl\u0151h\u00f6z. A k\u00f6vetkez\u0151 tr\u00fckk\u00f6t alkalmazzuk. A <code>TryEnqueue</code> f\u00fcggv\u00e9nynek egy olyan param\u00e9ter n\u00e9lk\u00fcli, egysoros f\u00fcggv\u00e9nyt adunk meg lambda kifejez\u00e9s form\u00e1j\u00e1ban, mellyel a <code>ShowResult</code> f\u00fcggv\u00e9ny\u00fcnket h\u00edvja meg (gyakorlatilag rekurz\u00edvan), a param\u00e9tereket tov\u00e1bb passzolva sz\u00e1m\u00e1ra. Ez nek\u00fcnk az\u00e9rt j\u00f3, mert ez a <code>ShowResult</code> h\u00edv\u00e1s m\u00e1r azon a sz\u00e1lon t\u00f6rt\u00e9nik, mely a vez\u00e9rl\u0151t l\u00e9trehozta (az alkalmaz\u00e1s f\u0151 sz\u00e1la), ebben a <code>HasThreadAccess</code> \u00e9rt\u00e9ke m\u00e1r igaz, \u00e9s hozz\u00e1 tudunk f\u00e9rni k\u00f6zvetlen\u00fcl a <code>ListBox</code>-unkhoz. Ez a rekurz\u00edv megk\u00f6zel\u00edt\u00e9s egy bevett minta a redund\u00e1ns k\u00f3dok elker\u00fcl\u00e9s\u00e9re.</li> </ul> </li> </ul> <p>Tegy\u00fcnk t\u00f6r\u00e9spontot a <code>ShowResult</code> m\u0171velet els\u0151 sor\u00e1ra, \u00e9s az alkalmaz\u00e1st futtatva gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy a <code>ShowResult</code> m\u0171velet els\u0151 h\u00edv\u00e1sakor <code>HasThreadAccess</code> m\u00e9g hamis (\u00edgy megt\u00f6rt\u00e9nik a <code>TryEnqueue</code> h\u00edv\u00e1sa), majd ennek hat\u00e1s\u00e1ra m\u00e9g egyszer megh\u00edv\u00f3dik a <code>ShowResult</code>, de ekkor a <code>HasThreadAccess</code> \u00e9rt\u00e9ke m\u00e1r igaz.</p> <p>Vegy\u00fck ki a t\u00f6r\u00e9spontot, \u00edgy futtassuk az alkalmaz\u00e1st: vegy\u00fck \u00e9szre, hogy am\u00edg egy sz\u00e1m\u00edt\u00e1s fut, \u00fajabbakat is ind\u00edthatunk, hiszen a fel\u00fclet\u00fcnk v\u00e9gig reszponz\u00edv maradt (a kor\u00e1bban tapasztalt hiba pedig m\u00e1r nem jelentkezik).</p>"},{"location":"labor/4-tobbszalu/#4-feladat-muvelet-vegzese-threadpool-szalon","title":"4. feladat \u2013 M\u0171velet v\u00e9gz\u00e9se Threadpool sz\u00e1lon","text":"<p>Az el\u0151z\u0151 megold\u00e1s egy jellemz\u0151je, hogy mindig \u00faj sz\u00e1lat hoz l\u00e9tre a m\u0171velethez. Eset\u00fcnkben ennek nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge, de ez a megk\u00f6zel\u00edt\u00e9s egy olyan kiszolg\u00e1l\u00f3 alkalmaz\u00e1s eset\u00e9ben, amely nagysz\u00e1m\u00fa k\u00e9r\u00e9st szolg\u00e1l ki \u00fagy, hogy minden k\u00e9r\u00e9shez k\u00fcl\u00f6n sz\u00e1lat ind\u00edt, m\u00e1r probl\u00e9m\u00e1s lehet. K\u00e9t okb\u00f3l is:</p> <ul> <li>Ha a sz\u00e1lf\u00fcggv\u00e9ny gyorsan lefut (egy kliens kiszolg\u00e1l\u00e1sa gyors), akkor a CPU nagy r\u00e9sz\u00e9t arra pazaroljuk, hogy sz\u00e1lakat ind\u00edtsunk \u00e9s \u00e1ll\u00edtsunk le, ezek ugyanis \u00f6nmagukban is er\u0151forr\u00e1sig\u00e9nyesek.</li> <li>T\u00fal nagy sz\u00e1m\u00fa sz\u00e1l is l\u00e9trej\u00f6het, ennyit kell \u00fctemeznie az oper\u00e1ci\u00f3s rendszernek, ami feleslegesen pazarolja az er\u0151forr\u00e1sokat.</li> </ul> <p>Egy m\u00e1sik probl\u00e9ma jelen megold\u00e1sunkkal: mivel a sz\u00e1m\u00edt\u00e1s \u00fan. el\u0151t\u00e9rsz\u00e1lon fut (az \u00fajonnan l\u00e9trehozott sz\u00e1lak alap\u00e9rtelmez\u00e9sben el\u0151t\u00e9rsz\u00e1lak), hi\u00e1ba z\u00e1rjuk be az alkalmaz\u00e1st, a program tov\u00e1bb fut a h\u00e1tt\u00e9rben mindaddig, am\u00edg v\u00e9gre nem hajt\u00f3dik az utolj\u00e1ra ind\u00edtott sz\u00e1mol\u00e1s is: egy processz fut\u00e1sa ugyanis akkor fejez\u0151dik csak be, ha m\u00e1r nincs fut\u00f3 el\u0151t\u00e9rsz\u00e1la.</p> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy \u00faj sz\u00e1l ind\u00edt\u00e1sa helyett threadpool sz\u00e1lon futtassa a sz\u00e1m\u00edt\u00e1st. Ehhez csak a gombnyom\u00e1s esem\u00e9nykezel\u0151j\u00e9t kell ism\u00e9t \u00e1t\u00edrni.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        ThreadPool.QueueUserWorkItem(CalculatorThread, parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az alkalmaz\u00e1s az ablak bez\u00e1r\u00e1sakor azonnal le\u00e1ll, nem foglalkozik az esetlegesen m\u00e9g fut\u00f3 sz\u00e1lakkal (mert a threadpool sz\u00e1lak h\u00e1tt\u00e9r sz\u00e1lak).</p>"},{"location":"labor/4-tobbszalu/#5-feladat-termelo-fogyaszto-alapu-megoldas","title":"5. Feladat \u2013 Termel\u0151-fogyaszt\u00f3 alap\u00fa megold\u00e1s","text":"<p>Az el\u0151z\u0151 feladatok megold\u00e1sa sor\u00e1n \u00f6nmag\u00e1ban egy j\u00f3l m\u0171k\u00f6d\u0151 komplett megold\u00e1s\u00e1t kaptuk az eredeti probl\u00e9m\u00e1nak, mely lehet\u0151v\u00e9 teszi, hogy ak\u00e1r t\u00f6bb munkasz\u00e1l is p\u00e1rhuzamosan dolgozzon a h\u00e1tt\u00e9rben a sz\u00e1m\u00edt\u00e1son, ha a gombot sokszor egym\u00e1s ut\u00e1n megnyomjuk. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1sunkat, hogy a gombnyom\u00e1sra ne mindig keletkezzen \u00faj sz\u00e1l, hanem a feladatok beker\u00fcljenek egy feladatsorba, ahonnan t\u00f6bb, a h\u00e1tt\u00e9rben folyamatosan fut\u00f3 sz\u00e1l egym\u00e1s ut\u00e1n fogja kivenni \u0151ket \u00e9s v\u00e9grehajtani. Ez a feladat a klasszikus termel\u0151-fogyaszt\u00f3 probl\u00e9ma, mely a gyakorlatban is sokszor el\u0151fordul, a m\u0171k\u00f6d\u00e9s\u00e9t az al\u00e1bbi \u00e1bra szeml\u00e9lteti.</p> <p></p> <p>Termel\u0151 fogyaszt\u00f3 vs <code>ThreadPool</code></p> <p>Ha belegondolunk, a <code>ThreadPool</code> is egy speci\u00e1lis, a .NET \u00e1ltal sz\u00e1munkra biztos\u00edtott termel\u0151-fogyaszt\u00f3 \u00e9s \u00fctemez\u0151 mechanizmus. A k\u00f6vetkez\u0151kben egy m\u00e1s jelleg\u0171 termel\u0151-fogyaszt\u00f3 megold\u00e1st dolgozunk ki annak \u00e9rdek\u00e9ben, hogy bizonyos sz\u00e1lkezel\u00e9ssel kapcsolatos konkurencia probl\u00e9m\u00e1kkal tal\u00e1lkozhassunk.</p> <p>A f\u0151sz\u00e1lunk a termel\u0151, a Calculate result gombra kattintva hoz l\u00e9tre egy \u00faj feladatot. Fogyaszt\u00f3/feldolgoz\u00f3 munkasz\u00e1lb\u00f3l az\u00e9rt ind\u00edtunk majd t\u00f6bbet, mert \u00edgy t\u00f6bb CPU magot is ki tudunk haszn\u00e1lni, valamint a feladatok v\u00e9grehajt\u00e1s\u00e1t p\u00e1rhuzamos\u00edtani tudjuk.</p> <p>A feladatok ideiglenes t\u00e1rol\u00e1s\u00e1ra a kiindul\u00f3 projekt\u00fcnkben m\u00e1r n\u00e9mik\u00e9ppen el\u0151k\u00e9sz\u00edtett <code>DataFifo</code> oszt\u00e1lyt tudjuk haszn\u00e1lni (a Solution Explorerben a <code>Data</code> mapp\u00e1ban tal\u00e1lhat\u00f3). N\u00e9zz\u00fck meg a forr\u00e1sk\u00f3dj\u00e1t. Egy egyszer\u0171 FIFO sort val\u00f3s\u00edt meg, melyben <code>double[]</code> elemeket t\u00e1rol. A <code>Put</code> met\u00f3dus hozz\u00e1f\u0171zi a bels\u0151 lista v\u00e9g\u00e9hez az \u00faj p\u00e1rokat, m\u00edg a <code>TryGet</code> met\u00f3dus visszaadja (\u00e9s elt\u00e1vol\u00edtja) a bels\u0151 lista els\u0151 elem\u00e9t. Amennyiben a lista \u00fcres, a f\u00fcggv\u00e9ny nem tud visszaadni elemet. Ilyenkor a <code>false</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelzi ezt.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy ne <code>ThreadPool</code>ba dolgozzon, hanem a FIFO-ba:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        _fifo.Put(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>K\u00e9sz\u00edts\u00fck el az \u00faj sz\u00e1lkezel\u0151 f\u00fcggv\u00e9ny na\u00edv implement\u00e1ci\u00f3j\u00e1t az \u0171rlap oszt\u00e1lyunkban:</p> <pre><code>private void WorkerThread()\n{\n    while (true)\n    {\n        if (_fifo.TryGet(out var data))\n        {\n            double result = Algorithms.SuperAlgorithm.Calculate(data);\n            ShowResult(data, result);\n        }\n\n        Thread.Sleep(500);\n    }\n}\n</code></pre> <p>A <code>Thread.Sleep</code> bevezet\u00e9s\u00e9re az\u00e9rt van sz\u00fcks\u00e9g, mert e n\u00e9lk\u00fcl a munkasz\u00e1lak \u00fcres FIFO eset\u00e9n folyamatosan feleslegesen p\u00f6r\u00f6gn\u00e9nek, semmi hasznos m\u0171veletet nem v\u00e9gezve is 100%-ban kiterheln\u00e9nek egy-egy CPU magot. Megold\u00e1sunk nem ide\u00e1lis, k\u00e9s\u0151bb tov\u00e1bbfejlesztj\u00fck.</p> </li> <li> <p>Hozzuk l\u00e9tre, \u00e9s ind\u00edtsuk el a feldolgoz\u00f3 sz\u00e1lakat a konstruktorban:</p> <pre><code>new Thread(WorkerThread) { Name = \"Szal1\" }.Start();\nnew Thread(WorkerThread) { Name = \"Szal2\" }.Start();\nnew Thread(WorkerThread) { Name = \"Szal3\" }.Start();\n</code></pre> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, majd z\u00e1rjuk is be azonnal an\u00e9lk\u00fcl, hogy a Calculate Result gombra kattintan\u00e1nk. Az tapasztaljuk, hogy az ablakunk bez\u00e1r\u00f3dik ugyan, de a processz\u00fcnk tov\u00e1bb fut, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1ra csak a Visual Studiob\u00f3l, vagy a Task Managerb\u0151l van lehet\u0151s\u00e9g:</p> <p></p> <p>A feldolgoz\u00f3 sz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9p\u00e9skor megakad\u00e1lyozz\u00e1k a processz megsz\u0171n\u00e9s\u00e9t. Az egyik megold\u00e1s az lehetne, ha a sz\u00e1lak <code>IsBackground</code> tulajdons\u00e1g\u00e1t <code>true</code>-ra \u00e1ll\u00edtan\u00e1nk a l\u00e9trehoz\u00e1sukat k\u00f6vet\u0151en. A m\u00e1sik megold\u00e1s, hogy kil\u00e9p\u00e9skor gondoskodunk a feldolgoz\u00f3 sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9r\u0151l. Egyel\u0151re tegy\u00fck f\u00e9lre ezt a probl\u00e9m\u00e1t, k\u00e9s\u0151bb visszat\u00e9r\u00fcnk r\u00e1.</p> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st azt tapasztaljuk, hogy miut\u00e1n kattintunk a Calculate Result gombon (csak egyszer kattintsunk rajta) nagy val\u00f3sz\u00edn\u0171s\u00e9ggel kiv\u00e9telt fogunk kapni. A probl\u00e9ma az, hogy a <code>DataFifo</code> nem sz\u00e1lbiztos, inkonzisztens\u00e9 v\u00e1lt. K\u00e9t ered\u0151 ok is h\u00faz\u00f3dik a h\u00e1tt\u00e9rben:</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#problema-1","title":"Probl\u00e9ma 1","text":"<p>N\u00e9zz\u00fck a k\u00f6vetkez\u0151 forgat\u00f3k\u00f6nyvet:</p> <ol> <li>A sor \u00fcres. A feldolgoz\u00f3 sz\u00e1lak egy <code>while</code> ciklusban folyamatosan pollozz\u00e1k a FIFO-t, vagyis h\u00edvj\u00e1k a <code>TryGet</code> met\u00f3dus\u00e1t.</li> <li>A felhaszn\u00e1l\u00f3 egy feladatot tesz a sorba.</li> <li>Az egyik feldolgoz\u00f3 sz\u00e1l a <code>TryGet</code> met\u00f3dusban azt l\u00e1tja, van adat a sorban, vagyis <code>if ( _innerList.Count &gt; 0 )</code> k\u00f3dsor felt\u00e9tele teljes\u00fcl, \u00e9s r\u00e1l\u00e9p a k\u00f6vetkez\u0151 k\u00f3dsorra. Tegy\u00fck fel, hogy ez a sz\u00e1l ebben a pillanatban elveszti a fut\u00e1si jog\u00e1t, m\u00e1r nincs ideje kivenni az adatot a sorb\u00f3l.</li> <li>Egy m\u00e1sik feldolgoz\u00f3 sz\u00e1l is \u00e9ppen ekkor ejti meg az <code>if ( _innerList.Count &gt; 0 )</code> vizsg\u00e1latot, n\u00e1la is teljes\u00fcl a felt\u00e9tel, \u00e9s ez a sz\u00e1l ki is veszi az adatot a sorb\u00f3l.</li> <li>Az els\u0151 sz\u00e1lunk \u00fajra \u00fctemez\u00e9sre ker\u00fcl, fel\u00e9bred, \u0151 is megpr\u00f3b\u00e1lja kivenni az adatot a sorb\u00f3l: a sor viszont m\u00e1r \u00fcres, a m\u00e1sik sz\u00e1lunk kivette az egyetlen adatot a sorb\u00f3l az orra el\u0151tt. \u00cdgy az <code>_innerList[0]</code> hozz\u00e1f\u00e9r\u00e9s kiv\u00e9telt eredm\u00e9nyez.</li> </ol> <p>Ezt a probl\u00e9m\u00e1t csak \u00fagy tudjuk elker\u00fclni, ha a sor \u00fcress\u00e9g\u00e9nek a vizsg\u00e1lat\u00e1t \u00e9s az elem kiv\u00e9tel\u00e9t oszthatatlann\u00e1 tessz\u00fck.</p> <p>Thread.Sleep(500)</p> <p>Az \u00fcress\u00e9gvizsg\u00e1latot figyel\u0151 k\u00f3dsort k\u00f6vet\u0151 <code>Thread.Sleep(500);</code> k\u00f3dsornak csak az a szerepe a p\u00e9ldak\u00f3dunkban, hogy a fenti peches forgat\u00f3k\u00f6nyv bek\u00f6vetkez\u00e9s\u00e9nek a val\u00f3sz\u00edn\u0171s\u00e9g\u00e9t megn\u00f6velje, s \u00edgy a p\u00e9ld\u00e1t szeml\u00e9letesebb\u00e9 tegye (mivel ilyenkor szinte biztos, hogy \u00e1t\u00fctemez\u0151dik a sz\u00e1l). A k\u00e9s\u0151bbiekben ezt ki is fogjuk venni, egyel\u0151re hagyjuk benne.</p>"},{"location":"labor/4-tobbszalu/#problema-2","title":"Probl\u00e9ma 2","text":"<p>A <code>DataFifo</code> oszt\u00e1ly egyid\u0151ben t\u00f6bb sz\u00e1lb\u00f3l is hozz\u00e1f\u00e9rhet a <code>List&lt;double[]&gt;</code> t\u00edpus\u00fa <code>_innerList</code> tagv\u00e1ltoz\u00f3hoz. Ugyanakkor, ha megn\u00e9zz\u00fck a <code>List&lt;T&gt;</code> dokument\u00e1ci\u00f3j\u00e1t, azt tal\u00e1ljuk, hogy az oszt\u00e1ly nem sz\u00e1lbiztos (not thread safe). Ez esetben viszont ezt nem tehetj\u00fck meg, nek\u00fcnk kell z\u00e1rakkal biztos\u00edtanunk, hogy a k\u00f3dunk egyid\u0151ben csak egy met\u00f3dus\u00e1hoz / tulajdons\u00e1g\u00e1hoz / tagv\u00e1ltoz\u00f3j\u00e1hoz f\u00e9r hozz\u00e1 (pontosabban inkonzisztencia csak egyidej\u0171 \u00edr\u00e1s, illetve egyidej\u0171 \u00edr\u00e1s \u00e9s olvas\u00e1s eset\u00e9n l\u00e9phet fel, de az \u00edr\u00f3kat \u00e9s az olvas\u00f3kat a legt\u00f6bb esetben nem szoktuk megk\u00fcl\u00f6nb\u00f6ztetni, itt sem tessz\u00fck).</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a <code>DataFifo</code> oszt\u00e1lyunkat sz\u00e1lbiztoss\u00e1 tessz\u00fck, amivel megakad\u00e1lyozzuk, hogy a fenti k\u00e9t probl\u00e9ma bek\u00f6vetkezhessen.</p>"},{"location":"labor/4-tobbszalu/#6-feladat-tegyuk-szabiztossa-a-datafifo-osztalyt","title":"6. feladat \u2013 Tegy\u00fck sz\u00e1biztoss\u00e1 a DataFifo oszt\u00e1lyt","text":"<p>A <code>DataFifo</code> oszt\u00e1ly sz\u00e1lbiztoss\u00e1 t\u00e9tel\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy objektumra (ez b\u00e1rmilyen referencia t\u00edpus\u00fa objektum lehet), melyet kulcsk\u00e9nt haszn\u00e1lhatunk a z\u00e1rol\u00e1sn\u00e1l. Ezt k\u00f6vet\u0151en a <code>lock</code> kulcssz\u00f3 seg\u00edts\u00e9g\u00e9vel el tudjuk \u00e9rni, hogy egyszerre mindig csak egy sz\u00e1l tart\u00f3zkodjon az adott kulccsal v\u00e9dett blokkokban.</p> <ol> <li> <p>Vegy\u00fcnk fel egy <code>object</code> t\u00edpus\u00fa mez\u0151t <code>_syncRoot</code> n\u00e9ven a <code>DataFifo</code> oszt\u00e1lyba.</p> <pre><code>private object _syncRoot = new object();\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Put</code> \u00e9s a <code>TryGet</code> f\u00fcggv\u00e9nyeket a z\u00e1rol\u00e1ssal.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data); \n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            Thread.Sleep(500);\n\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> <p>Surround with</p> <p>Haszn\u00e1ljuk a Visual Studio Surround with funkci\u00f3j\u00e1t a CTRL + K, CTRL + S billenty\u0171 kombin\u00e1ci\u00f3j\u00e1val a k\u00f6r\u00fclvenni k\u00edv\u00e1nt kijel\u00f6lt k\u00f3dr\u00e9szleten.</p> </li> </ol> <p>Most m\u00e1r nem szabad kiv\u00e9telt kapnunk.</p> <p>Ki is vehetj\u00fck a <code>TryGet</code> met\u00f3dusb\u00f3l a mesters\u00e9ges k\u00e9sleltet\u00e9st (<code>Thread.Sleep(500);</code> sor).</p> <p>Lockol\u00e1s <code>this</code>-en</p> <p>Felmer\u00fclhet a k\u00e9rd\u00e9s, hogy mi\u00e9rt vezett\u00fcnk be egy k\u00fcl\u00f6n <code>_syncRoot</code> tagv\u00e1ltoz\u00f3t \u00e9s haszn\u00e1ltuk ezt z\u00e1rol\u00e1sra a <code>lock</code> param\u00e9terek\u00e9nt, amikor a <code>this</code>-t is haszn\u00e1lhattuk volna helyette (a <code>DataFifo</code> referencia t\u00edpus, \u00edgy ennek nem lenne akad\u00e1lya). A <code>this</code> alkalmaz\u00e1sa azonban s\u00e9rten\u00e9 az oszt\u00e1lyunk egys\u00e9gbez\u00e1r\u00e1s\u00e1t! Ne feledj\u00fck: a <code>this</code> egy referencia az objektumunkra, de m\u00e1s oszt\u00e1lyoknak is van ugyanerre az objektumra referenci\u00e1juk (pl. eset\u00fcnkben a <code>MainWindow</code>-nak van referenci\u00e1ja a <code>DataFifo</code>-ra), \u00e9s ha ezek a k\u00fcls\u0151 oszt\u00e1lyok z\u00e1rat tesznek a <code>lock</code> seg\u00edts\u00e9g\u00e9vel az objektumra, akkor az \"interfer\u00e1l\" az \u00e1ltalunk az oszt\u00e1lyon bel\u00fck haszn\u00e1lt z\u00e1rol\u00e1ssal (mivel <code>this</code> alkalmaz\u00e1sa miatt a k\u00fcls\u0151 \u00e9s bels\u0151 <code>lock</code>-ok param\u00e9tere ugyanaz lesz). \u00cdgy pl. egy k\u00fcls\u0151 z\u00e1rral teljesen meg lehet \"b\u00e9n\u00edtani\" a <code>TryGet</code> \u00e9s <code>Put</code> m\u0171velet m\u0171k\u00f6d\u00e9s\u00e9t. Ezzel szemben az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban a <code>lock</code> param\u00e9tere, a <code>_syncRoot</code> v\u00e1ltoz\u00f3 priv\u00e1t, ehhez m\u00e1r k\u00fcls\u0151 oszt\u00e1lyok nem f\u00e9rhetnek hozz\u00e1, \u00edgy nem is zavarhatj\u00e1k meg az oszt\u00e1lyunk bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9t.</p>"},{"location":"labor/4-tobbszalu/#7-feladat-hatekony-jelzes-megvalositasa","title":"7. feladat \u2013 Hat\u00e9kony jelz\u00e9s megval\u00f3s\u00edt\u00e1sa","text":""},{"location":"labor/4-tobbszalu/#manualresetevent-hasznalata","title":"ManualResetEvent haszn\u00e1lata","text":"<p>A <code>WorkerThread</code>-ben folyamatosan fut\u00f3 <code>while</code> ciklus \u00fan. akt\u00edv v\u00e1rakoz\u00e1st val\u00f3s\u00edt meg, ami mindig ker\u00fclend\u0151. Ha a <code>Thread.Sleep</code>-et nem tett\u00fck volna a ciklusmagba, akkor ezzel maximumra ki is terheln\u00e9 a processzort. A <code>Thread.Sleep</code> megoldja ugyan a processzor terhel\u00e9s probl\u00e9m\u00e1t, de bevezet egy m\u00e1sikat: ha mindh\u00e1rom munkasz\u00e1lunk \u00e9ppen alv\u00f3 \u00e1llapotba l\u00e9pett, mikor be\u00e9rkezik egy \u00faj adat, akkor feleslegesen v\u00e1runk 500 ms-ot az adat feldolgoz\u00e1s\u00e1nak megkezd\u00e9s\u00e9ig.</p> <p>A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1st, hogy blokkolva v\u00e1rakozzon, am\u00edg adat nem ker\u00fcl a FIFO-ba (amikor viszont adat ker\u00fcl bele, azonnal kezdje meg a feldolgoz\u00e1st). Annak jelz\u00e9s\u00e9re, hogy van-e adat a sorban egy <code>ManualResetEvent</code>-et fogunk haszn\u00e1lni.</p> <ol> <li> <p>Adjunk hozz\u00e1 egy <code>MaunalResetEvent</code> p\u00e9ld\u00e1nyt a <code>DataFifo</code> oszt\u00e1lyunkhoz <code>_hasData</code> n\u00e9ven.</p> <pre><code>// A false konstruktor param\u00e9ter eredm\u00e9nyek\u00e9ppen kezdetben az esem\u00e9ny nem jelzett (kapu csukva)\nprivate ManualResetEvent _hasData = new ManualResetEvent(false);\n</code></pre> </li> <li> <p>A <code>_hasData</code> alkalmaz\u00e1sunkban kapuk\u00e9nt viselkedik. Amikor adat ker\u00fcl a list\u00e1ba \u201ekinyitjuk\u201d, m\u00edg amikor ki\u00fcr\u00fcl a lista \u201ebez\u00e1rjuk\u201d.</p> <p>Az esem\u00e9ny szemantik\u00e1ja \u00e9s elnevez\u00e9se</p> <p>L\u00e9nyeges, hogy j\u00f3 v\u00e1lasszuk meg az esem\u00e9ny\u00fcnk szemantik\u00e1j\u00e1t \u00e9s ezt a v\u00e1ltoz\u00f3nk nev\u00e9vel pontosan ki is fejezz\u00fck. A p\u00e9ld\u00e1nkban a <code>_hasData</code> n\u00e9v j\u00f3l kifejezi, hogy pontosan akkor \u00e9s csak akkor jelzett az esem\u00e9ny\u00fcnk (nyitott a kapu), amikor van feldolgozand\u00f3 adat. Most m\u00e1r \"csak\" az a dolgunk, hogy ezt a szemantik\u00e1t megval\u00f3s\u00edtsuk: jelzettbe tegy\u00fck az esem\u00e9nyt, mikor adat ker\u00fcl a FIFO-ba, \u00e9s jelzetlenbe, amikor ki\u00fcr\u00fcl a FIFO.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data);\n        _hasData.Set();\n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> </li> </ol>"},{"location":"labor/4-tobbszalu/#jelzesre-varakozas-blokkolo-a-get","title":"Jelz\u00e9sre v\u00e1rakoz\u00e1s (blokkol\u00f3 a Get)","text":"<p>Az el\u0151z\u0151 pontban megoldottuk a jelz\u00e9st, \u00e1m ez \u00f6nmag\u00e1ban nem sokat \u00e9r, hiszen nem v\u00e1rakoznak r\u00e1. Ennek megval\u00f3s\u00edt\u00e1sa j\u00f6n most.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a met\u00f3dust az al\u00e1bbiak szerint: kidobjuk az \u00fcress\u00e9g vizsg\u00e1latot \u00e9s az esem\u00e9nyre val\u00f3 v\u00e1rakoz\u00e1ssal p\u00f3toljuk.</p> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_hasData.WaitOne())\n        {\n            // ...\n</code></pre> <p>A WaitOne m\u0171velet visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9nek vizsg\u00e1lata</p> <p>A <code>WaitOne</code> m\u0171velet egy <code>bool</code> \u00e9rt\u00e9kkel t\u00e9r vissza, mely igaz, ha a <code>WaitOne</code> param\u00e9ter\u00e9ben megadott id\u0151korl\u00e1t el\u0151tt jelzett \u00e1llapotba ker\u00fcl az esem\u00e9ny (ill. ennek megfelel\u0151en hamis, ha lej\u00e1rt az id\u0151korl\u00e1t). A p\u00e9ld\u00e1nkban nem adtunk meg id\u0151korl\u00e1tot param\u00e9terben, mely v\u00e9gtelen id\u0151korl\u00e1t alkalmaz\u00e1s\u00e1t jelenti. Ennek megfelel\u0151en felesleges is az <code>if</code> felt\u00e9telvizsg\u00e1lat, hiszen eset\u00fcnkben a <code>WaitOne()</code> mindig igaz \u00e9rt\u00e9kkel t\u00e9r vissza. Ez egyetlen ok, ami\u00e9rt m\u00e9gis \u00e9lt\u00fcnk felt\u00e9telvizsg\u00e1lattal: \u00edgy a k\u00f6vetketkez\u0151 \u00e9s egy k\u00e9s\u0151bbi feladatn\u00e1l kisebb \u00e1talak\u00edt\u00e1sra lesz majd sz\u00fcks\u00e9g.</p> </li> <li> <p>Ezzel a <code>Thread.Sleep</code> a <code>WorkerThread</code>-ben feleslegess\u00e9 v\u00e1lt, kommentezz\u00fck ki!</p> <p>A fenti megold\u00e1s futtat\u00e1sakor azt tapasztaljuk, hogy az alkalmaz\u00e1sunk fel\u00fclete az els\u0151 gombnyom\u00e1st k\u00f6vet\u0151en befagy. Az el\u0151z\u0151 megold\u00e1sunkban ugyanis egy amat\u0151r hib\u00e1t k\u00f6vett\u00fcnk el. A lock-olt k\u00f3dr\u00e9szleten bel\u00fcl v\u00e1rakozunk a <code>_hasData</code> jelz\u00e9s\u00e9re, \u00edgy a f\u0151sz\u00e1lnak lehet\u0151s\u00e9ge sincs arra, hogy a <code>Put</code> m\u0171veletben (egy szint\u00e9n <code>lock</code>-kal v\u00e9dett r\u00e9szen bel\u00fcl) jelz\u00e9st k\u00fcldj\u00f6n <code>_hasData</code>-val. Gyakorlatilag egy holtpont (deadlock) helyzet alakult ki.</p> <p>Pr\u00f3b\u00e1lkozhatn\u00e1nk egy id\u0151korl\u00e1t megad\u00e1s\u00e1val (ms) a v\u00e1rakoz\u00e1sn\u00e1l:</p> <pre><code>if (_hasData.WaitOne(100))\n</code></pre> <p>Ez \u00f6nmag\u00e1ban sem lenne eleg\u00e1ns megold\u00e1s, r\u00e1ad\u00e1sul a folyamatosan polloz\u00f3 munkasz\u00e1lak jelent\u0151sen ki\u00e9heztetn\u00e9k a Put-ot h\u00edv\u00f3 sz\u00e1lat! Helyette, az eleg\u00e1ns \u00e9s k\u00f6vetend\u0151 minta az, hogy lock-on bel\u00fcl ker\u00fclj\u00fck a blokkolva v\u00e1rakoz\u00e1st.</p> <p>Val\u00f3di jav\u00edt\u00e1sk\u00e9nt cser\u00e9lj\u00fck meg a <code>lock</code>-ot \u00e9s a <code>WaitOne</code>-t, illetve a <code>WaitOne</code> param\u00e9ter elt\u00e1vol\u00edt\u00e1s\u00e1val sz\u00fcntess\u00fck meg a v\u00e1rakoz\u00e1si id\u0151korl\u00e1tot:</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (_hasData.WaitOne())\n    {\n        lock (_syncRoot)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true; \n        }\n    }\n\n    data = null;\n    return false;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Az els\u0151 gombnyom\u00e1s hat\u00e1s\u00e1ra kiv\u00e9telt kapunk. \u00cdgy elker\u00fclj\u00fck ugyan a deadlockot, azonban a sz\u00e1lbiztoss\u00e1g s\u00e9r\u00fclt, hiszen mire a <code>lock</code>-on bel\u00fclre jutunk, nem biztos, hogy maradt elem a list\u00e1ban. Ugyanis lehet, t\u00f6bb sz\u00e1l is v\u00e1rakozik a <code>_hasData.WaitOne()</code> m\u0171veletn\u00e9l arra, hogy elem ker\u00fclj\u00f6n a sorba. Mikor ez bek\u00f6vetkezik, a <code>ManualResetEvent</code> objektumunk mind \u00e1tengedi (hacsak \u00e9ppen gyorsan le nem csukja egy sz\u00e1l, de ez nem garant\u00e1lt).</p> <p>A konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s neh\u00e9zs\u00e9gei</p> <p>J\u00f3l illusztr\u00e1lja a feladat, hogy milyen alapos \u00e1tgondol\u00e1st ig\u00e9nyel a konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s. Tulajdonk\u00e9ppen m\u00e9g szerencs\u00e9nk is volt az el\u0151z\u0151ekben, mert j\u00f3l reproduk\u00e1lhat\u00f3an el\u0151j\u00f6tt a hiba. A gyakorlatban azonban ez ritk\u00e1n van \u00edgy. Sajnos sokkal gyakoribb, hogy a konkurenciahib\u00e1k id\u0151nk\u00e9nti, nem reproduk\u00e1lhat\u00f3 probl\u00e9m\u00e1kat okoznak. Az ilyen jelleg\u0171 feladatok megold\u00e1s\u00e1t mindig nagyon \u00e1t kell gondolni, nem lehet az \"addig-pr\u00f3b\u00e1lkozom-m\u00edg-j\u00f3-nem-lesz-a-k\u00e9zi-teszt-sor\u00e1n\" elv ment\u00e9n leprogramozni.</p> </li> <li> <p>Jav\u00edt\u00e1sk\u00e9nt tegy\u00fck vissza a <code>lock</code>-on bel\u00fcli \u00fcress\u00e9g-vizsg\u00e1latot.</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (_hasData.WaitOne())\n    {\n        lock (_syncRoot)\n        {\n            if (_innerList.Count &gt; 0)\n            {\n                data = _innerList[0];\n                _innerList.RemoveAt(0);\n                if (_innerList.Count == 0)\n                {\n                    _hasData.Reset();\n                }\n\n                return true;  \n            }\n        }\n    }\n\n    data = null;\n    return false;\n}\n</code></pre> <p>Ez m\u00e1r j\u00f3l m\u0171k\u00f6dik. El\u0151fordulhat ugyan, hogy feleslegesen fordulunk a list\u00e1hoz, de ezzel \u00edgy most megel\u00e9gsz\u00fcnk.</p> <p>Tesztelj\u00fck az alkalmaz\u00e1st!</p> </li> </ol> <p>System.Collections.Concurrent</p> <p>A .NET keretrendszerben t\u00f6bb be\u00e9p\u00edtett sz\u00e1lbiztoss\u00e1gra felk\u00e9sz\u00edtett oszt\u00e1ly is tal\u00e1lhat\u00f3 a <code>System.Collections.Concurrent</code> n\u00e9vt\u00e9rben. A fenti p\u00e9ld\u00e1ban a <code>DataFifo</code> oszt\u00e1lyt a <code>System.Collections.Concurrent.ConcurrentQueue</code> oszt\u00e1llyal kiv\u00e1lthattuk volna.</p>"},{"location":"labor/4-tobbszalu/#8-feladat-kulturalt-leallas","title":"8. feladat \u2013 Kultur\u00e1lt le\u00e1ll\u00e1s","text":"<p>Kor\u00e1bban f\u00e9lretett\u00fck azt a probl\u00e9m\u00e1t, hogy az ablakunk bez\u00e1r\u00e1sakor a processz\u00fcnk \u201eberagad\u201d, ugyanis a feldolgoz\u00f3 munkasz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9ptet\u00e9s\u00fcket eddig nem oldottuk meg. C\u00e9lunk, hogy a v\u00e9gtelen <code>while</code> ciklust kiv\u00e1ltva a munkasz\u00e1laink az alkalmaz\u00e1s bez\u00e1r\u00e1sakor kultur\u00e1lt m\u00f3don \u00e1lljanak le.</p> <ol> <li> <p>Egy <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel jelezz\u00fck a le\u00e1ll\u00edt\u00e1st a FIFO-ban a <code>TryGet</code>-ben t\u00f6rt\u00e9n\u0151 v\u00e1rakoz\u00e1s sor\u00e1n. A FIFO-ban vegy\u00fcnk fel egy \u00faj <code>ManualResetEvent</code>-et, \u00e9s vezess\u00fcnk be egy <code>Release</code> m\u0171veletet, amellyel a v\u00e1rakoz\u00e1sainkat z\u00e1rhatjuk r\u00f6vidre (\u00faj esem\u00e9ny\u00fcnk jelzett \u00e1llapotba \u00e1ll\u00edthat\u00f3).</p> <pre><code>private ManualResetEvent _releaseTryGet = new ManualResetEvent(false);\n\npublic void Release()\n{\n    _releaseTryGet.Set();\n}\n</code></pre> </li> <li> <p>A <code>TryGet</code>-ben erre az esem\u00e9nyre is v\u00e1rakozzunk. A <code>WaitAny</code> met\u00f3dus akkor engedi tov\u00e1bb a futtat\u00e1st, ha a param\u00e9terk\u00e9nt megadott <code>WaitHandle</code> t\u00edpus\u00fa objektumok k\u00f6z\u00fcl valamelyik jelzett \u00e1llapotba ker\u00fcl, \u00e9s visszaadja annak t\u00f6mbb\u00e9li index\u00e9t. T\u00e9nyleges adatfeldolgoz\u00e1st pedig csak akkor szeretn\u00e9nk, ha a <code>_hasData</code> jelzett (amikor is a <code>WaitAny</code> 0-val t\u00e9r vissza).</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (WaitHandle.WaitAny(new[] { _hasData, _releaseTryGet }) == 0)\n    {\n        lock (_syncRoot)\n        {\n</code></pre> </li> <li> <p><code>MainWindow.xaml.cs</code>-ban vegy\u00fcnk fel egy flag tagv\u00e1ltoz\u00f3t a bez\u00e1r\u00e1s jelz\u00e9s\u00e9re:</p> <pre><code>private bool _isClosed = false;\n</code></pre> </li> <li> <p>A f\u0151ablak bez\u00e1r\u00e1sakor \u00e1ll\u00edtsuk jelzettre az \u00faj esem\u00e9nyt \u00e9s billents\u00fcnk be be a flag-et is: a <code>MainWindow</code> oszt\u00e1ly <code>Closed</code> esem\u00e9ny\u00e9re iratkozzunk fel a konstruktorban, \u00e9s \u00edrjuk meg a megfelel\u0151 esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt:</p> <pre><code>public MainWindow()\n{\n    ...\n\n    Closed += MainWindow_Closed;\n}\n\nprivate void MainWindow_Closed(object sender, WindowEventArgs args)\n{\n    _isClosed = true;\n    _fifo.Release();\n}\n</code></pre> </li> <li> <p>\u00cdrjuk \u00e1t a while ciklust az el\u0151z\u0151 pontban felvett flag figyel\u00e9s\u00e9re.</p> <pre><code>private void WorkerThread()\n{\n    while (!_isClosed)\n    {\n</code></pre> </li> <li> <p>V\u00e9g\u00fcl biztos\u00edtsuk, hogy a m\u00e1r bez\u00e1r\u00f3d\u00f3 ablak eset\u00e9ben ne pr\u00f3b\u00e1ljunk \u00fczeneteket ki\u00edrni</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    if (_isClosed)\n        return;\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s ellen\u0151rizz\u00fck, kil\u00e9p\u00e9skor az processz\u00fcnk val\u00f3ban befejezi-e a fut\u00e1s\u00e1t.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#kitekintes-task-async-await","title":"Kitekint\u00e9s: Task, async, await","text":"<p>A gyakorlat sor\u00e1n az alacsonyabb szint\u0171 sz\u00e1lkezel\u00e9si technik\u00e1kkal k\u00edv\u00e1ntunk megismerkedni. Ugyanakkor megold\u00e1sunkat (legal\u00e1bbis r\u00e9szben) \u00e9p\u00edthett\u00fck volna a .NET aszinkron programoz\u00e1st t\u00e1mogat\u00f3 magasabb szint\u0171 eszk\u00f6zeire \u00e9s mechanizmusaira, \u00fagymint <code>Task</code>/<code>Task&lt;T&gt;</code> oszt\u00e1lyok \u00e9s <code>async</code>/<code>await</code> kulcsszavak.</p>"},{"location":"labor/5-mvvm/","title":"5. MVVM","text":"<p>COMING SOON...</p>"},{"location":"labor/6-tervezesi-mintak/","title":"6. Tervez\u00e9si mint\u00e1k","text":"<p>COMING SOON...</p>"},{"location":"labor/6-tervezesi-mintak-pre/","title":"6. Tervez\u00e9si mint\u00e1k (kiterjeszthet\u0151s\u00e9g)","text":""},{"location":"labor/6-tervezesi-mintak-pre/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai (egy \u00f6sszetettebb, \u00e9letszer\u0171 p\u00e9lda alapj\u00e1n):</p> <ul> <li>Kiterjeszthet\u0151s\u00e9get, \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got, k\u00f3d \u00e1tl\u00e1that\u00f3s\u00e1got \u00e9s karbantarthat\u00f3s\u00e1got seg\u00edt\u0151 n\u00e9h\u00e1ny tervez\u00e9si alapelv gyakorl\u00e1sa: SRP, OPEN-CLOSED, DRY, KISS stb.</li> <li>N\u00e9h\u00e1ny, a kiterjeszthet\u0151s\u00e9ghez legink\u00e1bb kapcsol\u00f3d\u00f3 tervez\u00e9si minta alkalmaz\u00e1sa (Template Method, Strategy, Dependency Injection).</li> <li>Kiterjeszthet\u0151s\u00e9get \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 tov\u00e1bbi technik\u00e1k (pl. delegate/lambda kifejez\u00e9s) gyakorl\u00e1sa \u00e9s kombin\u00e1l\u00e1sa tervez\u00e9si mint\u00e1kkal.</li> <li>K\u00f3d refaktor\u00e1l\u00e1s gyakorl\u00e1sa.</li> <li>Egys\u00e9gteszt (unit test) fogalm\u00e1nak pontos\u00edt\u00e1sa, egys\u00e9gtesztelhet\u0151 k\u00f3d kialak\u00edt\u00e1sa.</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok:</p> <ul> <li>Tervez\u00e9si mint\u00e1k: kiterjeszthet\u0151s\u00e9ghez kapcsol\u00f3d\u00f3 mint\u00e1k (bevezet\u0151, Template Method, Strategy), valamint a Dependency Injection \"minta\".</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Gyakorlat Linuxon vagy macOS alatt</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de az elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is m\u00e1s fejleszt\u0151eszk\u00f6z\u00f6kkel (pl. VS Code, Rider, Visual Studio for Mac), vagy ak\u00e1r egy sz\u00f6vegszerkeszt\u0151vel \u00e9s CLI (parancssori) eszk\u00f6z\u00f6kkel. Ezt az teszi lehet\u0151v\u00e9, hogy a p\u00e9ld\u00e1k egy egyszer\u0171 Console alkalmaz\u00e1s kontextus\u00e1ban ker\u00fclnek ismertet\u00e9sre (nincsenek Windows specifikus elemek), a .NET 8 SDK pedig t\u00e1mogatott Linuxon \u00e9s macOS alatt. Hello World Linuxon.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#elmeleti-hatter-szemleletmod","title":"Elm\u00e9leti h\u00e1tt\u00e9r, szeml\u00e9letm\u00f3d *","text":"<p>A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. A megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t/m\u00f3dos\u00edt\u00e1s\u00e1t ig\u00e9nylik: ennek sor\u00e1n \u00faj hib\u00e1k sz\u00fcletnek, illetve jelent\u0151s munk\u00e1t kell fektetni a k\u00f3d nagy l\u00e9pt\u00e9k\u0171 \u00fajratesztel\u00e9s\u00e9be is!</p> <p>Ehelyett a c\u00e9lunk az, hogy az ilyen v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyeket a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d \u00e9rdemi m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - meg tudjuk val\u00f3s\u00edtani. A kulcssz\u00f3: m\u00f3dos\u00edt\u00e1ssal szemben b\u0151v\u00edt\u00e9s. Ehhez kapcsol\u00f3d\u00f3an: amennyiben bizonyos logik\u00e1ink kiterjeszthet\u0151k, \u00edgy \u00e1ltal\u00e1nosabbak is leszek, k\u00f6nnyebben, t\u00f6bb kontextusban is fel tudjuk ezeket haszn\u00e1lni. \u00cdgy hosszabb t\u00e1von gyorsabban haladunk, r\u00f6videbb a k\u00f3d, elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t (ez\u00e1ltal k\u00f6nnyebben karbantarthat\u00f3 is a k\u00f3d).</p> <p>A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Jelen gyakorlat keret\u00e9ben azon mint\u00e1kra, tervez\u00e9si elvekre \u00e9s n\u00e9h\u00e1ny programoz\u00f3i eszk\u00f6zre f\u00f3kusz\u00e1lunk, melyek a fenti probl\u00e9m\u00e1kon seg\u00edtenek. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen. Ennek t\u00fckr\u00e9ben nem is c\u00e9lunk (\u00e9s sokszor nincs is r\u00e1 lehet\u0151s\u00e9g\u00fcnk), hogy minden j\u00f6v\u0151beli kiterjeszthet\u0151s\u00e9gi ig\u00e9ny el\u0151re meg\u00e9rezz\u00fcnk, illetve nagyon el\u0151re \u00e1tgondoljunk. A l\u00e9nyeg az, hogy ak\u00e1r egy egyszer\u0171 megold\u00e1sb\u00f3l kiindulva, az egyes probl\u00e9m\u00e1kat felismerve, a k\u00f3dunkat folyamatosan refaktor\u00e1ljuk \u00fagy, hogy az aktu\u00e1lis (funkcion\u00e1lis \u00e9s nemfunkcion\u00e1lis) k\u00f6vetelm\u00e9nyeknek \u00e9s el\u0151rel\u00e1t\u00e1sunknak szerint a megfelel\u0151 pontokban tegy\u00fck k\u00f3dunkat k\u00f6nnyebben kiterjeszthet\u0151v\u00e9 \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1.</p> <p>Z\u00e1r\u00e1sk\u00e9ppen megvizsg\u00e1ljuk, hogyan seg\u00edtenek bizonyos tervez\u00e9si mint\u00e1k \u00e9s nyelvi eszk\u00f6z\u00f6k a k\u00f3dunk egys\u00e9gtesztelhet\u0151v\u00e9 t\u00e9tel\u00e9ben: sok c\u00e9gn\u00e9l egy szoftverterm\u00e9k fejleszt\u00e9se eset\u00e9n (jogos) alapelv\u00e1r\u00e1s a fejleszt\u0151kt\u0151l, hogy nagy k\u00f3dlefedetts\u00e9g\u0171 egys\u00e9gteszteket (unit test) k\u00e9sz\u00edtsenek. Ennek kivitelez\u00e9se viszont gyakorlatilag lehetetlen, ha a k\u00f3dunk egyes egys\u00e9gei/oszt\u00e1lyai t\u00fal szoros csatol\u00e1sban vannak egym\u00e1ssal.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#0-feladat-ismerkedes-a-feladattal-es-a-kiindulo-alkalmazassal","title":"0. Feladat - Ismerked\u00e9s a feladattal \u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal","text":"<p>Kl\u00f3nozzuk le a 6. gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-designpatterns-kiindulo.git</code></li> <li>Nyissuk meg a Lab-Extensibility.sln solutiont Visual Studio-ban.</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#a-feladat-ismertetese","title":"A feladat ismertet\u00e9se","text":"<p>A gyakorlat sor\u00e1n egy konzol alap\u00fa, adatfeldolgoz\u00f3 (pontosabban anonimiz\u00e1l\u00f3) alkalmaz\u00e1st fogunk a folyamatosan alakul\u00f3 ig\u00e9nyeknek megfelel\u0151en - k\u00fcl\u00f6nb\u00f6z\u0151 pontok ment\u00e9n \u00e9s k\u00fcl\u00f6nb\u00f6z\u0151 technik\u00e1kat alkalmazva - kiterjeszthet\u0151v\u00e9 tenni. Az els\u0151 feladat keret\u00e9ben az anonimiz\u00e1l\u00e1s fogalm\u00e1val is megismerked\u00fcnk.</p> <p>Az alkalmaz\u00e1s bemenete egy CSV sz\u00f6vegf\u00e1jl, mely minden sora egy adott szem\u00e9lyre vonatkoz\u00f3an tartalmaz adatokat. A f\u00e1jlrendszerben nyissuk meg a Data mapp\u00e1ban lev\u0151 us-500.csv f\u00e1jlt (duplakattal, vagy ak\u00e1r a Jegyzett\u00f6mb/Notepad alkalmaz\u00e1sban). Az l\u00e1tjuk, hogy \"\" k\u00f6z\u00f6tt, vessz\u0151vel elv\u00e1lasztva tal\u00e1lhat\u00f3k az egyes szem\u00e9lyekre vonatkoz\u00f3 adatok (ezek nem val\u00f3sak). N\u00e9zz\u00fck az els\u0151 sort:</p> <pre><code>\"James\",\"Butt\",\"Benton, John B Jr\",\"6649 N Blue Gum St\",\"New Orleans \",\"Orleans\",\"LA\",\"70116\",\"504-621-8927\",\"504-845-1427\",\"30\",\"65\",\"Heart-related\",\"jbutt@gmail.com\"\n</code></pre> <p>Az els\u0151 sorban lev\u0151 szem\u00e9lyt James Buttnak nevezik, a \"Benton, John B Jr\" c\u00e9gn\u00e9l dolgozik, majd n\u00e9h\u00e1ny c\u00edmre vonatkoz\u00f3 mez\u0151 tal\u00e1lhat\u00f3, 30 \u00e9ves, 65 kg a tests\u00falya. Az ezt k\u00f6vet\u0151 mez\u0151 azt mondja meg, milyen s\u00falyosabb betegs\u00e9ge van (a fenti sorba ez \"Heart-related\"). Az utols\u00f3 oszlop pedig a szem\u00e9ly e-mail c\u00edm\u00e9t tartalmazza.</p> Adatok forr\u00e1sa \u00e9s pontos form\u00e1tuma * <p>Az adatok forr\u00e1sa: https://www.briandunning.com/sample-data/, p\u00e1r oszloppal (kor, s\u00faly, betegs\u00e9g) kieg\u00e9sz\u00edtve. A mez\u0151k sorrendje: First Name, Last Name, Company, Address, City, County (where applicable), State/Province (where applicable), ZIP/Postal Code, Phone 1, Phone 2, Age, Weight, Illness, Email</p> <p>Az alkalmaz\u00e1s alapfeladata, hogy ezeket az adatokat az aktu\u00e1lis ig\u00e9nyeknek megfelel\u0151en anonimiz\u00e1lja, majd egy kimeneti CSV sz\u00f6vegf\u00e1jlba ki\u00edrja. Az anonimiz\u00e1l\u00e1s feladata, hogy az adatokat olyan form\u00e1ba alak\u00edtsa, hogy agy adathalmazban lev\u0151 szem\u00e9lyeket beazonos\u00edthatatlann\u00e1 tegye, de olyan m\u00f3don, hogy az adatokb\u00f3l m\u00e9gis lehessen kimutat\u00e1sokat k\u00e9sz\u00edteni. Az anonimiz\u00e1l\u00e1s egy k\u00fcl\u00f6n\u00e1ll\u00f3, nagyon komoly, \u00e9s sok kih\u00edv\u00e1st rejt\u0151 adatfeldolgoz\u00e1si szakter\u00fclet. A gyakorlat keret\u00e9ben nem c\u00e9lunk, hogy val\u00f3s k\u00f6rnyezetben is haszn\u00e1lhat\u00f3, vagy ak\u00e1r minden tekintetben \u00e9rtelmes megold\u00e1sokat dolgozzunk ki. Sz\u00e1munkra tulajdonk\u00e9ppen csak egy valamilyen adatfeldolgoz\u00f3 algoritmus \"bevet\u00e9se\" a fontos a mint\u00e1k bemutat\u00e1s\u00e1hoz, \u00e9s ez tal\u00e1n kicsit \"izgalmasabb\" keretet ad, mint egy egyszer\u0171 adatsz\u0171r\u00e9s/sorrendez\u00e9s/stb. alap\u00fa adatfeldolgoz\u00e1s (melyeket r\u00e1ad\u00e1sul a .NET m\u00e1r eleve be\u00e9p\u00edtve t\u00e1mogat).</p> <p>P\u00e1r gondolat az anonimiz\u00e1l\u00e1sr\u00f3l</p> <p>Azt gondolhatn\u00e1nk, hogy az anonimiz\u00e1l\u00e1s egy egyszer\u0171 probl\u00e9mak\u00f6r. Pl. csak el kell t\u00e1vol\u00edtani, vagy ki kell \"csillagozni\" a szem\u00e9lyek neveit, lakc\u00edm\u00e9b\u0151l az utca-h\u00e1zsz\u00e1mot, telefonsz\u00e1mokat, e-mail c\u00edmet, \u00e9s meg is vagyunk. P\u00e9ld\u00e1ul a bemenet\u00fcnk els\u0151 sor\u00e1ra ez lenne a kimenet:</p> <pre><code>\"***\",\"***\",\"Benton, John B Jr\",\"***\",\"New Orleans \",\"Orleans\",\"LA\",\"70116\",\"***\",\"***\",\"30\",\"65\",\"Heart-related\",\"***\"\n</code></pre> <p>De ez kor\u00e1nt sincs \u00edgy, k\u00fcl\u00f6n\u00f6sen, ha igaz\u00e1n sok adatr\u00f3l van sz\u00f3. Gondoljunk arra, hogy van egy kisebb falu, ahol nem laknak sokan. Tegy\u00fck fel, hogy az egyik fenti m\u00f3don anonimiz\u00e1lt szem\u00e9ly \u00e9letkora 14 \u00e9v, de rendk\u00edv\u00fcl t\u00fals\u00falyos, 95 kg. Ez egy ritka \"kombin\u00e1ci\u00f3\", m\u00e1s szem\u00e9ly j\u00f3 es\u00e9llyel nem \u00e9l ilyen param\u00e9terekkel a faluban. Ha az \u0151 oszt\u00e1lyt\u00e1rsai k\u00f6z\u00fcl (nyolcadikos, hiszen 14 \u00e9ves) valaki megn\u00e9zi az \"anonimiz\u00e1lt\" adatokat, tudni fogja ki \u0151 (nincs m\u00e1s ennyire t\u00fals\u00falyos nyolcadikos az iskol\u00e1ban), beazonos\u00edtja a szem\u00e9lyt, \u00e9s \u00edgy pl. tudni fogja, milyen betegs\u00e9ge van. Tanuls\u00e1g: az adatok \u00f6sszef\u00fcgg\u00e9sben \u00e1rulkod\u00f3k lehetnek.</p> <p>Mi a megold\u00e1s? A v\u00e1rost, az \u00e9letkort \u00e9s a testt\u00f6meget nem t\u00f6r\u00f6lhetj\u00fck/csillagozhatjuk, mert ezekre vonatkoz\u00f3an kell kimutat\u00e1st k\u00e9sz\u00edteni. Egy tipikus megold\u00e1s: nem pontos \u00e9letkort/tests\u00falyt adunk meg az anonimiz\u00e1l\u00e1st k\u00f6vet\u0151en, hanem s\u00e1vokat (vagyis \u00e1ltal\u00e1nos\u00edtjuk az adatokat): pl. a fenti szem\u00e9ly eset\u00e9ben az \u00e9letkora 10..20 \u00e9v, tests\u00falya 80..100 kg, \u00e9s ezt adjuk meg erre a szem\u00e9lyre vonatkoz\u00f3an a kimeneti f\u00e1jlban. \u00cdgy m\u00e1r nem lehet beazonos\u00edtani. Ezt a technik\u00e1t mi is fogjuk k\u00e9s\u0151bb alkalmazni.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#kiindulo-kovetelmenyek","title":"Kiindul\u00f3 k\u00f6vetelm\u00e9nyek","text":"<p>Az alkalmaz\u00e1ssal szemben t\u00e1masztott kiindul\u00f3 k\u00f6vetelm\u00e9nyek:</p> <ol> <li>Egy adott \u00fcgyf\u00e9lt\u0151l kapott f\u00e1jlokat (mindnek ugyanaz a form\u00e1tuma) kell ugyanazzal az anonimiz\u00e1l\u00f3 algoritmussal, ugyanabba a kimeneti form\u00e1tumba konvert\u00e1lni. Az anonimiz\u00e1l\u00e1s egyszer\u0171en a keresztn\u00e9v \u00e9s vezet\u00e9kn\u00e9v \"kicsillagoz\u00e1s\u00e1b\u00f3l\" \u00e1lljon.</li> <li>Sz\u00fcks\u00e9g van n\u00e9mi adattiszt\u00edt\u00e1sra. A bemeneti adatokban a v\u00e1rost tartalmaz\u00f3 oszlop elej\u00e9n/v\u00e9g\u00e9n lehetnek felesleges <code>_</code> \u00e9s <code>#</code> karakterek, ezeket el kell t\u00e1vol\u00edtani (trim m\u0171velet).</li> <li>Ki kell \u00edrni minden sor feldolgoz\u00e1sa ut\u00e1n a konzolra, hogy a sor feldolgoz\u00e1sa megt\u00f6rt\u00e9nt, ill. a minden adat feldolgoz\u00e1s ut\u00e1n n\u00e9mi \u00f6sszes\u00edt\u0151 inform\u00e1ci\u00f3t (Summary): h\u00e1ny sort dolgoztunk fel, \u00e9s mennyn\u00e9l kellett a v\u00e1rosnevet trimmelni.</li> <li>L\u00e9nyeges szempont: az alkalmaz\u00e1sra csak r\u00f6vid id\u0151re lesz sz\u00fcks\u00e9g, nem a k\u00edv\u00e1njuk k\u00e9s\u0151bbiekben b\u0151v\u00edteni.</li> </ol> <p>Megjegyz\u00e9s: hogy a k\u00f3dban kevesebb mez\u0151vel kelljen dolgozni, \u00e9s a kimenet is \u00e1tl\u00e1that\u00f3bb legyen, elhagyunk m\u00e9g n\u00e9h\u00e1ny mez\u0151t a feldolgoz\u00e1s sor\u00e1n.</p> <p>P\u00e9ldak\u00e9nt a bemeneti f\u00e1jlunk els\u0151 sor\u00e1ra a v\u00e1rt kimenet:</p> <pre><code>***; ***; LA; New Orleans; 30; 65; Heart-related\n</code></pre>"},{"location":"labor/6-tervezesi-mintak-pre/#1-megoldas-minden-egyben-1-startstart","title":"1. Megold\u00e1s - minden egyben (1-Start/Start)","text":"<p>A Visual Studio Solution Explorer\u00e9ben mapp\u00e1kat l\u00e1tunk, 1-t\u0151l 6-ig sz\u00e1mmal kezdve. Ezek az egyes munkaiter\u00e1ci\u00f3khoz tartoz\u00f3 megold\u00e1sokat tartalmazz\u00e1k. Az els\u0151 k\u00f6r\u00f6s megold\u00e1s az \"1-Start\" mapp\u00e1ban, \"Start\" projektn\u00e9v alatt tal\u00e1lhat\u00f3. N\u00e9zz\u00fck meg a projektben tal\u00e1lhat\u00f3 f\u00e1jlokat:</p> <ul> <li><code>Person.cs</code> - Egy szem\u00e9ly sz\u00e1munkra \u00e9rdekes adatai tartalmazza, ennek objektumaiba olvassuk be egy-egy szem\u00e9ly adatait.</li> <li><code>Program.cs</code> - Ennek Main f\u00fcggv\u00e9ny\u00e9ben van megval\u00f3s\u00edtva minden logika, k\u00f3dmegjegyz\u00e9sekkel \"elv\u00e1lasztva\". Amennyiben kicsit is bonyolultabb\u00e1 v\u00e1lik a logika, m\u00e1r k\u00e9t nap mi is csak nehezen fogjuk \u00e1ttekinteni \u00e9s meg\u00e9rteni a saj\u00e1t k\u00f3dunkat. Ezt a megold\u00e1st ne is n\u00e9zz\u00fck.</li> </ul> <p>\u00d6sszeg\u00e9sz\u00e9ben minden nagyon egyszer\u0171. \u00d6sszeg\u00e9sz\u00e9ben nem gondolkodtunk rosszul, hiszen a k\u00f3dnak nem j\u00f3solunk hossz\u00fa j\u00f6v\u0151t. De az egy f\u00fcggv\u00e9nybe \u00f6nt\u00f6tt \"szkriptszer\u0171\", \"minden egybe\" megold\u00e1s ekkor sem j\u00f3 ir\u00e1ny, nagyon neh\u00e9zz\u00e9 teszi a k\u00f3d \u00e1tl\u00e1t\u00e1s\u00e1t, meg\u00e9rt\u00e9s\u00e9t. Ne is n\u00e9zz\u00fck ezt tov\u00e1bb.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#2-megoldas-2-organizedtofunctionsorganizedtofunctions-1","title":"2. Megold\u00e1s (2-OrganizedToFunctions/OrganizedToFunctions-1)","text":"<p>T\u00e9rj\u00fcnk \u00e1t Visual Studioban a \"2-OrganizedToFunctions\" mapp\u00e1ban tal\u00e1lhat\u00f3 \"OrganizedToFunctions-1\" projektben tal\u00e1lhat\u00f3 megold\u00e1sra. Ez m\u00e1r sokkal szimpatikusabb, mert f\u00fcggv\u00e9nyekre bontottuk a logik\u00e1t. Tekints\u00fck \u00e1t a k\u00f3dot r\u00f6viden:</p> <p><code>Anonymizer.cs</code></p> <ul> <li>A <code>Run</code> f\u00fcggv\u00e9ny a \"gerince\", ez tartalmazza a vez\u00e9rl\u00e9si logik\u00e1t, ez h\u00edvja az egyes l\u00e9p\u00e9sek\u00e9rt felel\u0151s f\u00fcggv\u00e9nyeket.</li> <li><code>ReadFromInput</code> m\u0171velet: beolvassa a forr\u00e1sf\u00e1jlt, minden sorhoz k\u00e9sz\u00edt egy <code>Person</code> objektumot, \u00e9s visszat\u00e9r a beolvasott <code>Person</code> objektumok list\u00e1j\u00e1val.</li> <li><code>TrimCityNames</code>: Az adattiszt\u00edt\u00e1st v\u00e9gzi (v\u00e1rosnevek trimmel\u00e9se).</li> <li><code>Anonymize</code>: Minden egyes beolvasott <code>Person</code> objektummal megh\u00edv\u00e1sra ker\u00fcl, \u00e9s feladata, hogy visszaadjon egy \u00faj <code>Person</code> objektumot, mely m\u00e1r az anonimiz\u00e1lt adatokat tartalmazza.</li> <li><code>WriteToOutput</code>: m\u00e1r anonimiz\u00e1lt <code>Person</code> objektumokat ki\u00edrja a kimeneti f\u00e1jlba.</li> <li><code>PrintSummary</code>: ki\u00edrja az \u00f6sszes\u00edt\u00e9st a feldolgoz\u00e1s v\u00e9g\u00e9n a konzolra.</li> </ul> <p><code>Program.cs</code></p> <ul> <li>L\u00e9trehoz egy <code>Anonymizer</code>-t \u00e9s a <code>Run</code> h\u00edv\u00e1s\u00e1val futtatja. L\u00e1that\u00f3, hogy az anonimiz\u00e1l\u00e1s sor\u00e1n maszkol\u00e1sra haszn\u00e1lt stringet konstruktor param\u00e9terben kell megadni.</li> </ul> <p>Pr\u00f3b\u00e1ljuk ki, futtassuk! Ehhez a \"OrganizedToFunctions-1\" legyen Visual Studioban a startup projekt (Jobb katt rajta, \u00e9s Set as Startup Project), majd futtassuk:</p> <p></p> <p>A kimeneti f\u00e1jt f\u00e1jlkezel\u0151ben tudjuk megn\u00e9zni, a \"OrganizedToFunctions-1\\bin\\Debug\\net8.0\\\" vagy hasonl\u00f3 nev\u0171 mapp\u00e1ban tal\u00e1ljuk, \"us-500.processed.txt\" n\u00e9ven. Nyissuk meg, \u00e9s vess\u00fcnk egy pillant\u00e1st az adatokra.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-ertekelese","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<ul> <li>A megold\u00e1s alapvet\u0151en j\u00f3l struktur\u00e1lt, k\u00f6nnyen meg\u00e9rthet\u0151.</li> <li>K\u00f6veti a KISS (Keep It Stupid Simple) elvet, nem haszn\u00e1l felesleges bonyol\u00edt\u00e1sokat. Ez \u00edgy j\u00f3, hiszen nem mer\u00fcltek fel potenci\u00e1lis j\u00f6v\u0151beli tov\u00e1bbfejleszt\u00e9si ig\u00e9nyek, nem kell k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1tumokat, logik\u00e1kat stb. t\u00e1mogatni.</li> <li> <p>A megold\u00e1sunk nem k\u00f6veti az egyik legalapvet\u0151bb \u00e9s legh\u00edresebb tervez\u00e9si elvet, mely Single Responsibility Principle (r\u00f6viden SRP) n\u00e9ven k\u00f6zismert. Ez (n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve) azt v\u00e1rja el, hogy egy oszt\u00e1lynak egy felel\u0151ss\u00e9ge legyen (alapvet\u0151en egy dologgal foglalkozzon).</p> <ul> <li>K\u00e9ts\u00e9gtelen, hogy az <code>Anonymizer</code> oszt\u00e1lyunknak sz\u00e1mos felel\u0151ss\u00e9ge van: bemenet feldolgoz\u00e1sa, adattiszt\u00edt\u00e1s, anonimiz\u00e1l\u00e1s, kimenet el\u0151\u00e1ll\u00edt\u00e1sa stb.</li> <li>Ez a probl\u00e9ma n\u00e1lunk az\u00e9rt nem felt\u0171n\u0151, illetve az\u00e9rt nem okoz gondot, mert mindegyik felel\u0151ss\u00e9g megval\u00f3s\u00edt\u00e1sa egyszer\u0171, \"belef\u00e9rt\" egy-egy r\u00f6videbb f\u00fcggv\u00e9nybe. De ha b\u00e1rmelyik is \u00f6sszetettebb lenne, t\u00f6bb f\u00fcggv\u00e9nyben lenn\u00e9nek megval\u00f3s\u00edtva, akkor mindenk\u00e9ppen k\u00fcl\u00f6n oszt\u00e1lyba illene szervezni.</li> </ul> Mi\u00e9rt probl\u00e9ma, ha egy oszt\u00e1lynak t\u00f6bb felel\u0151ss\u00e9ge van? * <ul> <li>Nehezebb meg\u00e9rteni a m\u0171k\u00f6d\u00e9s\u00e9t, mert nem egy dologra f\u00f3kusz\u00e1l.</li> <li>Ha b\u00e1rmelyik felel\u0151ss\u00e9g ment\u00e9n is j\u00f6n be v\u00e1ltoz\u00e1si ig\u00e9ny, egy nagy, sok mindennel foglalkoz\u00f3 oszt\u00e1lyt kell v\u00e1ltoztatni \u00e9s \u00fajra tesztelni.</li> </ul> </li> <li> <p>A megold\u00e1shoz lehet \u00edrni automatiz\u00e1lt integr\u00e1ci\u00f3s (input-output) teszteket, de \"igazi\" egys\u00e9gteszteket nem. Arra  majd k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza, hogyan kell ezt \u00e9rtelmezni.</p> </li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#3-megoldas-organizedtofunctions-2-twoalgorithms","title":"3. Megold\u00e1s (OrganizedToFunctions-2-TwoAlgorithms)","text":"<p>A kor\u00e1bbi \"tervekkel\" ellent\u00e9tben \u00faj felhaszn\u00e1l\u00f3i ig\u00e9nyek mer\u00fcltek fel. Az \u00fcgyfel\u00fcnk meggondolta mag\u00e1t, egy m\u00e1sik adathalmazn\u00e1l m\u00e1sf\u00e9le anonimiz\u00e1l\u00f3 algoritmus megval\u00f3s\u00edt\u00e1s\u00e1t k\u00e9ri: a szem\u00e9lyek \u00e9letkor\u00e1t kell s\u00e1vosan menteni, nem der\u00fclhet ki a szem\u00e9lyek pontos \u00e9letkora. Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben ez esetben a szem\u00e9lyek nev\u00e9t nem fogjuk anonimiz\u00e1lni, \u00edgy tekints\u00fck ezt egyfajta \"pszeudo\" anonimiz\u00e1l\u00e1snak (ett\u0151l m\u00e9g lehet \u00e9rtelme, csak nem teljesen korrekt ezt anonimiz\u00e1l\u00e1snak nevezni).</p> <p>A megold\u00e1sunkat - mely egyar\u00e1nt t\u00e1mogatja a r\u00e9gi \u00e9s az \u00faj algoritmust (egyszerre csak az egyiket) - a VS solution OrganizedToFunctions-2-TwoAlgorithms nev\u0171 projektj\u00e9ben tal\u00e1ljuk. N\u00e9zz\u00fcnk r\u00e1 az <code>Anonymizer</code> oszt\u00e1lyra, a megold\u00e1s alapelve (ezeket tekints\u00fck \u00e1t a k\u00f3dban):</p> <ul> <li>Bevezett\u00fcnk egy <code>AnonymizerMode</code> enum t\u00edpust, mely meghat\u00e1rozza, hogy melyik \u00fczemm\u00f3dban (algoritmussal) haszn\u00e1ljuk az <code>Anonymizer</code> oszt\u00e1lyt.</li> <li>Az <code>Anonymizer</code> oszt\u00e1lynak k\u00e9t anonimiz\u00e1l\u00f3 m\u0171velete van: <code>Anonymize_MaskName</code>, <code>Anonymize_AgeRange</code></li> <li>Az <code>Anonymizer</code> oszt\u00e1ly a <code>_anonymizerMode</code> tagj\u00e1ban t\u00e1rolja, melyik algoritmust kell haszn\u00e1lni: a k\u00e9t \u00fczemm\u00f3dhoz k\u00e9t k\u00fcl\u00f6n konstruktort vezett\u00fcnk be, ezek \u00e1ll\u00edtj\u00e1k be az <code>_anonymizerMode</code> \u00e9rt\u00e9k\u00e9t.</li> <li>Az <code>Anonymizer</code> oszt\u00e1ly t\u00f6bb helyen is megvizsg\u00e1lja (pl. <code>Run</code>, <code>GetAnonymizerDescription</code> m\u0171veletek), hogy mi az <code>_anonymizerMode</code> \u00e9rt\u00e9ke, \u00e9s ennek f\u00fcggv\u00e9ny\u00e9ben el\u00e1gazik.</li> <li>A <code>GetAnonymizerDescription</code>-ben az\u00e9rt kell ezt megtenni, mert ennek a m\u0171veletnek a feladata az anonimiz\u00e1l\u00f3 algoritmusr\u00f3l egy egysoros le\u00edr\u00e1s el\u0151\u00e1ll\u00edt\u00e1sa, melyet a feldolgoz\u00e1s v\u00e9g\u00e9n a \"summary\"-ben megjelen\u00edt. N\u00e9zz\u00fcnk r\u00e1 a <code>PintSummary</code> k\u00f3dj\u00e1ra, ez a m\u0171velet h\u00edvja.</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-ertekelese_1","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>\u00d6sszeg\u00e9sz\u00e9ben megold\u00e1sunk k\u00f3dmin\u0151s\u00e9g tekintet\u00e9ben a kor\u00e1bbin\u00e1l rosszabb lett. Kor\u00e1bban nem volt probl\u00e9ma, hogy anonimiz\u00e1l\u00f3 algoritmusok tekintet\u00e9ben nem volt kiterjeszthet\u0151 (hiszen nem volt r\u00e1 ig\u00e9ny), de ha m\u00e1r egyszer felmer\u00fclt az ig\u00e9ny \u00faj algoritmus bevezet\u00e9s\u00e9re, akkor hiba ebben a tekintetben nem kiterjeszthet\u0151v\u00e9 tenni: ett\u0151l kezdve sokkal ink\u00e1bb sz\u00e1m\u00edtunk arra, hogy \u00fajabb algoritmusokat kell bevezetni a j\u00f6v\u0151ben.</p> <p>Mi\u00e9rt \u00e1ll\u00edtjuk azt, hogy a k\u00f3dunk nem kiterjeszthet\u0151, amikor \"csak\" egy \u00faj enum \u00e9rt\u00e9ket, \u00e9s egy-egy plusz <code>if</code>/<code>switch</code> \u00e1gat kell a k\u00f3d n\u00e9h\u00e1ny pontj\u00e1ra bevezetni, amikor \u00faj algoritmust kell majd bevezetni?</p> <ul> <li> Open/Closed principle Kulcsfontoss\u00e1g\u00fa, hogy egy k\u00f3dot (oszt\u00e1lyt) akkor tekint\u00fcnk kiterjeszthet\u0151nek, ha annak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl, puszt\u00e1n a k\u00f3d b\u0151v\u00edt\u00e9s\u00e9vel lehet \u00faj viselked\u00e9st (eset\u00fcnkben \u00faj algoritmust) bevezetni. Vagyis eset\u00fcnkben az <code>Anonymizer</code> k\u00f3dj\u00e1hoz nem szabadna hozz\u00e1ny\u00falni, ami egy\u00e9rtelm\u0171en nem teljes\u00fcl. Ez a h\u00edres Open/Closed principle/elv: the class should be Open for Extension, Closed for Modification. A k\u00f3d m\u00f3dos\u00edt\u00e1sa az\u00e9rt probl\u00e9ma, mert annak sor\u00e1n j\u00f3 es\u00e9llyel \u00faj bugokat vezet\u00fcnk be, ill. a m\u00f3dos\u00edtott k\u00f3dot mindig \u00fajra kell tesztelni, ez pedig jelent\u0151s id\u0151/k\u00f6lts\u00e9gr\u00e1ford\u00edt\u00e1si ig\u00e9nyt jelenthet.</li> </ul> <p>Mi is a pontos c\u00e9l, \u00e9s hogyan \u00e9rtj\u00fck ezt el? Vannak olyan r\u00e9szek az oszt\u00e1lyunkban, melyeket nem szeretn\u00e9nk be\u00e9getni:</p> <ul> <li>Ezek nem adatok, hanem viselked\u00e9sek (k\u00f3d, logika).</li> <li>Nem <code>if</code>/<code>switch</code> utas\u00edt\u00e1sokkal oldjuk meg: \"kiterjeszt\u00e9si pontokat\" vezet\u00fcnk be, \u00e9s valamilyen m\u00f3don megoldjuk, hogy ezekben \"tetsz\u0151leges\" k\u00f3d lefuthasson.</li> <li>Ezek v\u00e1ltoz\u00f3/esetf\u00fcgg\u0151 r\u00e9szek k\u00f3dj\u00e1t m\u00e1s oszt\u00e1lyokba tessz\u00fck (az oszt\u00e1lyunk szempontj\u00e1b\u00f3l \"lecser\u00e9lhet\u0151\" m\u00f3don)!</li> </ul> <p>Note</p> <p>Ne gondoljunk semmif\u00e9le var\u00e1zslatra, a m\u00e1r ismert eszk\u00f6z\u00f6ket fogjuk erre haszn\u00e1lni: \u00f6r\u00f6kl\u00e9st absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekkel, vagy interf\u00e9szeket, vagy delegate-eket.</p> <p>Keress\u00fck meg azokat a r\u00e9szeket, melyek esetf\u00fcgg\u0151, v\u00e1ltoz\u00f3 logik\u00e1k, \u00edgy nem j\u00f3 be\u00e9getni az <code>Anonymizer</code> oszt\u00e1lyba:</p> <ul> <li>Az egyik maga az anonimiz\u00e1l\u00e1si logika: <code>Anonymize_MaskName</code>/<code>Anonymize_AgeRange</code></li> <li>A m\u00e1sik a <code>GetAnonymizerDescription</code></li> </ul> <p>Ezeket kell lev\u00e1lasztani az oszt\u00e1lyr\u00f3l, ezekben a pontokban kell kiterjeszthet\u0151v\u00e9 tenni az oszt\u00e1lyt. Az al\u00e1bbi \u00e1bra illusztr\u00e1lja a c\u00e9lt \u00e1ltal\u00e1noss\u00e1g\u00e1ban *:</p> Az \u00e1ltal\u00e1nos megold\u00e1si elv illusztr\u00e1l\u00e1sa <p></p> <p>A labor keret\u00e9ben h\u00e1rom konkr\u00e9t tervez\u00e9si mint\u00e1t, ill. technik\u00e1t n\u00e9z\u00fcnk meg a fentiek megval\u00f3s\u00edt\u00e1s\u00e1ra:</p> <ul> <li>Template Method tervez\u00e9si minta</li> <li>Strategy tervez\u00e9si minta</li> <li>Delegate (opcion\u00e1lisan Lambda kifejez\u00e9ssel)</li> </ul> <p>Val\u00f3j\u00e1ban mind haszn\u00e1ltuk m\u00e1r a tanulm\u00e1nyaink sor\u00e1n, de most m\u00e9lyebben megismerked\u00fcnk vel\u00fck, \u00e9s \u00e1tfog\u00f3bban be fogjuk gyakorolni ezek alkalmaz\u00e1s\u00e1t.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#4-megoldas-3-templatemethodtemplatemethod-1","title":"4. Megold\u00e1s (3-TemplateMethod/TemplateMethod-1)","text":"<p>Ebben a l\u00e9p\u00e9sben a Template Method tervez\u00e9si minta alkalmaz\u00e1s\u00e1val fogjuk a megold\u00e1sunkat a sz\u00fcks\u00e9ges pontokban kiterjeszthet\u0151v\u00e9 tenni.</p> <p>Note</p> <p>A minta neve \"megt\u00e9veszt\u0151\": semmi k\u00f6ze nincs a C++-ban tanult sablonmet\u00f3dusokhoz!</p> Template Method alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Template Method alap\u00fa megold\u00e1st, a l\u00e9nyegre f\u00f3kusz\u00e1lva:</p> <p></p> <p>A mint\u00e1ban a k\u00f6vetkez\u0151 elvek ment\u00e9n val\u00f3sul meg a \"v\u00e1ltozatlan\" \u00e9s \"v\u00e1ltoz\u00f3\" r\u00e9szek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa (\u00e9rdemes a fenti oszt\u00e1lydiagram alapj\u00e1n - a p\u00e9ld\u00e1nkra vet\u00edtve - ezeket meg\u00e9rteni):</p> <ul> <li>A \"k\u00f6z\u00f6s/v\u00e1ltozatlan\" r\u00e9szeket egy \u0151soszt\u00e1lyba tessz\u00fck.</li> <li>Ebben a kiterjeszt\u00e9si pontokat absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyek bevezet\u00e9se jelenti, ezeket h\u00edvjuk a kiterjeszt\u00e9si pontokban.</li> <li>Ezek esetf\u00fcgg\u0151 megval\u00f3s\u00edt\u00e1sa a lesz\u00e1rmazott oszt\u00e1lyokba ker\u00fcl.</li> </ul> <p>A j\u00f3l ismert \"tr\u00fckk\" a dologban az, hogy amikor az \u0151s megh\u00edvja az absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyeket, akkor a lesz\u00e1rmazottb\u00e9li, esetf\u00fcgg\u0151 k\u00f3d h\u00edv\u00f3dik meg.</p> <p>Alak\u00edtsuk \u00e1t a kor\u00e1bbi <code>if</code>/<code>switch</code> alap\u00fa megold\u00e1st Template Method alap\u00fara. Egy \u0151soszt\u00e1lyt \u00e9s k\u00e9t, algoritmusf\u00fcgg\u0151 lesz\u00e1rmazottat vezet\u00fcnk be.</p> <p>Alak\u00edtsuk \u00e1t a k\u00f3dunkat ennek megfelel\u0151en. A VS solution-ben a \"3-TemplateMethod\" mapp\u00e1ban a \"TemplateMethod-0-Begin\" projekt tartalmazza a kor\u00e1bbi megold\u00e1sunk k\u00f3dj\u00e1t (annak \"m\u00e1solat\u00e1t\"), ebben a projektben dolgozzunk:</p> <ol> <li>Nevezz\u00fck \u00e1t az <code>Anonymizer</code> oszt\u00e1lyt <code>AnonymizerBase</code>-re (pl. az oszt\u00e1ly nev\u00e9re \u00e1llva a forr\u00e1sf\u00e1jlban \u00e9s F2-t nyomva).</li> <li>Vegy\u00fcnk fel az projektbe egy <code>NameMaskingAnonymizer</code> \u00e9s egy <code>AgeAnonymizer</code> oszt\u00e1lyt (projekten jobb katt, Add/Class).</li> <li>Sz\u00e1rmaztassuk az <code>AnonymizerBase</code>-b\u0151l \u0151ket</li> <li>Az <code>AnonymizerBase</code>-b\u0151l mozgassuk \u00e1t a <code>NameMaskingAnonymizer</code>-be az ide tartoz\u00f3 r\u00e9szeket:<ol> <li>A <code>_mask</code> tagv\u00e1ltoz\u00f3t.</li> <li>A <code>string inputFileName, string mask</code> param\u00e9terez\u00e9s\u0171 konstruktort, \u00e1tnevezve <code>NameMaskingAnonymizer</code>-re,<ol> <li><code>_anonymizerMode = AnonymizerMode.Name;</code> sort t\u00f6r\u00f6lve,</li> <li>a <code>this</code> konstruktorh\u00edv\u00e1s helyett <code>base</code> konstruktorh\u00edv\u00e1ssal.</li> </ol> </li> </ol> </li> <li>Az <code>AnonymizerBase</code>-b\u0151l mozgassuk \u00e1t az <code>AgeAnonymizer</code>-be az ide tartoz\u00f3 r\u00e9szeket:</li> <li>A <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t.</li> <li>A <code>string inputFileName, string rangeSize</code> param\u00e9terez\u00e9s\u0171 konstruktort, \u00e1tnevezve <code>AgeAnonymizer</code>-re,<ol> <li><code>_anonymizerMode = AnonymizerMode.Name;</code> sort t\u00f6r\u00f6lve,</li> <li>a <code>this</code> konstruktorh\u00edv\u00e1s helyett <code>base</code> konstruktorh\u00edv\u00e1ssal.</li> </ol> </li> <li>Az <code>AnonymizerBase</code>-ben:<ol> <li>T\u00f6r\u00f6lj\u00fck az <code>AnonymizerMode</code> enum t\u00edpust.</li> <li>T\u00f6r\u00f6lj\u00fck a <code>_anonymizerMode</code> tagot.</li> </ol> </li> </ol> <p>Keress\u00fck meg azokat a r\u00e9szeket, melyek esetf\u00fcgg\u0151, v\u00e1ltoz\u00f3 logik\u00e1k, \u00edgy nem akarjuk be\u00e9getni az \u00fajrafelhaszn\u00e1lhat\u00f3nak sz\u00e1nt <code>AnonymizerBase</code> oszt\u00e1lyba:</p> <ul> <li>Az egyik az <code>Anonymize_MaskName</code>/<code>Anonymize_AgeRange</code>,</li> <li>a m\u00e1sik a <code>GetAnonymizerDescription</code>.</li> </ul> <p>A mint\u00e1t k\u00f6vetve ezekre az \u0151sben absztrakt (vagy esetleg virtu\u00e1lis) f\u00fcggv\u00e9nyeket vezet\u00fcnk be, \u00e9s ezeket h\u00edvjuk, az esetf\u00fcgg\u0151 implement\u00e1ci\u00f3ikat pedig a lesz\u00e1rmazott oszt\u00e1lyokba tessz\u00fck (override):</p> <ol> <li>Tegy\u00fck az <code>AnonymizerBase</code> oszt\u00e1ly absztraktt\u00e1 (a <code>class</code> el\u00e9 <code>abstract</code> kulcssz\u00f3)</li> <li> <p>Vezess\u00fcnk be az <code>AnonymizerBase</code>-ben egy</p> <pre><code>protected abstract Person Anonymize(Person person);\n</code></pre> <p>m\u0171veletet.</p> </li> <li> <p>Az <code>Anonymize_MaskName</code> m\u0171veletet mozgassuk \u00e1t a <code>NameMaskingAnonymizer</code> oszt\u00e1lyba, \u00e9s alak\u00edtsuk \u00e1t a szignat\u00far\u00e1j\u00e1t \u00fagy, hogy override-olja az \u0151sbeli <code>Anonymize</code> absztrakt f\u00fcggv\u00e9nyt:</p> <pre><code>protected override Person Anonymize(Person person)\n{\n    return new Person(_mask, _mask, person.CompanyName,\n        person.Address, person.City, person.State, person.Age, person.Weight, person.Decease);\n}\n</code></pre> <p>A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a megsz\u00fcntetett <code>mask</code> param\u00e9tert, hanem a <code>_mask</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja.</p> </li> <li> <p>Az el\u0151z\u0151 l\u00e9p\u00e9ssel teljesen anal\u00f3g m\u00f3don az <code>Anonymize_AgeRange</code> m\u0171veletet mozgassuk \u00e1t a <code>AgeAnonymizer</code> oszt\u00e1lyba, \u00e9s alak\u00edtsuk \u00e1t a szignat\u00far\u00e1j\u00e1t \u00fagy, hogy override-olja az \u0151sbeli <code>Anonymize</code> absztrakt f\u00fcggv\u00e9nyt:</p> <pre><code>protected override Person Anonymize(Person person)\n{\n    ...\n}\n</code></pre> <p>A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a megsz\u00fcntetett <code>rangeSize</code> param\u00e9tert, hanem a <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja.</p> </li> <li> <p>A <code>AnonymizerBase</code> oszt\u00e1ly <code>Run</code> f\u00fcggv\u00e9ny\u00e9ben az <code>if</code>/<code>else</code> kifejez\u00e9sben tal\u00e1lhat\u00f3 <code>Anonymize</code> h\u00edv\u00e1sokat most m\u00e1r le tudjuk cser\u00e9lni egy egyszer\u0171 absztrakt f\u00fcggv\u00e9ny h\u00edv\u00e1sra:</p> <pre><code>Person person;\nif (_anonymizerMode == AnonymizerMode.Name)\n    person = Anonymize_MaskName(persons[i], _mask);\nelse if (_anonymizerMode == AnonymizerMode.Age)\n    person = Anonymize_AgeRange(persons[i], _rangeSize);\nelse\n    throw new NotSupportedException(\"The requested anonymization mode is not supported.\");\n</code></pre> <p>helyett:</p> <pre><code>var person = Anonymize(persons[i]);\n</code></pre> </li> </ol> <p>Az egyik kiterjeszt\u00e9si pontunkkal el is k\u00e9sz\u00fclt\u00fcnk. De maradt m\u00e9g egy, a <code>GetAnonymizerDescription</code>, mely kezel\u00e9se szint\u00e9n esetf\u00fcgg\u0151. Ennek \u00e1talak\u00edt\u00e1sa nagyon hasonl\u00f3 az el\u0151z\u0151 l\u00e9p\u00e9ssorozathoz. Id\u0151 hi\u00e1ny\u00e1ban ezt az \u00e1talak\u00edt\u00e1st gyakorlaton nem tessz\u00fck meg (lehet otthoni gyakorl\u00f3 feladat), hanem a k\u00e9sz megold\u00e1sra ugrunk: ezt a \"TemplateMethod-1\" nev\u0171 projektben tal\u00e1ljuk. Fussuk \u00e1t a megold\u00e1s alapelemeit:</p> <ol> <li>Az <code>AnonymizerBase</code>-ben a <code>GetAnonymizerDescription</code> nem absztrakt, hanem virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt ker\u00fclt bevezet\u00e9sre, hiszen itt tudtunk \u00e9rtelmes alap\u00e9rtelmezett viselked\u00e9st biztos\u00edtani: egyszer\u0171en visszaadjuk az oszt\u00e1ly nev\u00e9t (mely pl. a <code>NameMaskingAnonymizer</code> oszt\u00e1ly eset\u00e9ben \"NameMaskingAnonymizer\"). Mindenesetre a rugalmatlan <code>switch</code> szerkezett\u0151l megszabadultunk.</li> <li>A lesz\u00e1rmazottakban fel\u00fcl\u00edrjuk ezt a virtu\u00e1lis f\u00fcggv\u00e9nyt, belef\u0171zz\u00fck a le\u00edr\u00e1sba az oszt\u00e1lyspecifikus adatokat (pl.<code>NameMaskingAnonymizer</code> eset\u00e9ben a <code>_mask</code> \u00e9rt\u00e9k\u00e9t).</li> </ol> <p>A \"TemplateMethod-0-Begin\" projekt\u00fcnk most nem fordul\u00f3 k\u00f3dot tartalmaz, ezt c\u00e9lszer\u0171 elt\u00e1vol\u00edtani a solution-b\u0151l, hogy a k\u00e9s\u0151bbi futtat\u00e1sok sor\u00e1n ne legyen zavar\u00f3: jobb katt a projekten \u00e9s <code>Remove</code> men\u00fc (ez fizikailag nem t\u00f6rli, csak kiveszi a solution-b\u0151l, k\u00e9s\u0151bb visszatehet\u0151).</p> <p>El is k\u00e9sz\u00fclt\u00fcnk. Ha sok id\u0151nk van, ki is pr\u00f3b\u00e1lhatjuk, hogy jobban \"\u00e9rezz\u00fck\", val\u00f3ban m\u0171k\u00f6dnek az kiterjeszt\u00e9si pontok (de ez k\u00fcl\u00f6n\u00f6sebben nem fontos, hasonl\u00f3t m\u00e1r kor\u00e1bbi f\u00e9l\u00e9vekben C++/Java nyelvek kontextus\u00e1ban is csin\u00e1ltunk):</p> <ul> <li>Legyen a \"TemplateMethod-1\" projekt a startup projekt.</li> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot az <code>AnonymizerBase</code> oszt\u00e1ly <code>var person = Anonymize(persons[i]);</code> sor\u00e1ra.</li> <li>Amikor fut\u00e1s k\u00f6zben itt meg\u00e1ll a debugger, ++F11++-gyel l\u00e9pj\u00fcnk bele.</li> <li>Az tapasztaljuk, hogy a  lesz\u00e1rmazott <code>AgeAnonymizer</code> m\u0171velete h\u00edv\u00f3dik.</li> </ul> <p>Vethet\u00fcnk egy pillant\u00e1st a megold\u00e1s oszt\u00e1lydiagramj\u00e1ra:</p> Template Method alap\u00fa megold\u00e1s oszt\u00e1lydiagram * <p></p> Mi\u00e9rt Template Method a minta neve * <p>A minta az\u00e9rt kapta a Template Method nevet, mert - eset\u00fcnket p\u00e9ldak\u00e9nt haszn\u00e1lva - a <code>Run</code> \u00e9s a <code>PrintSummary</code> olyan \"sablon met\u00f3dusok\", melyek meghat\u00e1roznak egy sablonszer\u0171 logik\u00e1t, v\u00e1zat, melyben bizonyos l\u00e9p\u00e9sek nincsenek megk\u00f6tve (ezek \"k\u00f3dj\u00e1t\" absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekre b\u00edzzuk, \u00e9s a lesz\u00e1rmazott oszt\u00e1lyok hat\u00e1rozz\u00e1k meg a megval\u00f3s\u00edt\u00e1sukat).</p>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-ertekelese_2","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>Ellen\u0151rizz\u00fck a megold\u00e1st, megval\u00f3s\u00edtja-e a c\u00e9ljainkat:</p> <ul> <li>Az <code>AnonymizerBase</code> egy \u00fajrafelhaszn\u00e1lhat\u00f3(bb) oszt\u00e1ly lett.</li> <li>Ha \u00faj anonimiz\u00e1l\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak sz\u00e1rmaztatunk bel\u0151le. Ez nem m\u00f3dos\u00edt\u00e1s, hanem b\u0151v\u00edt\u00e9s.</li> <li>Ennek megfelel\u0151en teljes\u00fcl az OPEN/CLOSED elv, vagyis a k\u00f3dj\u00e1nak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl tudjuk az \u0151sben megadott k\u00e9t pontban a logik\u00e1t testre szabni, kiterjeszteni.</li> </ul> <p>Legyen minden pontban kiterjeszthet\u0151 az oszt\u00e1lyunk?</p> <p>Figyelj\u00fck meg, hogy nem tett\u00fcnk az <code>AnonymizerBase</code> minden m\u0171velet\u00e9t virtu\u00e1liss\u00e1 (\u00edgy sok pontban kiterjeszthet\u0151v\u00e9 az oszt\u00e1lyt). Csak ott tett\u00fck meg, ahogy azt gondoljuk, hogy a j\u00f6v\u0151ben sz\u00fcks\u00e9g lehet a logika kiterjeszt\u00e9s\u00e9re.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#5-megoldas-3-templatemethodtemplatemethod-2-progress","title":"5. Megold\u00e1s (3-TemplateMethod/TemplateMethod-2-Progress)","text":"<p>T.f.h \u00faj - viszonylag egyszer\u0171 - ig\u00e9ny mer\u00fcl fel:</p> <ul> <li>A <code>NameMaskinAnonimizer</code> eset\u00e9n marad ugyan a kor\u00e1bbi progress kijelz\u00e9s (minden sor ut\u00e1n ki\u00edrjuk, h\u00e1nyadikn\u00e1l tartottunk),</li> <li> <p>de az <code>AgeAnonymizer</code> eset\u00e9n a progress kijelz\u00e9s m\u00e1s kell legyen: azt kell ki\u00edrni - minden sor ut\u00e1n friss\u00edtve -, hogy h\u00e1ny sz\u00e1zal\u00e9kn\u00e1l tart a feldolgoz\u00e1s.</p> Sz\u00e1zal\u00e9kos progress illusztr\u00e1l\u00e1sa <p> (Mivel jelenleg kev\u00e9s az adat, ezt a megold\u00e1sunk v\u00e9g\u00e9n nem \u00edgy l\u00e1tjuk majd, pillanatok alatt 100%-ra ugrik)</p> </li> </ul> <p>A megold\u00e1s nagyon egyszer\u0171: a <code>Run</code> m\u0171veletben sz\u00e9lesebb k\u00f6rben alkalmazva a Template Method mint\u00e1t, a progress ki\u00edr\u00e1skor is egy kiterjeszt\u00e9si pontot vezet\u00fcnk be, egy virtu\u00e1lis f\u00fcggv\u00e9nyre b\u00edzzuk a megval\u00f3s\u00edt\u00e1st.</p> <p>Ugorjunk egyb\u0151l a k\u00e9sz megold\u00e1sra (TemplateMethod-2-Progress projekt):</p> <ul> <li><code>AnonymizerBase</code> oszt\u00e1lyban \u00faj <code>PrintProgress</code> virtu\u00e1lis f\u00fcggv\u00e9ny (alap\u00e9rtelmez\u00e9sben nem \u00edr ki semmit)</li> <li><code>Run</code>-ban ennek h\u00edv\u00e1sa</li> <li><code>NameMaskingAnonymizer</code>-ben \u00e9s <code>NameMaskingAnonymizer</code>-ben megfelel\u0151 megval\u00f3s\u00edt\u00e1s (override)</li> </ul> <p>Ennek egyel\u0151re k\u00fcl\u00f6n\u00f6sebb tanuls\u00e1ga nincs, de a k\u00f6vetkez\u0151 l\u00e9p\u00e9sben m\u00e1r lesz.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#6-megoldas-3-templatemethodtemplatemethod-3-progressmultiple","title":"6. Megold\u00e1s (3-TemplateMethod/TemplateMethod-3-ProgressMultiple)","text":"<p>\u00daj - \u00e9s teljesen logikus - ig\u00e9ny mer\u00fclt fel: a j\u00f6v\u0151ben b\u00e1rmely anonimiz\u00e1l\u00f3 algoritmust b\u00e1rmely progress megjelen\u00edt\u00e9ssel lehessen haszn\u00e1lni. Ez jelen pillanatban n\u00e9gy keresztkombin\u00e1ci\u00f3t jelent:</p> Anonimiz\u00e1l\u00f3 Progress N\u00e9v anonimiz\u00e1l\u00f3 Egyszer\u0171 progress N\u00e9v anonimiz\u00e1l\u00f3 Sz\u00e1zal\u00e9k progress Kor anonimiz\u00e1l\u00f3 Egyszer\u0171 progress Kor anonimiz\u00e1l\u00f3 Sz\u00e1zal\u00e9k progress <p>Ugorjunk a k\u00e9sz megold\u00e1sra (TemplateMethod-3-ProgressMultiple projekt). K\u00f3d helyett \u00e9rdemes a <code>Main.cd</code> oszt\u00e1lydiagramot megnyitni, \u00e9s a megold\u00e1st az alapj\u00e1n \u00e1ttekinteni.</p> Template Method alap\u00fa megold\u00e1s (k\u00e9t aspektus) oszt\u00e1lydiagram <p></p> <p>\u00c9rezhet\u0151, hogy valami \"baj van\", minden keresztkombin\u00e1ci\u00f3nak k\u00fcl\u00f6n lesz\u00e1rmazottat kellett l\u00e9trehozni. S\u0151t, a k\u00f3dduplik\u00e1ci\u00f3 cs\u00f6kkent\u00e9s\u00e9re m\u00e9g plusz, k\u00f6ztes oszt\u00e1lyok is vannak a hierarchi\u00e1ban. R\u00e1ad\u00e1sul:</p> <ul> <li>Ha a j\u00f6v\u0151ben \u00faj anonimiz\u00e1l\u00f3 algoritmust vezet\u00fcnk be, annyi \u00faj oszt\u00e1lyt kell \u00edrni (legal\u00e1bb), ah\u00e1ny progress t\u00edpust t\u00e1mogatunk.</li> <li>Ha a j\u00f6v\u0151ben \u00faj progress t\u00edpust vezet\u00fcnk be, annyi \u00faj oszt\u00e1lyt kell \u00edrni (legal\u00e1bb), ah\u00e1ny anonimiz\u00e1l\u00f3 t\u00edpust t\u00e1mogatunk.</li> </ul> <p>Mi okozta a probl\u00e9m\u00e1t? Az, hogy az oszt\u00e1lyunk viselked\u00e9s\u00e9t t\u00f6bb aspektus/dimenzi\u00f3 ment\u00e9n (p\u00e9ld\u00e1nkban az anonimiz\u00e1l\u00e1s \u00e9s progress) kell kiterjeszthet\u0151v\u00e9 tenni, \u00e9s ezeket sok keresztkombin\u00e1ci\u00f3ban kell t\u00e1mogatni. Ha \u00fajabb aspektusok ment\u00e9n kellene ezt megtenni (pl. beolvas\u00e1s m\u00f3dja, kimenet gener\u00e1l\u00e1sa), akkor a probl\u00e9ma exponenci\u00e1lisan tov\u00e1bb \"robbanna\". Ilyen esetekben a Template Method tervez\u00e9si minta nem alkalmazhat\u00f3.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#7-megoldas-4-strategystrategy-1","title":"7. Megold\u00e1s (4-Strategy/Strategy-1)","text":"<p>Ebben a l\u00e9p\u00e9sben a Strategy tervez\u00e9si minta alkalmaz\u00e1s\u00e1val fogjuk a kezdeti megold\u00e1sunkat a sz\u00fcks\u00e9ges pontokban kiterjeszthet\u0151v\u00e9 tenni. A mint\u00e1ban a k\u00f6vetkez\u0151 elvek ment\u00e9n val\u00f3sul meg a \"v\u00e1ltozatlan/\u00fajrafelhaszn\u00e1lhat\u00f3\" \u00e9s \"v\u00e1ltoz\u00f3\" r\u00e9szek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa:</p> <ul> <li>A \"k\u00f6z\u00f6s/v\u00e1ltozatlan\" r\u00e9szeket egy adott oszt\u00e1lyba tessz\u00fck (de ez most nem egy \"\u0151soszt\u00e1ly\" lesz).</li> <li>A Template Methoddal szemben nem \u00f6r\u00f6kl\u00e9st, hanem kompoz\u00edci\u00f3t (tartalmaz\u00e1st) alkalmazunk: interf\u00e9szk\u00e9nt tartalmazott m\u00e1s objektumokra b\u00edzzuk a viselked\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1t a kiterjeszt\u00e9si pontokban (\u00e9s nem absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekre).</li> <li>Mindezt az oszt\u00e1ly viselked\u00e9s\u00e9nek minden olyan aspektus\u00e1ra/dimenzi\u00f3j\u00e1ra, melyet lecser\u00e9lhet\u0151v\u00e9/b\u0151v\u00edthet\u0151v\u00e9 szeretn\u00e9nk tenni, egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl megtessz\u00fck. Ezzel az el\u0151z\u0151 fejezetben tapasztalt kombinatorikus robban\u00e1s elker\u00fclhet\u0151.</li> </ul> <p>Ez sokkal egyszer\u0171bb a gyakorlatban, mint amilyennel le\u00edrva \u00e9rz\u0151dik (m\u00e1r haszn\u00e1ltuk is p\u00e1rszor kor\u00e1bbi tanulm\u00e1nyaink sor\u00e1n), \u00e9rts\u00fck meg a p\u00e9ld\u00e1nkra vet\u00edtve.</p> <p>A k\u00f6vetkez\u0151kben tekints\u00fck \u00e1t a Strategy alap\u00fa megold\u00e1st illusztr\u00e1l\u00f3 oszt\u00e1lydiagramot, a diagramot k\u00f6vet\u0151 magyar\u00e1zatra \u00e9p\u00edtve.</p> Strategy alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Strategy alap\u00fa megold\u00e1st, a l\u00e9nyegre f\u00f3kusz\u00e1lva:</p> <p></p> <p>A Strategy minta alkalmaz\u00e1s\u00e1nak els\u0151 l\u00e9p\u00e9se, hogy meghat\u00e1rozzuk, az oszt\u00e1ly viselked\u00e9s\u00e9nek h\u00e1ny k\u00fcl\u00f6nb\u00f6z\u0151 aspektusa van, melyet kiterjeszthet\u0151v\u00e9 szeretn\u00e9nk tenni. A p\u00e9ld\u00e1nkban ebb\u0151l - egyel\u0151re legal\u00e1bbis - kett\u0151 van:</p> <ul> <li>Anonimiz\u00e1l\u00e1shoz k\u00f6t\u0151d\u0151 viselked\u00e9s, melyhez k\u00e9t m\u0171velet tartozik:<ul> <li>Anonimiz\u00e1l\u00f3 logika</li> <li>Anonimiz\u00e1l\u00f3 logika le\u00edr\u00e1s\u00e1nak meghat\u00e1roz\u00e1sa (description)</li> </ul> </li> <li>Progress kezel\u00e9s, melyhez egy m\u0171velet tartozik:<ul> <li>Progress megjelen\u00edt\u00e9se</li> </ul> </li> </ul> <p>A nehez\u00e9vel meg is vagyunk, ett\u0151l kezdve alapvet\u0151en mechanikusan lehet dolgozni a Strategy mint\u00e1t k\u00f6vetve:</p> <ol> <li>A fenti aspektusok mindegyik\u00e9hez egy-egy strategy interf\u00e9szt kell bevezetni, a fent meghat\u00e1rozott m\u0171veletekkel, \u00e9s ezekhez el kell k\u00e9sz\u00edteni a megfelel\u0151 implement\u00e1ci\u00f3kat.</li> <li>Az Anonymizer oszt\u00e1lyba be kell vezetni egy-egy strategy interf\u00e9sz tagv\u00e1ltoz\u00f3t, \u00e9s a kiterjeszt\u00e9si pontokban ezen tagv\u00e1ltoz\u00f3kon kereszt\u00fcl haszn\u00e1lni az aktu\u00e1lisan be\u00e1ll\u00edtott strategy implement\u00e1ci\u00f3s objektumokat.</li> </ol> <p>A fenti oszt\u00e1lydiagramon meg is jelennek ezek az elemek. Most t\u00e9rj\u00fcnk \u00e1t a k\u00f3dra. Kiindul\u00f3 k\u00f6rnyezet\u00fcnk a \"4-Strategy\" mapp\u00e1ban a \"Strategy-0-Begin\" projektben tal\u00e1lhat\u00f3, ebben dolgozzunk. Ez ugyanaz, az enum-ot haszn\u00e1l\u00f3 megold\u00e1s, mint amelyet a Template Method minta eset\u00e9ben is kiindul\u00e1sk\u00e9nt haszn\u00e1ltunk. </p> <p>Az anonimiz\u00e1l\u00e1si strat\u00e9gia/aspektus kezel\u00e9s\u00e9vel kezd\u00fcnk: vezess\u00fck be az ehhez tartoz\u00f3 interf\u00e9szt \u00e9s implement\u00e1ci\u00f3kat:</p> <ol> <li>Hozzunk l\u00e9tre a projektben egy <code>AnonymizerAlgorithms</code> nev\u0171 mapp\u00e1t (jobb katt a \"Strategy-0-Begin\" projekten, majd Add/New Folder men\u00fc). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben minden interf\u00e9szt \u00e9s oszt\u00e1lyt egy k\u00fcl\u00f6n, a nev\u00e9nek megfelel\u0151 forr\u00e1sf\u00e1jlba tegy\u00fcnk a szok\u00e1sos m\u00f3don!</li> <li> <p>Vegy\u00fcnk fel ebben a mapp\u00e1ban egy <code>IAnonymizerAlgorithm</code> interf\u00e9szt az al\u00e1bbi k\u00f3ddal:</p> IAnonymizerAlgorithm.cs<pre><code>public interface IAnonymizerAlgorithm\n{\n    Person Anonymize(Person person);\n    string GetAnonymizerDescription() =&gt; GetType().Name;\n}\n</code></pre> <p>Azt is megfigyelhetj\u00fck a <code>GetAnonymizerDescription</code> m\u0171velet eset\u00e9ben, hogy a modern C# nyelven, amennyiben akarunk, tudunk az egyes interf\u00e9sz m\u0171veleteknek alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni!</p> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek az n\u00e9v anonimiz\u00e1l\u00e1shoz tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba (csak m\u00e1soljuk be az al\u00e1bbi k\u00f3dot \u00e9s \u00e9rtelmezz\u00fck azt):</p> Megold\u00e1s NameMaskingAnonymizerAlgorithm.cs<pre><code>public class NameMaskingAnonymizerAlgorithm: IAnonymizerAlgorithm\n{\n    private readonly string _mask;\n\n    public NameMaskingAnonymizerAlgorithm(string mask)\n    {\n        _mask = mask;\n    }\n\n    public Person Anonymize(Person person)\n    {\n        return new Person(_mask, _mask, person.CompanyName,\n            person.Address, person.City, person.State, person.Age, person.Weight, person.Decease);\n    }\n\n    public string GetAnonymizerDescription()\n    {\n        return $\"NameMasking anonymizer with mask {_mask}\";\n    }\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek az \u00e9letkor anonimiz\u00e1l\u00e1shoz tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba (csak m\u00e1soljuk be az al\u00e1bbi k\u00f3dot \u00e9s \u00e9rtelmezz\u00fck azt):</p> Megold\u00e1s AgeAnonymizerAlgorithm.cs<pre><code>public class AgeAnonymizerAlgorithm: IAnonymizerAlgorithm\n{\n    private readonly int _rangeSize;\n\n    public AgeAnonymizerAlgorithm(int rangeSize)\n    {\n        _rangeSize = rangeSize;\n    }\n\n    public Person Anonymize(Person person)\n    {\n        // This is whole number integer arithmetics, e.g for 55 / 20 we get 2\n        int rangeIndex = int.Parse(person.Age) / _rangeSize;\n        string newAge = $\"{rangeIndex * _rangeSize}..{(rangeIndex + 1) * _rangeSize}\";\n\n        return new Person(person.FirstName, person.LastName, person.CompanyName,\n            person.Address, person.City, person.State, newAge,\n            person.Weight, person.Decease);\n    }\n\n    public string GetAnonymizerDescription()\n    {\n        return $\"Age anonymizer with range size {_rangeSize}\";\n    }\n}\n</code></pre> </li> <li> <p>Fontos gondolat</p> <p>Warning</p> <p>Mindenk\u00e9ppen figyelj\u00fck meg, hogy az interf\u00e9sz \u00e9s a megval\u00f3s\u00edt\u00e1sai kiz\u00e1r\u00f3lag az anonimiz\u00e1l\u00e1ssal foglalkoznak, semmif\u00e9le m\u00e1s logika (pl. progress kezel\u00e9s) nincs itt!</p> </li> </ol> <p>M\u00e1sodik l\u00e9p\u00e9sben vezess\u00fck be a progress kezel\u00e9shez tartoz\u00f3 interf\u00e9szt \u00e9s implement\u00e1ci\u00f3kat:</p> <ol> <li>Hozzunk l\u00e9tre a projektben egy <code>Progresses</code> nev\u0171 mapp\u00e1t. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben minden interf\u00e9szt \u00e9s oszt\u00e1ly egy k\u00fcl\u00f6n, a nev\u00e9nek megfelel\u0151 forr\u00e1sf\u00e1jlba tegy\u00fcnk a szok\u00e1sos m\u00f3don.</li> <li> <p>Vegy\u00fcnk fel ebben a mapp\u00e1ban egy <code>IProgress</code> interf\u00e9szt az al\u00e1bbi k\u00f3ddal:</p> Megold\u00e1s IProgress.cs<pre><code>public interface IProgress\n{\n    void Report(int count, int index);\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek az egyszer\u0171 progresshez tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba:</p> Megold\u00e1s IProgress.cs<pre><code>public class SimpleProgress: IProgress\n{\n    public void Report(int count, int index)\n    {\n        Console.WriteLine($\"{index + 1}. person processed\");\n    }\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek az sz\u00e1zal\u00e9kos progresshez tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba:</p> Megold\u00e1s IProgress.cs<pre><code>public class PercentProgress: IProgress\n{\n    public void Report(int count, int index)\n    {\n        int percentage = (int)((double)(index+1) / count * 100);\n\n        var pos = Console.GetCursorPosition();\n        Console.SetCursorPosition(0, pos.Top);\n\n        Console.Write($\"Processing: {percentage} %\");\n\n        if (index == count - 1)\n            Console.WriteLine();\n    }\n}\n</code></pre> </li> <li> <p>Fontos gondolat</p> <p>Fontos</p> <p>Mindenk\u00e9ppen figyelj\u00fck meg, hogy az interf\u00e9sz \u00e9s a megval\u00f3s\u00edt\u00e1sai kiz\u00e1r\u00f3lag a progress kezel\u00e9ssel foglalkoznak, semmif\u00e9le m\u00e1s logika (pl. anonimiz\u00e1l\u00e1s) nincs itt!</p> </li> </ol> <p>A k\u00f6vetkez\u0151 fontos l\u00e9p\u00e9s az anonimiz\u00e1l\u00f3 alaposzt\u00e1ly \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 \u00e9s kiterjeszthet\u0151v\u00e9 t\u00e9tele a fent bevezetett strategy-k seg\u00edts\u00e9g\u00e9vel. Az <code>Anonymizer.cs</code> f\u00e1jlban:</p> <ol> <li>T\u00f6r\u00f6lj\u00fck a k\u00f6vetkez\u0151ket:<ul> <li><code>AnonymizerMode</code> enum t\u00edpus</li> <li><code>_anonymizerMode</code>, <code>_mask</code> \u00e9s <code>_rangeSize</code> tagok</li> </ul> </li> <li> <p>Vezess\u00fcnk be egy-egy strategy interf\u00e9sz t\u00edpus\u00fa tagot:</p> <pre><code>private readonly IProgress _progress;\nprivate readonly IAnonymizerAlgorithm _anonymizerAlgorithm;\n</code></pre> </li> <li> <p>A f\u00e1jl elej\u00e9re sz\u00farjunk be a megfelel\u0151 usingokat:</p> <pre><code>using Lab_Extensibility.AnonymizerAlgorithms;\nusing Lab_Extensibility.Progresses;\n</code></pre> </li> <li> <p>Az el\u0151z\u0151 pontban bevezetett <code>_progress</code> \u00e9s <code>_anonymizerAlgorithm</code> kezd\u0151\u00e9rt\u00e9ke null, a konstruktorban \u00e1ll\u00edtsuk ezeket a referenci\u00e1kat az ig\u00e9nyeinknek megfelel\u0151 implement\u00e1ci\u00f3ra. Pl.:</p> <pre><code>public Anonymizer(string inputFileName, string mask) : this(inputFileName)\n{\n    _progress = new PercentProgress();\n    _anonymizerAlgorithm = new NameMaskingAnonymizerAlgorithm(mask);\n}\n\npublic Anonymizer(string inputFileName, int rangeSize) : this(inputFileName)\n{\n    _progress = new PercentProgress();\n    _anonymizerAlgorithm = new AgeAnonymizerAlgorithm(rangeSize);\n}\n</code></pre> </li> </ol> <p>Az <code>Anonymizer</code> oszt\u00e1lyban a jelenleg be\u00e9getett, de anonimiz\u00e1l\u00e1s f\u00fcgg\u0151 logik\u00e1kat b\u00edzzuk a <code>_anonymizerAlgorithm</code> tagv\u00e1ltoz\u00f3 \u00e1ltal hivatkozott strategy implement\u00e1ci\u00f3ra:</p> <ol> <li> <p>Az oszt\u00e1ly <code>Run</code> f\u00fcggv\u00e9ny\u00e9ben az <code>if</code>/<code>else</code> kifejez\u00e9sben tal\u00e1lhat\u00f3 <code>Anonymize</code> h\u00edv\u00e1sokat most m\u00e1r le deleg\u00e1ljuk a <code>_anonymizerAlgorithm</code> objektumnak:</p> <pre><code>Person person;\nif (_anonymizerMode == AnonymizerMode.Name)\n    person = Anonymize_MaskName(persons[i], _mask);\nelse if (_anonymizerMode == AnonymizerMode.Age)\n    person = Anonymize_AgeRange(persons[i], _rangeSize);\nelse\n    throw new NotSupportedException(\"The requested anonymization mode is not supported.\");\n</code></pre> <p>helyett:</p> <pre><code>Person person = _anonymizerAlgorithm.Anonymize(persons[i]);\n</code></pre> </li> <li> <p>T\u00f6r\u00f6lj\u00fck a <code>Anonymize_MaskName</code> \u00e9s <code>Anonymize_AgeRange</code> f\u00fcggv\u00e9nyeket, hiszen ezek k\u00f3dja m\u00e1r a strategy implement\u00e1ci\u00f3kba ker\u00fclt, az oszt\u00e1lyr\u00f3l lev\u00e1lasztva.</p> </li> <li> <p>A <code>PrintSummary</code> f\u00fcggv\u00e9ny\u00fcnk a rugalmatlan, <code>switch</code> alapokon m\u0171k\u00f6d\u0151 <code>GetAnonymizerDescription</code>-t h\u00edvja. Ezt a <code>GetAnonymizerDescription</code> h\u00edv\u00e1st cser\u00e9lj\u00fck le, deleg\u00e1ljuk a <code>_anonymizerAlgorithm</code> objektumnak. A <code>PrintSummary</code> f\u00fcggv\u00e9nyben (csak a l\u00e9nyeget kiemelve):</p> <pre><code>    ... GetAnonymizerDescription() ...\n</code></pre> <p>helyett:</p> <pre><code>    ... _anonymizerAlgorithm.GetAnonymizerDescription() ...\n</code></pre> <p>P\u00e1r sorral lejjebb a <code>GetAnonymizerDescription</code> f\u00fcggv\u00e9nyt t\u00f6r\u00f6lj\u00fck is az oszt\u00e1lyb\u00f3l (ennek k\u00f3dja megfelel\u0151 strategy implement\u00e1ci\u00f3kba bek\u00fclt).</p> </li> </ol> <p>Az utols\u00f3 l\u00e9p\u00e9s az <code>Anonymizer</code> oszt\u00e1lyba be\u00e9getett progress kezel\u00e9s lecser\u00e9l\u00e9se:</p> <ol> <li> <p>Itt is deleg\u00e1ljuk a k\u00e9r\u00e9st, m\u00e9gpedig a kor\u00e1bban bevezetett <code>_progress</code> objektumunknak. A <code>Run</code> f\u00fcggv\u00e9nyben egy sort kell ehhez lecser\u00e9lni:</p> <pre><code>PrintProgress(i);\n</code></pre> <p>helyett:</p> <pre><code>_progress.Report(persons.Count, i);\n</code></pre> </li> <li> <p>T\u00f6r\u00f6lj\u00fck a <code>PrintProgress</code> f\u00fcggv\u00e9nyt, hiszen ennek k\u00f3dja m\u00e1r egy megfelel\u0151 strategy implement\u00e1ci\u00f3ba ker\u00fclt, az oszt\u00e1lyr\u00f3l lev\u00e1lasztva.</p> </li> </ol> <p>Elk\u00e9sz\u00fclt\u00fcnk, a k\u00e9sz megold\u00e1s a \"Strategy-1\" projektben meg is tal\u00e1lhat\u00f3 (ha valahol elakadtunk, vagy nem fordul a k\u00f3d, ezzel \u00f6ssze lehet n\u00e9zni).</p>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-ertekelese_3","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>A strategy minta bevezet\u00e9s\u00e9vel elk\u00e9sz\u00fclt\u00fcnk. Jelen form\u00e1j\u00e1ban ugyanakkor szinte soha nem haszn\u00e1ljuk. Ellen\u0151rizz\u00fck a megold\u00e1sunkat: val\u00f3ban \u00fajrafelhaszn\u00e1lhat\u00f3, \u00e9s az <code>Anomymizer</code> oszt\u00e1ly m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl lehet\u0151s\u00e9g van-e az anonimiz\u00e1l\u00f3 algoritmus, illetve a progress kezel\u00e9s megv\u00e1ltoztat\u00e1s\u00e1ra? Ehhez azt kell megn\u00e9zni, b\u00e1rhol az oszt\u00e1lyban van-e olyan k\u00f3d, mely implement\u00e1ci\u00f3 f\u00fcgg\u0151.</p> <p>Sajnos tal\u00e1lunk ilyet. A konstruktorba be van \u00e9getve, milyen algoritmus implement\u00e1ci\u00f3t \u00e9s progress implement\u00e1ci\u00f3t hozunk l\u00e9tre. Ezt mindenk\u00e9ppen n\u00e9zz\u00fck meg a k\u00f3dban! Ha algoritmus vagy progress m\u00f3dot akarunk v\u00e1ltoztatni, ezekben a sorokban \u00e1t kell \u00edrni a <code>new</code> oper\u00e1tor ut\u00e1ni t\u00edpust, mely \u00edgy az oszt\u00e1ly m\u00f3dos\u00edt\u00e1s\u00e1val j\u00e1r.</p> <p>Sokan - teljesen jogosan - ezt jelen form\u00e1j\u00e1ban nem is tekintik igazi Strategy alap\u00fa megold\u00e1snak. A teljes k\u00f6r\u0171 megold\u00e1st a k\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtjuk meg.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#8-megoldas-4-strategystrategy-2-di","title":"8. Megold\u00e1s (4-Strategy/Strategy-2-DI)","text":"<p>A megold\u00e1st a Dependency Injection (r\u00f6viden DI) alkalmaz\u00e1sa jelenti. Ennek l\u00e9nyege az, hogy nem maga az oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edtja a viselked\u00e9sbeli f\u00fcgg\u0151s\u00e9geit (ezek a strategy implement\u00e1ci\u00f3k), hanem ezeket k\u00edv\u00fclr\u0151l adjuk \u00e1t neki, pl. konstruktor param\u00e9terekben, vagy ak\u00e1r property-k vagy setter m\u0171veletek form\u00e1j\u00e1ban. Term\u00e9szetesen interf\u00e9sz t\u00edpusk\u00e9nt hivatkozva!</p> <p>A k\u00e9sz megold\u00e1st n\u00e9zz\u00fck meg, ez a \"Strategy-2-DI\" projektben tal\u00e1lhat\u00f3. Csak az <code>Anonymizer</code> oszt\u00e1ly konstruktor\u00e1t kell n\u00e9zni. Azt l\u00e1tjuk, hogy a fenti elveknek megfelel\u0151en \u00e1t lett alak\u00edtva.</p> <p>Megjegyz\u00e9s: azt egyel\u0151re ne akarjuk meg\u00e9rteni, mi az \u00fajonnan felbukkan\u00f3 <code>NullProgress</code> a konstruktorban (ez a DI szempontj\u00e1b\u00f3l irrelev\u00e1ns, r\u00f6videsen visszat\u00e9r\u00fcnk r\u00e1).</p> <p>Most m\u00e1r elk\u00e9sz\u00fclt\u00fcnk, az <code>Anonymizer</code> oszt\u00e1ly teljesen f\u00fcggetlen lett az implement\u00e1ci\u00f3kt\u00f3l. Lehet\u0151s\u00e9g\u00fcnk van az <code>Anonymizer</code> oszt\u00e1ly b\u00e1rmilyen anonimiz\u00e1l\u00f3 algoritmus \u00e9s b\u00e1rmilyen progress kezel\u00e9s  (annak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl). Erre vannak is p\u00e9ld\u00e1k a <code>Program.cs</code> f\u00e1jlban, n\u00e9zz\u00fck ezt meg! Itt n\u00e9gy <code>Anonymizer</code> objektumot hozunk l\u00e9tre, n\u00e9gy k\u00fcl\u00f6nb\u00f6z\u0151 anonimiz\u00e1l\u00f3 \u00e9s progress kombin\u00e1ci\u00f3val.</p> <p>A m\u0171k\u00f6d\u00e9s ellen\u0151rz\u00e9se</p> <p>A gyakorlat sor\u00e1n erre val\u00f3sz\u00edn\u0171leg nem lesz id\u0151, de aki bizonytalan abban, \"mit\u0151l is m\u0171k\u00f6dik\" a strategy minta, mit\u0151l lesz m\u00e1s a viselked\u00e9s a fenti n\u00e9gy esetre: \u00e9rdemes t\u00f6r\u00e9spontokat tenni a <code>Program.cs</code> f\u00e1jlban a n\u00e9gy <code>Run</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sra, \u00e9s a f\u00fcggv\u00e9nyekbe a debuggerben belel\u00e9pkedve kipr\u00f3b\u00e1lni, hogy mindig a megfelel\u0151 strategy implement\u00e1ci\u00f3 h\u00edv\u00f3dik meg.</p> <p>A projektben tal\u00e1lhat\u00f3 egy oszt\u00e1lydiagram (<code>Main.cd</code>), ezen is megtekinthet\u0151 a k\u00e9sz megold\u00e1s:</p> Strategy alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Strategy alap\u00fa megold\u00e1sunkat:</p> <p></p>"},{"location":"labor/6-tervezesi-mintak-pre/#null-strategy-kitero","title":"Null strategy (kit\u00e9r\u0151)","text":"<p>Az <code>Anonymizer</code> konstruktor\u00e1ban l\u00e1tunk egy els\u0151re tal\u00e1n kicsit fura r\u00e9szletet. Ha a h\u00edv\u00f3 null-t ad meg <code>IProgress</code> strategy-k\u00e9nt param\u00e9terben, akkor a <code>_progress</code> tagv\u00e1ltoz\u00f3ba nem <code>null</code>-t ment\u00fcnk, hanem egy <code>NullProgress</code> objektumra \u00e1ll\u00edtjuk. A <code>NullProgress</code> is egy teljes \u00e9rt\u00e9k\u0171 <code>IProgress</code> implement\u00e1ci\u00f3, csak \u00e9ppen nem csin\u00e1l semmit (\u00fcres a t\u00f6rzse). Ezzel a megold\u00e1ssal azt \u00e9rj\u00fck el, hogy nem kell az oszt\u00e1lyban a <code>_progress</code> minden haszn\u00e1latakor megvizsg\u00e1lni, hogy null-e (ha elfelejten\u00e9nk, akkor <code>NullReferenceException</code>-t kapn\u00e1nk!), mert az mindig egy \u00e9rv\u00e9nyes objektumra mutat. Egyszer\u0171en, ha nincs sz\u00fcks\u00e9g semmif\u00e9le progress ki\u00edr\u00e1s\u00e1ra, akkor <code>NullProgress</code>-t haszn\u00e1lunk strat\u00e9giak\u00e9nt, mely nem csin\u00e1l semmit. Ez is egy tervez\u00e9si minta, Null Object a neve.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-ertekelese_4","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>Ellen\u0151rizz\u00fck a megold\u00e1st, megval\u00f3s\u00edtja-e a c\u00e9ljainkat:</p> <ul> <li>Az <code>Anonymizer</code> egy \u00fajrafelhaszn\u00e1lhat\u00f3(bb) oszt\u00e1ly lett.</li> <li>Ha \u00faj anonimiz\u00e1l\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak egy \u00faj <code>IAnonymizerAlgorithm</code> implement\u00e1ci\u00f3t kell bevezetni. Ez nem m\u00f3dos\u00edt\u00e1s, hanem b\u0151v\u00edt\u00e9s.</li> <li>Ha \u00faj progress logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak egy \u00faj <code>IProgress</code> implement\u00e1ci\u00f3t kell bevezetni. Ez nem m\u00f3dos\u00edt\u00e1s, hanem b\u0151v\u00edt\u00e9s.</li> <li>A fenti k\u00e9t pontban teljes\u00fcl az OPEN/CLOSED elv, vagyis az <code>Anonymizer</code> k\u00f3dj\u00e1nak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl tudjuk a logik\u00e1j\u00e1t testre szabni, kiterjeszteni.</li> <li>Itt nem kell tartani a Template Methodn\u00e1l tapasztalt kombinatorikus robban\u00e1st\u00f3l: b\u00e1rmely <code>IAnonymizerAlgorithm</code> implement\u00e1ci\u00f3 b\u00e1rmely <code>IProgress</code> implement\u00e1ci\u00f3val k\u00e9nyelmesen haszn\u00e1lhat\u00f3, nem kell a kombin\u00e1ci\u00f3khoz \u00faj oszt\u00e1lyokat bevezetni (ezt l\u00e1ttuk a <code>Program.cs</code> f\u00e1jlban).</li> </ul> <p>Tov\u00e1bbi Strategy el\u0151ny\u00f6k a Template Methoddal szemben *</p> <ul> <li>Fut\u00e1s k\u00f6zben lecser\u00e9lhet\u0151 viselked\u00e9s is megval\u00f3s\u00edthat\u00f3. Ha sz\u00fcks\u00e9g lenne arra, hogy egy adott <code>Anonymizer</code> objektumra vonatkoz\u00f3an a l\u00e9trehoz\u00e1sa ut\u00e1n meg tudjuk v\u00e1ltoztatni az anonimiz\u00e1l\u00f3 vagy progress viselked\u00e9st, akkor azt k\u00f6nnyen meg tudn\u00e1nk tenni (csak egy <code>SetAnonimizerAlgorithm</code>, ill. <code>SetProgress</code> m\u0171veletet kellene bevezetni, melyben a param\u00e9terben megkapott implement\u00e1ci\u00f3ra lehetne \u00e1ll\u00edtani az oszt\u00e1ly \u00e1ltal haszn\u00e1lt strategy-t).</li> <li>Egys\u00e9gtesztelhet\u0151s\u00e9g t\u00e1mogat\u00e1sa (m\u00e9g visszat\u00e9r\u00fcnk erre).</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#9-megoldas-5-strategyfull-unittestingstrategyfull-1","title":"9. Megold\u00e1s (5-StrategyFull-UnitTesting/StrategyFull-1)","text":"<p>Vegy\u00fck \u00e9szre, hogy az <code>Anonimyzer</code> oszt\u00e1ly m\u0171k\u00f6d\u00e9s\u00e9nek van m\u00e9g sz\u00e1mos aspektusa, melyeket valamelyik megold\u00e1sunkkal kiterjeszthet\u0151v\u00e9 lehetne tenni. T\u00f6bbek k\u00f6z\u00f6tt ilyen a:</p> <ul> <li>Bemenet kezel\u00e9se: Most csak f\u00e1jl alap\u00fa, adott CSV form\u00e1tumot t\u00e1mogatunk.</li> <li>Kimenet kezel\u00e9se: Most csak f\u00e1jl alap\u00fa, adott CSV form\u00e1tumot t\u00e1mogatunk.</li> </ul> <p>Ezeket az SRP elve miatt illene az oszt\u00e1lyr\u00f3l lev\u00e1lasztani, de nem felt\u00e9telen kiterjeszthet\u0151 m\u00f3don, hiszen nem mer\u00fclt fel ig\u00e9ny arra (\u00e9s \u00fagy l\u00e1tjuk, nem is lesz k\u00e9s\u0151bb sem), hogy a mostanit\u00f3l elt\u00e9r\u0151 logik\u00e1kat alkalmazzunk.</p> <p>Ugyanakkor van m\u00e9g egy kritikus szempont, melyr\u0151l nem besz\u00e9lt\u00fcnk (\u00e9s a r\u00e9gebbi, klasszikus design pattern irodalmak sem felt\u00e9tlen emlegetik). Ez az egys\u00e9gtesztelhet\u0151s\u00e9g.</p> <p>Jelen pillanatban az <code>Anonymizer</code> oszt\u00e1lyunkhoz automata integr\u00e1ci\u00f3s teszteket tudunk \u00edrni, automata egys\u00e9gteszteket nem:</p> <ul> <li>Az integr\u00e1ci\u00f3s tesztek a teljes m\u0171k\u00f6d\u00e9st egyben vizsg\u00e1lj\u00e1k: ebben benne van a bemenet feldolgoz\u00e1sa, adatfeldolgoz\u00e1s, kimenet el\u0151\u00e1ll\u00edt\u00e1sa. Ez p\u00e9ld\u00e1nkban egyszer\u0171: el\u00e1ll\u00edtunk bizonyos bemeneti CVS \u00e1llom\u00e1nyokat, \u00e9s megn\u00e9zz\u00fck, a v\u00e1rt kimeneti \u00e1llom\u00e1ny \u00e1ll\u00edt\u00f3dik-e el\u0151.</li> <li>Az integr\u00e1ci\u00f3s tesztek nagyon lass\u00faak tudnak lenni: sokszor f\u00e1jlokb\u00f3l, adatb\u00e1zisokb\u00f3l, felh\u0151 alap\u00fa szolg\u00e1ltat\u00e1sokb\u00f3l veszik a bemenetet, illetve ezek szolg\u00e1lnak kimenetk\u00e9nt. Egy nagyobb term\u00e9k eset\u00e9ben - mikor sok ezer teszt van - ez a lass\u00fas\u00e1g korl\u00e1toz\u00f3 t\u00e9nyez\u0151, ritk\u00e1bban tudjuk futtatni \u00e9s/vagy nem tudunk j\u00f3 tesztlefedetts\u00e9get el\u00e9rni.</li> </ul> <p>A fentiek miatt nagyobb k\u00f3dlefedetts\u00e9get nagyon gyorsan fut\u00f3 egys\u00e9gtesztekkel szoktunk/tudunk el\u00e9rni. Ezek mindenf\u00e9le lass\u00fa f\u00e1jl/adatb\u00e1zis/h\u00e1l\u00f3zat/felh\u0151 el\u00e9r\u00e9s n\u00e9lk\u00fcl \u00f6nmag\u00e1ban egy egy logikai egys\u00e9get tesztelnek a k\u00f3dban, ezt viszont \u00edgy m\u00e1r vill\u00e1mgyorsan, \u00edgy sokat tudunk futtatni adott id\u0151 alatt, j\u00f3 tesztlefedetts\u00e9ggel.</p> <p>Tesztpiramis *</p> <p>Ezt egy tesztpiramissal szok\u00e1s szeml\u00e9ltetni, melynek t\u00f6bb form\u00e1ja terjedt el az irodalomban, egy egyszer\u0171 vari\u00e1ns a k\u00f6vetkez\u0151:</p> <p></p> <p>Min\u00e9l fentebb vagyunk a piramis r\u00e9tegeiben, ann\u00e1l \u00e1tfog\u00f3bbak ugyan a tesztek, de ann\u00e1l lassabbak \u00e9s k\u00f6lts\u00e9gesebben is futtathat\u00f3k. \u00cdgy ezekb\u0151l \u00e1ltal\u00e1ban kevesebbet is k\u00e9sz\u00edt\u00fcnk (ez\u00e1ltal kisebb k\u00f3dlefedetts\u00e9get is \u00e9r\u00fcnk el vel\u00fck).</p> <p>N\u00e9zz\u00fck meg az <code>Anonymizer</code> oszt\u00e1lyt: ebbe be van \u00e9getve, hogy csak a lass\u00fa, f\u00e1jl alap\u00fa bemenettel tud dolgozni. De amikor mi pl. a <code>Run</code> m\u0171velet logik\u00e1j\u00e1t szeretn\u00e9nk egys\u00e9gtesztelni, teljesen mindegy, hogy f\u00e1jlb\u00f3l j\u00f6nnek-e az adatok (lassan), vagy egyszer\u0171en k\u00f3db\u00f3l a <code>new</code> oper\u00e1torral el\u0151\u00e1ll\u00edtunk n\u00e9h\u00e1ny <code>Person</code> objektumot (t\u00f6bb nagys\u00e1grenddel gyorsabban).</p> <p>A megold\u00e1s - a k\u00f3dunk egys\u00e9gtesztelhet\u0151v\u00e9 t\u00e9tel\u00e9hez - egyszer\u0171:</p> <ul> <li> A Strategy minta (vagy delegate-ek) alkalmaz\u00e1ssal v\u00e1lasszuk le az egys\u00e9gtesztelni k\u00edv\u00e1nt oszt\u00e1lyr\u00f3l a tesztel\u00e9st akad\u00e1lyoz\u00f3 vagy lass\u00edt\u00f3 (pl. bemenet/kimenet kezel\u00e9s) logik\u00e1kat. Ezeknek k\u00e9sz\u00edt\u00fcnk a val\u00f3di logik\u00e1t megval\u00f3s\u00edt\u00f3 implement\u00e1ci\u00f3it, illetve tesztel\u00e9st seg\u00edt\u0151, \u00fan. mock implement\u00e1ci\u00f3it.</li> </ul> <ul> <li> Ennek megfelel\u0151en a Strategy mint\u00e1t sokszor nem az\u00e9rt haszn\u00e1ljuk, mert az \u00fcgyf\u00e9lig\u00e9nyek miatt t\u00f6bbf\u00e9le viselked\u00e9st kell benevezni, hanem az\u00e9rt, hogy a k\u00f3dunk egys\u00e9gtesztelhet\u0151 legyen.</li> </ul> <p>Ennek megfelel\u0151en elk\u00e9sz\u00edtj\u00fck a megold\u00e1sunk egys\u00e9gtesztel\u00e9sre is el\u0151k\u00e9sz\u00edtett v\u00e1ltozat\u00e1t, melyben a bemenet \u00e9s kimenet kezel\u00e9se is le van v\u00e1lasztva a Strategy minta alkalmaz\u00e1s\u00e1val.</p> <p>Egyb\u0151l a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck (\"StrategyFull-1\"), hiszen itt semmi \u00fajat nem tanulunk, egyszer\u0171en csak alkalmazzuk a Strategy mint\u00e1t k\u00e9t aspektus ment\u00e9n:</p> <ul> <li><code>InputReaders</code> mappa: bemenet feldolgoz\u00f3 strategy interf\u00e9sz, \u00e9s a kor\u00e1bbi logika kiszervezve egy implement\u00e1ci\u00f3ba.</li> <li><code>ResultWriters</code> mappa: kimenet el\u0151\u00e1ll\u00edt\u00f3 strategy interf\u00e9sz, \u00e9s a kor\u00e1bbi logika kiszervezve egy implement\u00e1ci\u00f3ba.</li> <li><code>Anonymizer</code> oszt\u00e1ly:<ul> <li>\u00daj <code>_inputReader</code> \u00e9s <code>_resultWriter</code> tagok, valamint ezek inicializ\u00e1l\u00e1sa a konstruktorban.</li> <li>Run f\u00fcggv\u00e9nyben <code>_inputReader</code> \u00e9s <code>_resultWriter</code> haszn\u00e1lata.</li> </ul> </li> </ul> <p>Az <code>Anonymizer</code> oszt\u00e1lyunk \u00e1tl\u00e1that\u00f3bb is lett: jobban k\u00f6veti az SRP elvet, k\u00e9t felel\u0151ss\u00e9gi k\u00f6r kiszervez\u00e9sre ker\u00fclt bel\u0151le.</p> Megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Strategy alap\u00fa megold\u00e1sunkat (Main.cd diagram a projektben):</p> <p></p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9s egys\u00e9gtesztek k\u00e9sz\u00edt\u00e9se az <code>Anonymizer</code> oszt\u00e1lyhoz. Ehhez olyan mock strategy implement\u00e1ci\u00f3kat kell bevezetni, melyek nemcsak tesztadatokat szolg\u00e1ltatnak, hanem ellen\u0151rz\u00e9seket is v\u00e9geznek (adott logikai egys\u00e9g val\u00f3ban j\u00f3l m\u0171k\u00f6dik-e). Ez most bonyolultnak hangzik, de szerencs\u00e9re a legt\u00f6bb modern keretrendszerben van r\u00e1 k\u00f6nyvt\u00e1r t\u00e1mogat\u00e1s (.NET-ben a moq). Ennek alkalmaz\u00e1sa t\u00falmutat a t\u00e1rgy keretein, \u00edgy a feladatunk egys\u00e9gtesztelhet\u0151s\u00e9ghez kapcsol\u00f3d\u00f3 vonulat\u00e1t ebben a pontban lez\u00e1rjuk.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#10-megoldas-6-delegatesandlambdasdelegatesandlambdas-1-progress","title":"10. Megold\u00e1s (6-DelegatesAndLambdas/DelegatesAndLambdas-1-Progress)","text":"<p>Napjainkban rohamosan terjed a kor\u00e1bban szigor\u00faan objektumorient\u00e1lt nyelvekben is a funkcion\u00e1lis programoz\u00e1st t\u00e1mogat\u00f3 eszk\u00f6z\u00f6k megjelen\u00e9se, \u00e9s az alkalmaz\u00e1sfejleszt\u0151k is egyre nagyobb szeretettel alkalmazz\u00e1k ezeket. Egy ilyen eszk\u00f6z C# nyelven a delegate (\u00e9s ehhez kapcsol\u00f3d\u00f3an a lambda kifejez\u00e9s).</p> <p>Mint a f\u00e9l\u00e9v sor\u00e1n kor\u00e1bban l\u00e1ttuk, delegate-ek seg\u00edts\u00e9g\u00e9vel olyan k\u00f3dot tudunk \u00edrni, melybe bizonyos logik\u00e1k/viselked\u00e9sek nincsenek be\u00e9getve, ezeket \"k\u00edv\u00fclr\u0151l\" kap meg a k\u00f3d. Pl. egy sorrendez\u0151 f\u00fcggv\u00e9nynek delegate form\u00e1j\u00e1ban adjuk \u00e1t param\u00e9terk\u00e9nt, hogyan kell k\u00e9t elemet \u00f6sszehasonl\u00edtani, vagy mely mez\u0151je/tulajdons\u00e1ga szerint kell az \u00f6sszehasonl\u00edt\u00e1st elv\u00e9gezni (\u00edgy v\u00e9gs\u0151 soron meghat\u00e1rozni a k\u00edv\u00e1nt sorrendet).</p> <p>Ennek megfelel\u0151en a delegate-ek alkalmaz\u00e1sa egy \u00fajabb alternat\u00edva (a Template Method \u00e9s a Strategy mellett) a k\u00f3d \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1/kiterjeszthet\u0151v\u00e9 t\u00e9tel\u00e9re, kiterjeszt\u00e9si pontok bevezet\u00e9s\u00e9re.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a kor\u00e1bban Strategy mint\u00e1val megval\u00f3s\u00edtott progress kezel\u00e9st alak\u00edtjuk \u00e1t delegate alap\u00fara (\u00faj funkci\u00f3t nem vezet\u00fcnk be, ez egy pluszt\u00e1n \"technikai\" \u00e1talak\u00edt\u00e1s lesz).</p> <ul> <li> A megold\u00e1s alapelve A delegate alap\u00fa megold\u00e1s alapelve nagyon hasonl\u00edt a Strategy-hez: csak nem strategy-ket kap \u00e9s t\u00e1rol az oszt\u00e1ly tagv\u00e1ltoz\u00f3kban (interf\u00e9sz hivatkoz\u00e1sokon kereszt\u00fcl), hanem delegate-eket, \u00e9s az ezek \u00e1ltal hivatkozott f\u00fcggv\u00e9nyeket h\u00edvja a kiterjeszt\u00e9si pontokban.</li> </ul> <p>A \"6-DelegatesAndLambdas\" mappa \"DelegatesAndLambdas-0-Begin\" projektj\u00e9b\u0151l indulunk ki. Ez a kor\u00e1bbi, n\u00e9gy aspektus ment\u00e9n Strategy mint\u00e1val m\u00e1r kiterjeszthet\u0151v\u00e9 tett megold\u00e1s. L\u00e9p\u00e9sek:</p> <ol> <li>Az <code>IProgress</code> interf\u00e9szt, pontosabban annak <code>Report</code> m\u0171velet\u00e9t v\u00e1ltjuk ki delegate haszn\u00e1lattal. Ne vezess\u00fcnk be saj\u00e1t delegate t\u00edpust, haszn\u00e1ljuk a .NET \u00e1ltal biztos\u00edtott <code>Action</code> \u00e9s <code>Func</code> (generikus) t\u00edpusokat. A <code>Report</code> <code>void</code>-dal t\u00e9r vissza, \u00e9s k\u00e9t <code>int</code> param\u00e9tere van: ez egy <code>Action&lt;int, int&gt;</code> t\u00edpussal v\u00e1lthat\u00f3 ki, ezt fogjuk az al\u00e1bbiakban haszn\u00e1lni.</li> <li> <p>Az <code>Anonymizer</code> oszt\u00e1lyban a strategy tag lecser\u00e9l\u00e9se delegate-re:</p> <pre><code>private readonly IProgress _progress;\n</code></pre> <p>helyett:</p> <pre><code>private readonly Action&lt;int, int&gt; _reportProgress;\n</code></pre> </li> <li> <p>Az <code>Anonymizer</code> oszt\u00e1lyban a konstruktorban a strategy interf\u00e9sz lecser\u00e9l\u00e9se delegate-re:</p> <pre><code>public Anonymizer(..., Action&lt;int, int&gt; reportProgress)\n{\n    ...\n    // If reportProgress is null, use a lambda function that does nothing (has an empty body)\n    _reportProgress = reportProgress ?? (( _,  _) =&gt; { });\n    ...\n}\n</code></pre> <p>Itt egy picit \"tr\u00fckk\u00f6zt\u00fcnk\" is (de ez az \"alapok\" tekintet\u00e9ben l\u00e9nyegtelen): ha a f\u00fcggv\u00e9ny null action-t kap, akkor a <code>_reportProgress</code> tagv\u00e1ltoz\u00f3t egy \u00fcres t\u00f6rzs\u0171 (semmit nem csin\u00e1l\u00f3) f\u00fcggv\u00e9nyre \u00e1ll\u00edtjuk egy lambda kifejez\u00e9ssel, hogy a <code>_reportProgress</code> soha ne legyen <code>null</code>, ne kelljen <code>null</code> vizsg\u00e1latot v\u00e9gezni a haszn\u00e1latakor.</p> <p>Azt pedig szabadon eld\u00f6nthetj\u00fck, adunk-e <code>null</code> alap\u00e9rtelmezett \u00e9rt\u00e9ket a <code>reportProgress</code> param\u00e9ternek (a fenti p\u00e9ld\u00e1ban nem adtunk).</p> </li> <li> <p>A Run m\u0171veletben a strategy lecser\u00e9l\u00e9se delegate h\u00edv\u00e1sra:</p> <pre><code>_progress.Report(persons.Count,i);\n</code></pre> <p>helyett:</p> <pre><code>_reportProgress(persons.Count,i);\n</code></pre> </li> <li> <p>A <code>Program.cs</code>-ben az <code>Anonymizer</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sakor negyedik param\u00e9terben m\u00e1r nem egy <code>IProgress</code> implement\u00e1ci\u00f3t kell \u00e1tadni, hanem egy <code>Action&lt;int, int&gt;</code>-tel kompatibilis f\u00fcggv\u00e9nyt. A <code>SimpleProgress</code> eset\u00e9ben a <code>Report</code> egy egyszer\u0171, egysoros f\u00fcggv\u00e9ny, adjuk ezt meg egy lambda kifejez\u00e9s form\u00e1j\u00e1ban:</p> <pre><code>    Anonymizer a1 = new(\n    new CsvInputReader(inputFileName),\n    new CsvResultWriter(outputFileName),\n    new NameMaskingAnonymizerAlgorithm(\"***\"),\n    (count, index) =&gt; Console.WriteLine($\"{index + 1}. person processed\")\n    a1.Run();\n</code></pre> <p>A lambda t\u00f6rzse pontosan ugyanaz, mint a <code>SimpleProgress</code> eset\u00e9ben volt!</p> </li> <li> <p>Mostant\u00f3l nincs sz\u00fcks\u00e9g a progress kezel\u00e9shez kapcsol\u00f3d\u00f3 strategy interf\u00e9szre \u00e9s implement\u00e1ci\u00f3kra!</p> <ul> <li>T\u00f6r\u00f6lj\u00fck az ezeket tartalmaz\u00f3 <code>Progresses</code> mapp\u00e1t a solutionb\u0151l (jobb katt rajta a Solution Explorerben, majd <code>Delete</code> men\u00fc). Megjegyz\u00e9s: Ezzel ugyan kit\u00f6r\u00f6lt\u00fck a sz\u00e1zal\u00e9k progress logik\u00e1t is, erre m\u00e9g majd visszat\u00e9r\u00fcnk r\u00f6videsen.</li> <li>T\u00f6r\u00f6lj\u00fck az <code>Anonymizer.cs</code>-ben a <code>using Lab_Extensibility.Progresses;</code> sort, hiszen ez a n\u00e9vt\u00e9r a fenti t\u00f6rl\u00e9ssel megsz\u0171nt.</li> </ul> </li> </ol> <p>De \u00e1ltal\u00e1noss\u00e1g\u00e1ban a helyzet nem ilyen egyszer\u0171. Amennyiben az Anonymizer l\u00e9trehoz\u00e1sakor a <code>reportProgress</code> delegate-nek mindig m\u00e1s \u00e9s m\u00e1s implement\u00e1ci\u00f3t adunk meg, akkor ez a lambda alap\u00fa megold\u00e1s t\u00f6k\u00e9letes. Viszont mi a helyzet akkor, ha a fenti p\u00e9ld\u00e1ban szerepl\u0151 \"simple progress\" logik\u00e1t t\u00f6bb helyen, t\u00f6bb <code>Anonymizer</code> objektumn\u00e1l is fel szeretn\u00e9nk haszn\u00e1lni? S\u00falyos hiba lenne a <code>(count, index) =&gt; Console.WriteLine($\"{index + 1}. person processed\")</code> lambda kifejez\u00e9st copy-paste-tel \"szapor\u00edtani\", k\u00f3dduplik\u00e1ci\u00f3hoz vezetne (ellentmondana a Do Not Repeat Yourself, r\u00f6viden DRY elvnek).</p> <p>K\u00e9rd\u00e9s: van-e megold\u00e1s arra, hogy delegate-ek eset\u00e9ben is \u00fajrafelhaszn\u00e1lhat\u00f3 k\u00f3dot adjunk meg? Term\u00e9szetesen igen, hiszen delegate-ek eset\u00e9ben nem k\u00f6telez\u0151 a lambda kifejez\u00e9sek haszn\u00e1lata, lehet vel\u00fck k\u00f6z\u00f6ns\u00e9ges m\u0171veletekre (ak\u00e1r statikus, ak\u00e1r nem statikusakra is), mint azt kor\u00e1bban a f\u00e9l\u00e9v sor\u00e1n l\u00e1ttuk, \u00e9s sz\u00e1mos esetben alkalmaztuk is.</p> <p>Amennyiben a \"simple progress\" \u00e9s/vagy \"percent progress\" logik\u00e1t/logik\u00e1kat \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 szeretn\u00e9nk tenni, tegy\u00fck ezeket egy k\u00fcl\u00f6n f\u00fcggv\u00e9nyekbe valamilyen, az adott esetben legink\u00e1bb passzol\u00f3 oszt\u00e1lyba/oszt\u00e1lyokba, \u00e9s egy ilyen  m\u0171veletet adjuk meg az <code>Anonymizer</code> konstruktornak param\u00e9terk\u00e9nt:</p> <p>A k\u00f6vetkez\u0151kben ugorjuk az ennek megfelel\u0151en \u00e1talak\u00edtott k\u00e9sz, \"DelegatesAndLambdas-1-Progress\" projektben tal\u00e1lhat\u00f3 megold\u00e1sra:</p> <ul> <li> <p>A \"simple progress\" \u00e9s \"percent progress\" logik\u00e1kat egy <code>AllProgresses</code> nev\u0171 statikus oszt\u00e1ly k\u00e9t statikus m\u0171velet\u00e9ben val\u00f3s\u00edtottuk meg:</p> AllProgresses.cs <pre><code>public static class AllProgresses\n{\n    public static void ReportPercent(int count, int index)\n    {\n        int percentage = (int)((double)(index+1) / count * 100);\n\n        var pos = Console.GetCursorPosition();\n        Console.SetCursorPosition(0, pos.Top);\n\n        Console.Write($\"Processing: {percentage} %\");\n\n        if (index == count - 1)\n            Console.WriteLine();\n    }\n\n    public static void ReportSimple(int count, int index)\n    {\n        Console.WriteLine($\"{index + 1}. person processed\");\n    }\n}\n</code></pre> </li> <li> <p>A <code>Program.cs</code> f\u00e1jlban az <code>Anonymizer a2</code> objektum eset\u00e9ben az <code>AllProgresses.ReportPercent</code>-et adtuk meg param\u00e9ternek:</p> Program.cs <pre><code>Anonymizer a2 = new(\n    new CsvInputReader(inputFileName),\n    new CsvResultWriter(outputFileName),\n    new NameMaskingAnonymizerAlgorithm(\"***\"),\n    AllProgresses.ReportPercent);\na2.Run();\n</code></pre> </li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#a-megoldas-erekelese","title":"A megold\u00e1s \u00e9r\u00e9kel\u00e9se","text":"<p>Elk\u00e9sz\u00fclt\u00fcnk, \u00e9rt\u00e9kelj\u00fck a megold\u00e1st:</p> <ul> <li>Kijelenthet\u0151, hogy a delegate alap\u00fa megold\u00e1s a Strategy-n\u00e9l kisebb cerem\u00f3ni\u00e1val j\u00e1rt: nem kellett interf\u00e9szt \u00e9s implement\u00e1ci\u00f3s oszt\u00e1lyokat bevezetni (a be\u00e9p\u00edtett <code>Action</code> \u00e9s <code>Func</code> generikus delegate t\u00edpusokat tudtuk haszn\u00e1lni).</li> <li>A teljesen \"eseti\" logik\u00e1t lambda kifejez\u00e9s form\u00e1j\u00e1ban legegyszer\u0171bb megadni. Ha \u00fajrafelhaszn\u00e1lhat\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g, akkor viszont vezess\u00fcnk be \"hagyom\u00e1nyos\", \u00fajrafelhaszn\u00e1lhat\u00f3 f\u00fcggv\u00e9nyeket.</li> </ul> <p>Hogy mikor \u00e9rdemesebb delegate-ekkel dolgozni, illetve a Strategy mint\u00e1val, al\u00e1bb, az \u00fatmutat\u00f3 v\u00e9g\u00e9n a Kiterjeszt\u00e9si technik\u00e1k \u00e1ttekint\u00e9se fejezetben foglaljuk \u00f6ssze.</p>"},{"location":"labor/6-tervezesi-mintak-pre/#osszegzes","title":"\u00d6sszegz\u00e9s","text":""},{"location":"labor/6-tervezesi-mintak-pre/#a-munkafolyamatunk-attekintese","title":"A munkafolyamatunk \u00e1ttekint\u00e9se","text":"<ul> <li>A v\u00e1ltoz\u00f3 ig\u00e9nyek sor\u00e1n organikusan jelentek meg tervez\u00e9si mint\u00e1k, \u00e9s vetett\u00fcnk be egy\u00e9b technik\u00e1kat a refaktor\u00e1l\u00e1sok sor\u00e1n. Ez teljesen term\u00e9szetes, a gyakorlatban is sokszor \u00edgy dolgozunk.</li> <li>Egy komplexebb feladat eset\u00e9ben egy\u00e9bk\u00e9nt is sokszor - k\u00fcl\u00f6n\u00f6sen ha nem rendelkez\u00fcnk sok\u00e9ves tapasztalattal - egy egyszer\u0171bb implement\u00e1ci\u00f3val indulunk (ezt l\u00e1tjuk \u00e1t els\u0151re), \u00e9s alak\u00edtjuk \u00e1t olyanra, hogy az adott kontextusban k\u00edv\u00e1nt kiterjeszthet\u0151s\u00e9gi/\u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1gi param\u00e9terekkel rendelkezzen.</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#ujrafelhasznalhatosagi-es-kiterjeszthetoseg-szintjei-az-egyes-megoldasokban","title":"\u00dajrafelhaszn\u00e1lhat\u00f3s\u00e1gi \u00e9s kiterjeszthet\u0151s\u00e9g szintjei az egyes megold\u00e1sokban","text":"<p>Megpr\u00f3b\u00e1lhatjuk \u00e1br\u00e1ba \u00f6nteni, hogy v\u00e1lt a megold\u00e1sunk az egyes iter\u00e1ci\u00f3kkal egyre ink\u00e1bb \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 \u00e9s kiterjeszthet\u0151v\u00e9:</p> <p></p> <p>Term\u00e9szetesen a % szinteket nem szabad t\u00fal komolyan venni. Mindenesetre a fejl\u0151d\u00e9s j\u00f3l megfigyelhet\u0151.</p> Mi\u00e9rt \"csak\" 70%-os a v\u00e9gs\u0151 megold\u00e1sn\u00e1l mutat\u00f3nk? <p>Felmer\u00fclhet a k\u00e9rd\u00e9s, mi\u00e9rt adunk jelem megold\u00e1sra kb. 70%-ot? T\u00f6bbek k\u00f6z\u00f6tt:</p> <ul> <li>Az <code>Anonymizer</code> oszt\u00e1lyba az adattiszt\u00edt\u00e1s m\u00f3dja mereven be van \u00e9getve (trimmel\u00e9s adott oszlopra adott m\u00f3don).</li> <li>Nem k\u00f6vett\u00fcnk egy nagyon fontos \u00e1ltal\u00e1nos alapelvet: a UI \u00e9s a logika k\u00fcl\u00f6nv\u00e1laszt\u00e1s\u00e1t. A k\u00f3dunk t\u00f6bb pontban konzolra \u00edr, \u00edgy p\u00e9ld\u00e1ul egy grafikus fel\u00fclettel nem haszn\u00e1lhat\u00f3!</li> <li>Bizonyos az anonimiz\u00e1l\u00f3 algoritmusaink nagyon specifikusak. Lehetne olyan \u00e1ltal\u00e1nosabb algoritmusokat k\u00e9sz\u00edteni, melyek tetsz\u0151leges mez\u0151ket kicsillagoznak (nem csak a nevet be\u00e9getetten), illetve tetsz\u0151leges mez\u0151ket s\u00e1vos\u00edtanak (nem csak az \u00e9letkort).</li> <li>Jelen megold\u00e1s csak <code>Person</code> objektumokkal tud m\u0171k\u00f6dni.</li> <li>Nem lehet egyszerre alkalmazni kombin\u00e1lni k\u00fcl\u00f6nb\u00f6z\u0151 anonimiz\u00e1l\u00f3 algoritmusokat.</li> </ul>"},{"location":"labor/6-tervezesi-mintak-pre/#kiterjesztesi-technikak-attekintese","title":"Kiterjeszt\u00e9si technik\u00e1k \u00e1ttekint\u00e9se","text":"<ul> <li>Template Method: Egyszer\u0171 esetben, ha a viselked\u00e9sek k\u00fcl\u00f6nb\u00f6z\u0151 aspektusainak nem kell sok keresztkombin\u00e1ci\u00f3j\u00e1t t\u00e1mogatni, nagyon k\u00e9nyelmes \u00e9s egyszer\u0171 megold\u00e1st ad, k\u00fcl\u00f6n\u00f6sen, ha egy\u00e9bk\u00e9nt is kell haszn\u00e1ljuk a sz\u00e1rmaztat\u00e1st. De nem, vagy csak nehezen egys\u00e9gtesztelhet\u0151 alaposzt\u00e1lyt eredm\u00e9nyez.</li> <li>Strategy: Nagyon rugalmas megold\u00e1st biztos\u00edt, \u00e9s nem vezet kombinatorikus robban\u00e1shoz, ha t\u00f6bb aspektus ment\u00e9n kell az oszt\u00e1lyt kiterjeszteni, \u00e9s t\u00f6bb keresztkombin\u00e1ci\u00f3ban is szeretn\u00e9nk ezeket haszn\u00e1lni. Sok esetben csak az\u00e9rt alkalmazzuk, hogy az oszt\u00e1lyunkr\u00f3l interf\u00e9szek seg\u00edts\u00e9g\u00e9vel lev\u00e1lasszuk a f\u00fcgg\u0151s\u00e9geit, \u00e9s \u00edgy egys\u00e9gtesztelhet\u0151v\u00e9 tegy\u00fck az oszt\u00e1lyunkat.</li> <li>Delegate/lambda: Ez a megk\u00f6zel\u00edt\u00e9s kisebb cerem\u00f3ni\u00e1val j\u00e1r, mint a Strategy alkalmaz\u00e1sa, ugyanis nincs sz\u00fcks\u00e9g interf\u00e9szek \u00e9s implement\u00e1ci\u00f3s oszt\u00e1lyok bevezet\u00e9s\u00e9re, emiatt egyre ink\u00e1bb (rohamosan) terjed a haszn\u00e1lata a modern objektumorient\u00e1lt nyelvekben is. K\u00fcl\u00f6n\u00f6sen akkor j\u00f6nnek ki az el\u0151nyei, ha a viselked\u00e9seket nem akarjuk \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 tenni (mert ekkor csak egy-egy lambda kifejez\u00e9ssel megadjuk ezeket, mindenf\u00e9le \u00faj oszt\u00e1lyok/k\u00fcl\u00f6n f\u00fcggv\u00e9nyek bevezet\u00e9se n\u00e9lk\u00fcl). </li> </ul> <p>\u00c9rdemes \u00f6sszeszedni, hogy a Strategy-nek mikor lehet/van van el\u0151nye a delegate-ekkel szemben:</p> <ul> <li>Ha kiterjesztend\u0151 oszt\u00e1ly adott aspektus\u00e1hoz t\u00f6bb (min\u00e9l t\u00f6bb, ann\u00e1l ink\u00e1bb) m\u0171velet tartozik. Ilyenkor a strategy interf\u00e9sz ezeket \"mag\u00e1t\u00f3l\" sz\u00e9pen \u00f6sszefogja, csoportos\u00edtja (mint a p\u00e9ld\u00e1nkban az <code>IAnonymizerAlgorithm</code> interf\u00e9sz az <code>Anonymize</code> \u00e9s <code>GetAnonymizerDescription</code> m\u0171veleteket). Ezek \u00e9rtelemszer\u0171en az interf\u00e9sz implement\u00e1ci\u00f3kban is egy\u00fctt jelennek meg (delegate-ek eset\u00e9ben nincs ilyen csoportos\u00edt\u00e1s). Ez \u00e1tl\u00e1that\u00f3bb\u00e1 teheti, sok m\u0171velet eset\u00e9n egy\u00e9rtelm\u0171en azz\u00e1 is teszi a megold\u00e1st.</li> <li>Az adott nyelv puszt\u00e1n objektumorient\u00e1lt, nem t\u00e1mogatja a delegate/lambda alkalmaz\u00e1s\u00e1t. De ma m\u00e1r a legt\u00f6bb modern OO nyelv szerencs\u00e9re t\u00e1mogatja valamilyen form\u00e1ban (Java \u00e9s C++ is).</li> <li> <p>A strategy implement\u00e1ci\u00f3k a tagv\u00e1ltoz\u00f3ikban \u00e1llapotot is tudnak t\u00e1rolni, melyet l\u00e9trehoz\u00e1sukkor meg tudunk adni. Ezt haszn\u00e1ltuk is (a <code>NameMaskingAnonymizerAlgorithm</code> eset\u00e9ben ilyen volt a <code>_mask</code>, a <code>AgeAnonymizerAlgorithm</code> eset\u00e9ben a <code>_rangeSize</code>). Ez nem azt jelenti, hogy ilyen esetben egy\u00e1ltal\u00e1n nem tudunk delegate-eket haszn\u00e1lni, hiszen:</p> <ul> <li>ezeket az adatokat ak\u00e1r \u00fajonnan bevezetett f\u00fcggv\u00e9ny param\u00e9terben is \u00e1tadhatjuk az egyes delegate h\u00edv\u00e1sok sor\u00e1n,</li> <li>illetve, lambda haszn\u00e1lata eset\u00e9n a \"variable capture\" mechanizmus seg\u00edts\u00e9g\u00e9vel a lambda f\u00fcggv\u00e9nyek tudnak \u00e1llapotot \u00e1tvenni k\u00f6rnyezet\u00fckb\u0151l.</li> </ul> <p>De ezek a megold\u00e1sok nem mindig alkalmazhat\u00f3k, vagy legal\u00e1bbis k\u00f6r\u00fclm\u00e9nyes lehet az alkalmaz\u00e1suk.</p> </li> </ul> <p>Mindenk\u00e9ppen meg kell eml\u00edteni, hogy nem csak jelen gyakorlatban eml\u00edtett n\u00e9h\u00e1ny minta szolg\u00e1lja a kiterjeszthet\u0151s\u00e9get \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got, hanem gyakorlatilag az \u00f6sszes. Most kiemelt\u00fcnk p\u00e1rat, melyek (m\u00e9g p. az Observert/Iteratort/Adaptert ide sorolva) tal\u00e1n a leggyakrabban, legsz\u00e9lesebb k\u00f6rben alkalmazhat\u00f3k \u00e9s bukkannak is fel keretrendszerekben.</p>"},{"location":"labor/7-adatkezeles/","title":"7. Adatkezel\u00e9s","text":""},{"location":"labor/7-adatkezeles/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl.</p> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek.</p>"},{"location":"labor/7-adatkezeles/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>A gyakorlat sor\u00e1n Visual Studio-ban az SQL Server Object Explorer-t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben, de a Data Storage and Processing workload is tartalmazza ezt.</li> </ul> <p>Gyakorlat Linuxon vagy Macen</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studio-ra k\u00e9sz\u00fclt, de - n\u00e9mik\u00e9ppen m\u00e1s \u00faton - elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is, mivel a .NET 6 SDK t\u00e1mogatott Linuxon \u00e9s Mac-en is, Linuxon:</p> <ul> <li>Visual Studio helyett, sz\u00f6vegszerkeszt\u0151vel (pl.: VSCode) \u00e9s CLI eszk\u00f6z\u00f6kkel.</li> <li>Az SQL szervernek van Linuxos v\u00e1ltozata, Mac-en pedig Dockerben futtathat\u00f3 (de Linuxon is tal\u00e1n a Docker legk\u00e9nyelmesebb m\u00f3d a futtat\u00e1s\u00e1ra).</li> <li>Az adatok vizualiz\u00e1ci\u00f3j\u00e1ra haszn\u00e1lhat\u00f3 a szint\u00e9n keresztplatformos Azure Data Studio eszk\u00f6z.</li> </ul>"},{"location":"labor/7-adatkezeles/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-adatkezeles-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/7-adatkezeles/#bevezeto","title":"Bevezet\u0151","text":"Megjegyz\u00e9s gyakorlatvezet\u0151knek <p>Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden.</p>"},{"location":"labor/7-adatkezeles/#adonet","title":"ADO.NET","text":"<p>Alacsony szint\u0171 adatb\u00e1zis-kezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni.</p> <p>Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk:</p> <ul> <li>Kapcsolatalap\u00fa modell</li> <li>Kapcsolat n\u00e9lk\u00fcli modell</li> </ul> <p>Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l.</p> A Kapcsolatalap\u00fa modell alapelvei <p>L\u00e9nyege az, hogy az adatb\u00e1zis-kapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le.</p> <p>A modell el\u0151nyei:</p> <ul> <li>Egyszer\u0171bb a konkurencia kezel\u00e9se</li> <li>Az adatok mindenhol a legfrissebbek</li> </ul> <p>Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9shez az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. (Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre.)</p> <p>H\u00e1tr\u00e1nyok:</p> <ul> <li>Folyamatos h\u00e1l\u00f3zati kapcsolat</li> <li>Sk\u00e1l\u00e1zhat\u00f3s\u00e1g hi\u00e1nya</li> </ul> A Kapcsolat-n\u00e9lk\u00fcli modell alapelvei <p>A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a <code>DataSet</code> objektumok alkalmaz\u00e1sa.</p> <p>A modell el\u0151nyei:</p> <ul> <li>Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat</li> <li>Sk\u00e1l\u00e1zhat\u00f3s\u00e1g</li> </ul> <p>H\u00e1tr\u00e1nyok</p> <ul> <li>Az adatok nem mindig a legfrissebbek</li> <li>\u00dctk\u00f6z\u00e9sek lehets\u00e9gesek</li> </ul> <p>Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A <code>DataSet</code> csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 - az ADO.NET-n\u00e9l korszer\u0171bb - .NET technol\u00f3gi\u00e1kat (pl. Entity Framework Core).</p>"},{"location":"labor/7-adatkezeles/#a-kapcsolatalapu-modell","title":"A kapcsolatalap\u00fa modell","text":"<p>A labor keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg.</p> <p>Az alapfolyamat a k\u00f6vetkez\u0151:</p> <ol> <li>Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s, illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt (<code>Connection</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1sa (<code>Command</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>Utas\u00edt\u00e1s futtat\u00e1sa (<code>Command</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa (<code>DataReader</code> objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g.</li> <li>Kapcsolat lez\u00e1r\u00e1sa.</li> </ol> <p>Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van:</p> <ul> <li>Connection</li> <li>Command</li> <li>Data Reader</li> </ul> <p>Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1zis-kezel\u0151-f\u00fcggetlen r\u00e9sz\u00fck a BCL System.Data.Common n\u00e9vter\u00e9ben tal\u00e1lhat\u00f3 <code>DbConnection</code>, <code>DbCommand</code>, illetve <code>DbDataReader</code> n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1zis-kezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1zis-kezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat.</p> <p>Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy <code>using</code> blokkban haszn\u00e1lhat\u00f3k \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1zis-kezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a labor sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra.</p> <p>A Microsoft SQL Server-t t\u00e1mogat\u00f3 v\u00e1ltozat a Microsoft.Data.SqlClient NuGet csomagban, az \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k (<code>SqlConnection</code>, <code>SqlCommand</code> \u00e9s <code>SqlDataReader</code>).</p> <p>A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data provider-nek nevezik. Teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl n\u00e9h\u00e1ny p\u00e9lda:</p> <ul> <li>PostgreSQL</li> <li>SQLite </li> <li>Oracle</li> </ul>"},{"location":"labor/7-adatkezeles/#connection","title":"Connection","text":"<p>Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1zis-kezel\u0151-rendszer k\u00f6z\u00f6tt. Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, mely a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 a bels\u0151 form\u00e1tuma (b\u0151vebben).</p> <p>\u00daj <code>Connection</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat.</p> <p>A <code>Connection</code> k\u00fcl\u00f6n\u00f6sen k\u00f6lts\u00e9ges nem fel\u00fcgyelt er\u0151forr\u00e1sokat haszn\u00e1l, \u00edgy kiemelten fontos, hogy a lehet\u0151 leghamarabb gondoskodjunk lez\u00e1r\u00e1s\u00e1r\u00f3l, amikor m\u00e1r nincs r\u00e1 sz\u00fcks\u00e9g (pl. a <code>Dispose()</code> h\u00edv\u00e1s\u00e1val, amit az esetek t\u00f6bbs\u00e9g\u00e9ben legegyszer\u0171bben a <code>using</code> blokk alkalmaz\u00e1s\u00e1val tehet\u00fcnk meg).</p>"},{"location":"labor/7-adatkezeles/#command","title":"Command","text":"<p>Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A <code>Command</code>-nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel futtatjuk a parancsot:</p> <ul> <li>ExecuteReader: Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se</li> <li>ExecuteScalar: Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se</li> <li>ExecuteNonQuery: Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT, UPDATE \u00e9s DELETE), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk</li> </ul>"},{"location":"labor/7-adatkezeles/#data-reader","title":"Data Reader","text":"<p>Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a <code>Data Reader</code> ezen tud soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak egyes\u00e9vel el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon.</p> <p>Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz.</p>"},{"location":"labor/7-adatkezeles/#1-feladat-adatbazis-elokeszitese","title":"1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se","text":"<p>Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1zis-kezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes-\u00e9rt\u00e9k\u0171 adatb\u00e1zis-kezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb egy fejleszt\u0151i adatb\u00e1zis-kezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zismotort, ez a LocalDB, mely a teljes-\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai:</p> <ul> <li>nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151,</li> <li>az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes-\u00e9rt\u00e9k\u0171 Microsoft SQL Server-rel,</li> <li>alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, melyre telep\u00edtett\u00fck,</li> <li>t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151k el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt),</li> <li>a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat.</li> </ul> ssqllocaldb parancssori eszk\u00f6z <p>A gyakorlat sor\u00e1n nincs sz\u00fcks\u00e9g\u00fcnk erre, de a p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az <code>sqllocaldb</code> parancssori eszk\u00f6z haszn\u00e1lhat\u00f3.  N\u00e9h\u00e1ny parancs, melyet az <code>sqllocaldb</code> ut\u00e1n be\u00edrva alkalmazhatunk:</p> Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u00faj p\u00e9ld\u00e1ny l\u00e9trehoz\u00e1sa \u201elocdb\u201d n\u00e9vvel delete \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa <p>A Visual Studio is telep\u00edt, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapesetben milyen p\u00e9ld\u00e1nyokat l\u00e1t.</p> <ol> <li>Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE).</li> <li>Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit).</li> <li>Ha nem jelent meg semmi, akkor parancssorb\u00f3l az <code>mssqllocaldb info</code> parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB</li> <li>A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, javasolt a Neptun k\u00f3d, mint n\u00e9v haszn\u00e1lata).</li> <li>Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit.</li> <li>Nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet.</li> <li>M\u00e1soljuk be a teljes szkriptet a query ablakba.</li> <li>Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal (Execute). Figyelj\u00fcnk oda, hogy j\u00f3 adatb\u00e1zis (melyet fenti 4. l\u00e9p\u00e9sben hoztunk l\u00e9tre) legyen kiv\u00e1lasztva a query ablak tetej\u00e9n a leg\u00f6rd\u00fcl\u0151ben!.</li> <li>Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunkban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek.</li> <li>Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.).</li> </ol> <p>MSSQL menedzsment eszk\u00f6z\u00f6k</p> <p>A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1zis-kezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1zis-kezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk.</p> <p>Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t vagy a szint\u00e9n ingyenes \u00e9s multiplatform Azure Data Studio-t tudjuk haszn\u00e1lni.</p>"},{"location":"labor/7-adatkezeles/#2-feladat-lekerdezes-adonet-sqldatareader-rel","title":"2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel","text":"<p>A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely haszn\u00e1lja a Northwind adatb\u00e1zis <code>Shippers</code> t\u00e1bl\u00e1j\u00e1nak rekordjait.</p> <ol> <li> <p>Hozzunk l\u00e9tre egy C# nyelv\u0171 konzolos alkalmaz\u00e1st. A projekt t\u00edpusa Console App legyen, \u00e9s NE a Console App (.NET Framework):</p> <ul> <li>A projekt neve legyen AdoExample</li> <li>A Target Framework legyen .NET 6</li> <li>Pip\u00e1ljuk be a Do not use top-level statements kapcsol\u00f3t</li> </ul> </li> <li> <p>Keress\u00fck ki a connection string-et az SSOE-b\u0151l: jobbklikk az adatb\u00e1zis-kapcsolatunkon (pirossal jel\u00f6lve az al\u00e1bbi \u00e1br\u00e1n) / Properties.</p> <p></p> </li> <li> <p>M\u00e1soljuk a Properties ablakb\u00f3l a Connection String tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t egy v\u00e1ltoz\u00f3ba, a <code>Program</code> oszt\u00e1lyba.</p> <pre><code>private const string ConnString = @\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=neptun;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\";\n</code></pre> <p>SQL Server connection string form\u00e1tuma</p> <p>MSSQL eset\u00e9ben a connection string kulcs \u00e9rt\u00e9kp\u00e1rokat tartalmaz pontosvessz\u0151vel elv\u00e1lasztva. A <code>Data Source</code> kulcs alatt az SQL szerver p\u00e9ld\u00e1ny neve, az<code>Initial Catalog</code> kulcs alatt pedig az adatb\u00e1zis neve szerepel. Az <code>Integrated Security=true</code> kapcsol\u00f3 pedig a Windows autentik\u00e1ci\u00f3t jelenti.</p> <p>@-os string (C# verbatim string)</p> <p>A <code>@</code> egy speci\u00e1lis karakter (verbatim identifier), amit itt arra haszn\u00e1lunk, hogy a connection string-ben megjelen\u0151 backslash karakter (<code>\\</code>) ne felold\u00f3jelk\u00e9nt (escape character) ker\u00fclj\u00f6n \u00e9rtelmez\u00e9sre.</p> </li> <li> <p>Vegy\u00fck fel a projektbe a <code>Microsoft.Data.SqlClient</code> NuGet csomagot. Ezt k\u00e9tf\u00e9lek\u00e9ppen tehetj\u00fck meg:</p> <ul> <li>A) Visual Studio NuGet kezel\u0151ben:<ol> <li>Projekten jobb gomb / Manage NuGet Packages..., a megjelen\u0151 oldalon Browse oldalra v\u00e1lt\u00e1s.</li> <li>A keres\u0151be Microsoft.Data.SqlClient be\u00edr\u00e1sa.</li> <li>A Version mez\u0151ben az 5.0.1 kiv\u00e1laszt\u00e1sa (laboron az\u00e9rt v\u00e1lasztjuk ki ezt a verzi\u00f3t, mert ez szerepel a g\u00e9peken a NuGet cache-ben, otthoni gyakorl\u00e1s sor\u00e1n v\u00e1lasszuk ink\u00e1bb a Latest stable-t).</li> </ol> </li> <li> <p>B) Bem\u00e1soljuk az al\u00e1bbi csomag referenci\u00e1t a a projektf\u00e1jlba:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Microsoft.Data.SqlClient\" Version=\"5.0.1\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> </li> </ul> <p>NuGet csomagkezel\u0151</p> <p>A NuGet egy olyan online csomagkezel\u0151 rendszer, ahonnan .NET alap\u00fa projektjeinkbe tudunk k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket, oszt\u00e1lyk\u00f6nyvt\u00e1rakat egyszer\u0171en, verzi\u00f3zott form\u00e1ban behivatkozni. B\u0151vebben az els\u0151 el\u0151ad\u00e1son szerepel.</p> </li> <li> <p>\u00cdrjunk lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt, mely lek\u00e9rdezi az \u00f6sszes sz\u00e1ll\u00edt\u00f3t:</p> <pre><code>private static void GetShippers()\n{\n    using (var conn = new SqlConnection(ConnString))\n    using (var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn))\n    {\n        conn.Open();\n        Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\", \"ShipperID\", \"CompanyName\", \"Phone\");\n        Console.WriteLine(new string('-', 60));\n        using (SqlDataReader reader = command.ExecuteReader())\n        {\n            while (reader.Read())\n            {\n                Console.WriteLine(\n                    $\"{reader[\"ShipperID\"],-10}\" +\n                    $\"{reader[\"CompanyName\"],-20}\" +\n                    $\"{reader[\"Phone\"],-20}\");\n            }\n        }\n    }\n}\n</code></pre> <p>A kapcsolat alap\u00fa modell folyamata:</p> <ul> <li>Kapcsolat, parancs inicializ\u00e1l\u00e1sa</li> <li>Kapcsolat megnyit\u00e1sa</li> <li>Parancs futtat\u00e1sa</li> <li>Eredm\u00e9ny feldolgoz\u00e1sa</li> <li>Kapcsolat bont\u00e1sa, takar\u00edt\u00e1s</li> </ul> <p>N\u00e9h\u00e1ny megjegyz\u00e9s a k\u00f3dhoz</p> <ul> <li>A <code>DataReader</code>-t a parancs futtat\u00e1s\u00e1nak eredm\u00e9nyek\u00e9nt kapjuk meg, nem pedig k\u00f6zvetlen\u00fcl p\u00e9ld\u00e1nyos\u00edtjuk</li> <li>A parancs futtat\u00e1sa el\u0151tt meg kell nyitnunk a kapcsolatot</li> <li>A <code>DbConnection</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem nyit\u00f3dik meg a kapcsolat (nem t\u00f6rt\u00e9nik h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3)</li> <li>A <code>DataReader.Read()</code> f\u00fcggv\u00e9nye mutatja, hogy van-e m\u00e9g adat az eredm\u00e9nyhalmazban</li> <li>A <code>DataReader</code>-t az eredm\u00e9nyhalmazban tal\u00e1lhat\u00f3 oszlopok nev\u00e9vel indexelhetj\u00fck \u2013 az eredm\u00e9ny <code>object</code> lesz, \u00edgy, ha konkr\u00e9tabb t\u00edpusra van sz\u00fcks\u00e9g\u00fcnk cast-olni kell</li> <li>A ford\u00edt\u00f3 nem \u00e9rtelmezi az SQL parancs sz\u00f6veg\u00e9t (az csak egy string), hanem majd csak az adatb\u00e1zis, \u00edgy hib\u00e1s SQL eset\u00e9n csak fut\u00e1si idej\u0171 kiv\u00e9telt kapunk</li> <li>Figyelj\u00fck meg, hogy az adatb\u00e1zis s\u00e9ma v\u00e1ltoz\u00e1sa eset\u00e9n, pl. egy oszlop \u00e1tnevez\u00e9se ut\u00e1n, h\u00e1ny helyen kell k\u00e9zzel \u00e1t\u00edrni string-eket a k\u00f3dban</li> <li><code>$</code>-ral prefixelve string interpol\u00e1ci\u00f3t alkalmazhatunk, azaz k\u00f6zvetlen\u00fcl a string-be \u00e1gyazhatunk ki\u00e9rt\u00e9kelend\u0151 kifejez\u00e9seket (C# 6-os k\u00e9pess\u00e9g). A <code>$@</code> seg\u00edts\u00e9g\u00e9vel t\u00f6bbsoros string interpol\u00e1ci\u00f3s kifejez\u00e9seket \u00edrhatunk (a sort\u00f6r\u00e9st a {}-k k\u00f6z\u00f6tt kell betenn\u00fcnk, k\u00fcl\u00f6nben a kimeneten is megjelenik). \u00c9rdekess\u00e9g: C# 8-t\u00f3l f\u00f6lfele b\u00e1rmilyen sorrendben \u00edrhatjuk a $ \u00e9s @ karaktereket, teh\u00e1t a <code>$@</code> \u00e9s a <code>@$</code> is helyesnek sz\u00e1m\u00edt.</li> <li> <p>A using kulcssz\u00f3 blokk utas\u00edt\u00e1s helyett egysoros kifejez\u00e9sk\u00e9nt is haszn\u00e1lhat\u00f3. Ilyen esetben a using blokk v\u00e9ge a tartalmaz\u00f3 blokkig tart (eset\u00fcnkben a f\u00fcggv\u00e9ny v\u00e9g\u00e9ig). Ezzel cs\u00f6kkenthet\u0151 a beh\u00faz\u00e1sok sz\u00e1ma, de ne legyen automatikus reflex a haszn\u00e1lata, mert el\u0151fordulhat, hogy hamarabb c\u00e9lszer\u0171 kik\u00e9nyszer\u00edteni az er\u0151forr\u00e1sok felszabad\u00edt\u00e1s\u00e1t, mint a tartalmaz\u00f3 blokk v\u00e9ge.</p> <pre><code>private static void GetShippers()\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn);\n\n    conn.Open();\n\n    Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\",\"ShipperID\", \"CompanyName\", \"Phone\");\n    Console.WriteLine(new string('-', 60));\n\n    using var reader = command.ExecuteReader();\n    while (reader.Read())\n    {\n        Console.WriteLine(\n            $\"{reader[\"ShipperID\"],-10}\" +\n            $\"{reader[\"CompanyName\"],-20}\" +\n            $\"{reader[\"Phone\"],-20}\");\n    }\n}\n</code></pre> <p>A tov\u00e1bbiakban ezt a m\u00f3dszert haszn\u00e1ljuk a beh\u00faz\u00e1sok \u00e9s z\u00e1r\u00f3jelek megsp\u00f3rol\u00e1sa \u00e9rdek\u00e9ben.</p> </li> </ul> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l.</p> <pre><code>private static void Main(string[] args)\n{\n    GetShippers();\n}\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Rontsuk el az SQL-t, \u00e9s \u00fagy is pr\u00f3b\u00e1ljuk ki.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#3-feladat-beszuras-sql-utasitassal","title":"3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal","text":"<ol> <li> <p>\u00cdrjunk f\u00fcggv\u00e9nyt, mely \u00faj sz\u00e1ll\u00edt\u00f3t sz\u00far be az adatb\u00e1zisba:</p> <pre><code>private static void InsertShipper(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        \"INSERT INTO Shippers(CompanyName, Phone) VALUES(@name,@phone)\", conn);\n    command.Parameters.AddWithValue(\"@name\", companyName);\n    command.Parameters.AddWithValue(\"@phone\", phone);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>Itt olyan SQL-t kell \u00edrnunk, melynek az \u00f6ssze\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l k\u00edv\u00fclr\u0151l kapott v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit is felhaszn\u00e1ltuk. A string \u00f6sszerak\u00e1s\u00e1hoz egyszer\u0171en a string \u00f6sszef\u0171z\u00e9s oper\u00e1tort, string interpol\u00e1ci\u00f3t vagy <code>string.Format</code>-ot is haszn\u00e1lhattunk volna, de ez biztons\u00e1gi kock\u00e1zatot (SQL Injection \u2013 b\u0151vebben l\u00e1sd lentebb) rejt \u2013 SOHA!!! ne rakjuk \u00f6ssze az SQL-t string m\u0171velettel. Helyette \u00edrjuk meg \u00fagy az SQL-t, hogy ahov\u00e1 a v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit \u00edrn\u00e1nk, oda param\u00e9terhivatkoz\u00e1sokat tesz\u00fcnk. SQL Server eset\u00e9ben a hivatkoz\u00e1s szintaxisa: @param\u00e9tern\u00e9v.</p> <p>A parancs futtat\u00e1s\u00e1hoz a param\u00e9terek \u00e9rt\u00e9keit is \u00e1t kell adnunk az adatb\u00e1zisnak, ugyanis az fogja elv\u00e9gezni a param\u00e9terek hely\u00e9re az \u00e9rt\u00e9kek behelyettes\u00edt\u00e9s\u00e9t.</p> <p>A besz\u00far\u00e1si parancs kimenete nem eredm\u00e9nyhalmaz, \u00edgy az <code>ExecuteNonQuery</code> m\u0171velettel kell futtatnuk, mely visszaadja besz\u00fart sorok sz\u00e1m\u00e1t.</p> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l.</p> <pre><code>GetShippers();\nInsertShipper(\"Super Shipper\",\"49-98562\");\nGetShippers();\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy beker\u00fclt-e az \u00faj sor. Az SSOE-ben val\u00f3 gyors \u00e9s k\u00e9nyelmes ellen\u0151rz\u00e9shez a <code>Shippers</code> t\u00e1bla context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Data lehet\u0151s\u00e9get.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#4-feladat-modositas-tarolt-eljarassal","title":"4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal","text":"<ol> <li> <p>Tanulm\u00e1nyozzuk SSOE-ben a <code>Product_Update</code> t\u00e1rolt elj\u00e1r\u00e1s k\u00f3dj\u00e1t. Ehhez nyissuk le a Programmability alatt tal\u00e1lhat\u00f3 Stored Procedures csom\u00f3pontot, majd a <code>Product_Update</code> t\u00e1rolt elj\u00e1r\u00e1s context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Code lehet\u0151s\u00e9get.</p> <p>Programk\u00f3d az adatb\u00e1zisban</p> <p>A nagyobb adatkezel\u0151 rendszerek lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy programk\u00f3dot defini\u00e1ljunk mag\u00e1ban az adatkezel\u0151 adatb\u00e1zis\u00e1ban. Ezeket t\u00e1rol elj\u00e1r\u00e1soknak (stored procedure) nevezz\u00fck. A nyelve adatkezel\u0151 f\u00fcgg\u0151, de MSSQL eset\u00e9ben ez T-SQL.</p> <p>Manaps\u00e1g m\u00e1r egyre ink\u00e1bb kezd kikopni az a gyakorlat az iparb\u00f3l, hogy komolyabb \u00fczleti logik\u00e1t az adatb\u00e1zisban helyezz\u00fcnk el, mivel ezeknek az SQL dialektusoknak az eszk\u00f6zk\u00e9szlete ma m\u00e1r j\u00f3val korl\u00e1tosabb, mint egy magas szint\u0171 programoz\u00e1si nyelv\u00e9 (C#, Java). R\u00e1ad\u00e1sul a rendszer tesztelhet\u0151s\u00e9g\u00e9t nagyban rontja a t\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata. Ennek ellen\u00e9re n\u00e9ha indokolt lehet az adatb\u00e1zisban tartani valamennyi logik\u00e1t, amikor ki szeretn\u00e9nk azt haszn\u00e1lni, hogy az adatokhoz k\u00f6zel futnak a programk\u00f3djaink, pl. ha nem akarjuk megutaztatni a h\u00e1l\u00f3zaton az adatot egy egyszer\u0171 t\u00f6meges adatkarbantart\u00e1s \u00e9rdek\u00e9ben.</p> </li> <li> <p>\u00cdrjunk f\u00fcggv\u00e9nyt, mely ezt a t\u00e1rolt elj\u00e1r\u00e1st h\u00edvja</p> <pre><code>private static void UpdateProduct(int productID, string productName, decimal price)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"Product_Update\", conn);\n\n    command.CommandType = CommandType.StoredProcedure;\n\n    command.Parameters.AddWithValue(\"@ProductID\", productID);\n    command.Parameters.AddWithValue(\"@ProductName\", productName);\n    command.Parameters.AddWithValue(\"@UnitPrice\", price);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>A <code>Command</code>-nak a t\u00e1rolt elj\u00e1r\u00e1s nev\u00e9t kellett megadni, \u00e9s a parancs t\u00edpus\u00e1t kellett \u00e1t\u00e1ll\u00edtani, egy\u00e9bk\u00e9nt szerkezetileg hasonl\u00edt a kor\u00e1bbi besz\u00far\u00f3 k\u00f3dra.</p> </li> <li> <p>H\u00edvjuk meg az \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l, p\u00e9ld\u00e1ul az al\u00e1bbi param\u00e9terez\u00e9ssel:</p> <pre><code>UpdateProduct(1, \"MyProduct\", 50);\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy m\u00f3dosult-e az 1-es azonos\u00edt\u00f3j\u00fa term\u00e9k.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#5-feladat-sql-injection","title":"5. Feladat - SQL Injection","text":"<ol> <li> <p>\u00cdrjuk meg a besz\u00far\u00f3 f\u00fcggv\u00e9nyt \u00fagy, hogy string interpol\u00e1ci\u00f3val rakja \u00f6ssze az SQL-t.</p> <pre><code>private static void InsertShipper2(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        $\"INSERT INTO Shippers(CompanyName, Phone) VALUES('{companyName}','{phone}')\",\n        conn);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n    Console.WriteLine($\"{affectedRows} row(s) inserted\");\n}\n</code></pre> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l \u201especi\u00e1lisan\u201d param\u00e9terezve.</p> <pre><code>InsertShipper2(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\n</code></pre> <p>\u00dagy \u00e1ll\u00edtottuk \u00f6ssze a m\u00e1sodik param\u00e9tert, hogy az lez\u00e1rja az eredeti utas\u00edt\u00e1st, ezut\u00e1n tetsz\u0151leges (!!!) SQL-t \u00edrhatunk, v\u00e9g\u00fcl kikommentezz\u00fck az eredeti utas\u00edt\u00e1s marad\u00e9k\u00e1t (<code>--</code>).</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, hib\u00e1t kell kapjunk, mely arra utal, hogy valamelyik sz\u00e1ll\u00edt\u00f3 nem t\u00f6r\u00f6lhet\u0151 idegen kulcs hivatkoz\u00e1s miatt.</p> <p>Teh\u00e1t a <code>DELETE FROM</code> is lefutott! N\u00e9zz\u00fck meg debugger-rel (pl. a <code>conn.Open</code> utas\u00edt\u00e1son \u00e1llva), hogy mi a v\u00e9gleges SQL (<code>command.CommandText</code>).</p> <p>Tanuls\u00e1gok:</p> <ul> <li>SOSE f\u0171zz\u00fcnk \u00f6ssze programozottan SQL-t (semmilyen m\u00f3dszerrel), mert azzal kitessz\u00fck a k\u00f3dunkat SQL Injection alap\u00fa t\u00e1mad\u00e1snak.</li> <li>Az adatb\u00e1zis \u00e1ll\u00edtsa \u00f6ssze a v\u00e9gleges SQL-t az SQL param\u00e9terek alapj\u00e1n, mert ilyenkor biztos\u00edtott, hogy a param\u00e9ter \u00e9rt\u00e9kek nem fognak SQL-k\u00e9nt \u00e9rtelmez\u0151dni (hi\u00e1ba \u00edrunk be SQL-t). Haszn\u00e1ljunk param\u00e9terezett SQL-t vagy t\u00e1rolt elj\u00e1r\u00e1st.</li> <li>Haszn\u00e1ljunk adatb\u00e1zis k\u00e9nyszereket, pl. a v\u00e9letlen t\u00f6rl\u00e9s ellen is v\u00e9d.</li> <li>Konfigur\u00e1ljunk adatb\u00e1zisban felhaszn\u00e1l\u00f3kat k\u00fcl\u00f6nb\u00f6z\u0151 jogosults\u00e1gokkal, a programunk connection string-j\u00e9ben megadott felhaszn\u00e1l\u00f3 csak a m\u0171k\u00f6d\u00e9shez sz\u00fcks\u00e9ges minim\u00e1lis jogokkal rendelkezzen. A mi eset\u00fcnkben nem adtunk meg felhaszn\u00e1l\u00f3t, a windows-os felhaszn\u00e1l\u00f3k\u00e9nt fogunk csatlakozni.</li> </ul> </li> <li> <p>H\u00edvjuk meg az eredeti (vagyis a biztons\u00e1gos, SQL param\u00e9tereket haszn\u00e1l\u00f3) besz\u00far\u00f3 f\u00fcggv\u00e9nyt a \u201especi\u00e1lis\u201d param\u00e9terez\u00e9ssel, hogy l\u00e1ssuk, m\u0171k\u00f6dik-e a v\u00e9delem:</p> <pre><code>InsertShipper(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\nInsertShipper(\"XXX');DELETE FROM Shippers;--\", \"49-98562\");\n</code></pre> <p>Az els\u0151n\u00e9l nem f\u00e9r\u00fcnk bele a m\u00e9retkorl\u00e1tba, a m\u00e1sodik lefut, de csak egy \u201efurcsa\u201d nev\u0171 sz\u00e1ll\u00edt\u00f3 ker\u00fclt be. A param\u00e9ter \u00e9rt\u00e9ke t\u00e9nyleg \u00e9rt\u00e9kk\u00e9nt \u00e9rtelmez\u0151d\u00f6tt nem pedig SQL-k\u00e9nt. Nem \u00fagy mint itt:</p> <p></p> </li> </ol>"},{"location":"labor/7-adatkezeles/#6-feladat-torles","title":"6. Feladat - T\u00f6rl\u00e9s","text":"<ol> <li> <p>\u00cdrjunk egy \u00faj f\u00fcggv\u00e9nyt, mely kit\u00f6r\u00f6l egy adott sz\u00e1ll\u00edt\u00f3t.</p> <pre><code>private static void DeleteShipper(int shipperID)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"DELETE FROM Shippers WHERE ShipperID = @ShipperID\", conn);\n    command.Parameters.AddWithValue(\"@ShipperID\", shipperID);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} row(s) affected\");\n}\n</code></pre> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l, pl. 1-gyel param\u00e9terezve.</p> </li> <li>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Val\u00f3sz\u00edn\u0171leg kiv\u00e9telt kapunk, ugyanis van hivatkoz\u00e1s (idegen kulcs k\u00e9nyszerrel) az adott rekordra.</li> <li>SSOE-b\u0151l n\u00e9zz\u00fck ki az azonos\u00edt\u00f3j\u00e1t egy olyan sz\u00e1ll\u00edt\u00f3nak, melyet mi vett\u00fcnk fel. Adjuk \u00e1t ezt az azonos\u00edt\u00f3t a t\u00f6rl\u0151 f\u00fcggv\u00e9nynek \u2013 ezt m\u00e1r ki tudja t\u00f6r\u00f6lni, hiszen nincs r\u00e1 hivatkoz\u00e1s.</li> </ol> <p>T\u00f6rl\u00e9si strat\u00e9gi\u00e1k</p> <p>L\u00e1that\u00f3, hogy a t\u00f6rl\u00e9s igen kock\u00e1zatos \u00e9s kisz\u00e1m\u00edthatatlan m\u0171velet az idegen kulcs k\u00e9nyszerek miatt. N\u00e9h\u00e1ny m\u00f3dszer a t\u00f6rl\u00e9s kezel\u00e9s\u00e9re:</p> <ul> <li>nem enged\u00e9lyezz\u00fck a t\u00f6rl\u00e9st: Ha hivatkoznak a t\u00f6rlend\u0151 rekordra, az adatb\u00e1zis hib\u00e1val t\u00e9r vissza (ahogy fent is l\u00e1thattuk).</li> <li>kaszk\u00e1d t\u00f6rl\u00e9s \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord is t\u00f6rl\u0151dj\u00f6n. Gyakran ez oda vezet, hogy minden idegen kulcs k\u00e9nyszer\u00fcnk ilyen lesz, \u00e9s egy (v\u00e9letlen) t\u00f6rl\u00e9ssel v\u00e9gigt\u00f6r\u00f6lhetj\u00fck ak\u00e1r a teljes adatb\u00e1zist, azaz nehezen j\u00f3solhat\u00f3 a t\u00f6rl\u00e9s hat\u00e1sa.</li> <li>hivatkoz\u00e1s NULL-oz\u00e1sa \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord idegen kulcs mez\u0151je <code>NULL</code> \u00e9rt\u00e9k\u0171 legyen. Csak akkor alkalmazhat\u00f3, ha a modell\u00fcnkben az adott idegen kulcs mez\u0151 <code>NULL</code>-ozhat\u00f3.</li> <li>logikai t\u00f6rl\u00e9s (soft delete) \u2013 t\u00f6rl\u00e9s m\u0171velet helyett csak egy flag oszlopot (pl. <code>IsDeleted</code>) \u00e1ll\u00edtunk be. El\u0151nye, hogy nem kell az idegen kulcs k\u00e9nyszerekkel foglalkoznunk, a t\u00f6r\u00f6lt adat rendelkez\u00e9sre \u00e1ll, ha sz\u00fcks\u00e9g lenne r\u00e1 (pl. undelete m\u0171velet). \u00c1m a m\u0171k\u00f6d\u00e9s bonyol\u00f3dik, mert foglalkozni kell azzal, hogy hogyan \u00e9s mikor sz\u0171rj\u00fck a t\u00f6r\u00f6lt rekordokat (pl. hogy ne jelenjenek meg a fel\u00fcleten, statisztik\u00e1kban), vagy hogyan kezelj\u00fck, ha egy nem t\u00f6r\u00f6lt rekord t\u00f6r\u00f6lt rekordra hivatkozik.</li> </ul>"},{"location":"labor/7-adatkezeles/#kitekintes","title":"Kitekint\u00e9s","text":"<p>A fenti ADO.NET alapm\u0171veleteket ebben az itt l\u00e1tott alapform\u00e1ban ritk\u00e1n haszn\u00e1lj\u00e1k k\u00e9t okb\u00f3l kifoly\u00f3an (m\u00e9g akkor is, ha ez a megk\u00f6zel\u00edt\u00e9s adja a legjobb teljes\u00edtm\u00e9nyt):</p> <ul> <li>Gyenge t\u00edpusoss\u00e1g (egy rekord adatait beolvasni egy oszt\u00e1ly property-jeibe igen k\u00f6r\u00fclm\u00e9nyes, cast-olni kell stb.)</li> <li>String-be k\u00f3dolt SQL (az elg\u00e9pel\u00e9sb\u0151l ered\u0151 hib\u00e1k csak fut\u00e1si id\u0151ben der\u00fclnek ki)</li> </ul> <p>Az el\u0151bbire megold\u00e1st jelenthetnek a k\u00fcl\u00f6nb\u00f6z\u0151 ADO.NET-et kieg\u00e9sz\u00edt\u0151 komponensek, pl.:</p> <ul> <li>Dapper</li> <li>PetaPoco</li> </ul> <p>Ezek a megold\u00e1sok egy minim\u00e1lis teljes\u00edtm\u00e9nyvesztes\u00e9g\u00e9rt cser\u00e9be nagyobb k\u00e9nyelmet k\u00edn\u00e1lnak.</p> <p>Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelentenek az ORM (Object-Relational-Mapping) rendszerek, cser\u00e9be ezek nagyobb overheaddel j\u00e1rnak, mint az el\u0151bb eml\u00edtett megold\u00e1sok. Az ORM-ek lek\u00e9pez\u00e9st alak\u00edtanak ki az adatb\u00e1zis \u00e9s az OO oszt\u00e1lyaink k\u00f6z\u00f6tt, \u00e9s ennek a lek\u00e9pez\u00e9snek a seg\u00edts\u00e9g\u00e9vel egyszer\u0171s\u00edtik az adatb\u00e1zis m\u0171veleteket. Az oszt\u00e1lyainkon v\u00e9gzett, t\u00edpusos k\u00f3ddal le\u00edrt m\u0171veleteinket automatikusan \u00e1tford\u00edtj\u00e1k a megfelel\u0151 adatb\u00e1zis m\u0171veletekre, \u00edgy a mem\u00f3riabeli objektummodell\u00fcnket szinkronban tartj\u00e1k az adatb\u00e1zissal. Az ORM-ek ebb\u0151l k\u00f6vetkez\u0151en kapcsolat n\u00e9lk\u00fcli modellt haszn\u00e1lnak. Ismertebb .NET-es ORM-ek:</p> <ul> <li>ADO.NET DataSet \u2013 els\u0151 gener\u00e1ci\u00f3s ORM, ma m\u00e1r nagyon ritk\u00e1n haszn\u00e1ljuk</li> <li>Entity Framework 6.x \u2013 (r\u00e9gi) .NET Framework leggyakrabban haszn\u00e1lt ORM keretrendszere</li> <li>Entity Framework Core (EF Core) \u2013 a jelenleg els\u0151dlegesen haszn\u00e1lt .NET ORM (open source)</li> <li>NHibernate \u2013 a Java-s Hibernate .NET-es portja (open source)</li> </ul> <p>Az Entity Framework Core-ral r\u00e9szletesebben foglalkozunk az Adatvez\u00e9relt rendszerek specializ\u00e1ci\u00f3 t\u00e1rgyban illetve a Szoftverfejleszt\u00e9s .NET platformon v\u00e1laszthat\u00f3 t\u00e1rgyban.</p>"},{"location":"labor/old-6-doc-view/","title":"6. Document-View architekt\u00fara","text":""},{"location":"labor/old-6-doc-view/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai:</p> <ul> <li>UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa</li> <li>A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban</li> <li>UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n</li> <li>A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (<code>Paint</code> esem\u00e9ny, <code>Invalidate</code>, <code>Graphics</code> haszn\u00e1lata)</li> </ul> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga:</p> <ul> <li>UML alap\u00fa modellez\u00e9s (1. gyakorlat)</li> <li>Windows Forms alkalmaz\u00e1sfejleszt\u00e9s</li> <li>Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara)</li> </ul>"},{"location":"labor/old-6-doc-view/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/old-6-doc-view/#a-gyakorlat-menete","title":"A gyakorlat menete","text":"<p>Az al\u00e1bbiak szerint fogunk dolgozni:</p> <ul> <li>A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se</li> <li>A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se</li> <li>Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se)</li> <li>A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se</li> </ul> Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra <p>A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st (innen kl\u00f3nozzuk ki: https://github.com/bmeviauab00/lab-docview-megoldas). A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik a feladat bemutat\u00e1sa.</p>"},{"location":"labor/old-6-doc-view/#1-feladat-a-feladat-ismertetese","title":"1. Feladat - A feladat ismertet\u00e9se","text":"<p>Interakt\u00edv FontEditor (bet\u0171t\u00edpus szerkeszt\u0151) k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s az aktu\u00e1lis bet\u0171k\u00e9szlet alapj\u00e1n tetsz\u0151leges p\u00e9ldasz\u00f6veg megjelen\u00edthet\u0151. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben:</p> <p></p> <p>A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia:</p> <ul> <li>T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface).</li> <li>\u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t).</li> <li>Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k (File/Save), bet\u00f6lthet\u0151k (File/Open), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 (File/Close). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF).</li> <li>A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se<ul> <li>Az oldal tetej\u00e9n (Sample text) egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt.</li> <li>Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy, az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet.</li> <li>Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck.</li> </ul> </li> <li>A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se<ul> <li>Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik.</li> <li>Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3</li> <li>\u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l</li> <li>\u2019+\u2019 gomb: nagy\u00edt\u00e1s</li> <li>\u2019-\u2019 gomb: kicsiny\u00edt\u00e9s</li> </ul> </li> </ul> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s vizsg\u00e1ljuk meg a m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen n\u00e9zz\u00fck meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl.</p> <p>Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor k\u00f3dmegjegyz\u00e9sekkel el van l\u00e1tva, mely seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t.</p>"},{"location":"labor/old-6-doc-view/#2-feladat-az-alkalmazas-megtervezese","title":"2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se","text":"<p>A c\u00e9l az, hogy l\u00e1ssuk, milyen folyamatot k\u00f6vetve, milyen l\u00e9p\u00e9sekben dolgozunk, mikor milyen tervez\u0151i l\u00e9p\u00e9seket kell meghoznunk. T\u00f6rekedj\u00fcnk oktat\u00f3i \u00e9s hallgat\u00f3i r\u00e9szr\u0151l is az interaktivit\u00e1sra, k\u00f6z\u00f6sen hozzuk meg a d\u00f6nt\u00e9seket.</p> <p>Hozzunk l\u00e9tre egy \u00faj C# nyelv\u0171 \u201eWindow Form App\u201d projektet (.NET 6-osat), legyen a neve FontEditor. Vegy\u00fcnk fel egy oszt\u00e1lydiagramot: projekten jobb katt, Add / New Item, majd a megjelen\u0151 ablakban Class Diagram kiv\u00e1laszt\u00e1sa, a neve maradhat az alap\u00e9rtelmezett. \u00c1ll\u00edtsuk be, hogy a diagram mutassa majd a m\u0171veletek szignat\u00far\u00e1it is (pl. jobb katt a h\u00e1tt\u00e9ren, Change Members Format / Display Full Signature). A gyakorlat nagy r\u00e9sz\u00e9ben ezt a diagramot fogjuk szerkeszteni.</p> <p>A k\u00e9sz oszt\u00e1lydiagram a k\u00f6vetkez\u0151, eddig fogunk fokozatosan eljutni:</p> <p></p>"},{"location":"labor/old-6-doc-view/#document-view-architektura","title":"Document-View architekt\u00fara","text":"<p>Az els\u0151 tervez\u0151i d\u00f6nt\u00e9s: architekt\u00far\u00e1t kell v\u00e1lasztani. A Document-View eset\u00fcnkben egy\u00e9rtelm\u0171 v\u00e1laszt\u00e1s: dokumentumokkal dolgozunk, \u00e9s t\u00f6bb n\u00e9zettel, melyeket szinkronban kell tartani. Az al\u00e1bbi \u00e1bra ismerteti a m\u0171k\u00f6d\u00e9st. A n\u00e9zetek az observerek, a document pedig a subject, melynek v\u00e1ltoz\u00e1saira az egyes n\u00e9zetek fel vannak iratkozva.</p> <p></p> <p>A D-V architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g\u00fcnk lesz dokumentum oszt\u00e1lyra, amely a dokumentum adatait t\u00e1rolja (tagv\u00e1ltoz\u00f3kban), mint pl. a n\u00e9v, el\u00e9r\u00e9si \u00fat, pixelm\u00e1trix. Tegy\u00fck fel, hogy a k\u00e9s\u0151bbiekben t\u00f6bb dokumentum t\u00edpust is t\u00e1mogatni kell majd: pl. megnyithatunk egy olyan tabf\u00fclet, melyen a BKK j\u00e1rm\u0171vekhez tudjuk rendelni a bet\u0171t\u00edpusokat (elektronikus kijelz\u0151). Vannak olyan dokumentum adatok, melyek minden dokumentum t\u00edpusban megjelennek (pl. n\u00e9v, el\u00e9r\u00e9si \u00fat). Az egyes dokumentum t\u00edpusoknak a k\u00f6z\u00f6s tulajdons\u00e1gait/m\u0171veleteit c\u00e9lszer\u0171 egy <code>Document</code> \u0151soszt\u00e1lyba kiszervezni, hogy ne legyenek duplik\u00e1lva az egyes dokumentum t\u00edpusokat reprezent\u00e1l\u00f3 dokumentum oszt\u00e1lyokban.</p> <ul> <li>Vegy\u00fck fel a <code>Document</code> oszt\u00e1lyt (ez az absztrakt \u0151s).</li> <li>Vegy\u00fcnk fel bele egy <code>string Name</code> property-t (ez jelenik meg a tabf\u00fcleken).</li> </ul> <p>A Document-View architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g van egy n\u00e9zet interf\u00e9szre (egy <code>Update</code> m\u0171velettel a n\u00e9zet \u00e9rtes\u00edt\u00e9s\u00e9hez), valamint a dokumentumoknak nyilv\u00e1n kell tartaniuk egy list\u00e1ban a n\u00e9zeteiket:</p> <ul> <li>Vegy\u00fck fel az <code>IView</code> interf\u00e9szt.</li> <li>Vegy\u00fcnk fel bele egy <code>Update</code> m\u0171veletet.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel egy <code>List&lt;IView&gt; views</code> mez\u0151t (a Fields-n\u00e9l). Jobb gombbal kattintsunk a mez\u0151 nev\u00e9n a diagramon, \u00e9s a men\u00fcb\u0151l Show as collection association kiv\u00e1laszt\u00e1sa.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel a <code>void AttachView(IView view)</code> m\u0171veletet, mellyel \u00faj n\u00e9zetet lehet beregisztr\u00e1lni.</li> <li>V\u00e9g\u00fcl vegy\u00fcnk fel egy <code>void DetachView(IView view)</code>-t, mert n\u00e9zetet bez\u00e1rni is lehet.</li> </ul> <p>T\u00e1mogatnunk kell az egyes dokumentumok tartalm\u00e1nak perziszt\u00e1l\u00e1s\u00e1t (ment\u00e9s/bet\u00f6lt\u00e9s). Ezekhez vegy\u00fcnk fel a <code>Document</code> \u0151sbe a megfelel\u0151 m\u0171veleteket:</p> <ul> <li><code>Document</code>-be <code>LoadDocument(string path)</code> felv\u00e9tele.</li> <li><code>Document</code>-be <code>SaveDocument(string path)</code> felv\u00e9tele.</li> <li>Mindkett\u0151 legyen absztrakt, hiszen csak az egyes dokumentum lesz\u00e1rmazottakban tudunk implement\u00e1ci\u00f3t megadni: szelekt\u00e1ljuk ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban az Inheritence modifier legyen Abstract.</li> </ul> <p>Az egyes dokumentumoknak t\u00e1mogatniuk kell a n\u00e9zeteik friss\u00edt\u00e9s\u00e9t, ez minden dokumentum t\u00edpusra k\u00f6z\u00f6s:</p> <ul> <li>A <code>Document</code>-be vegy\u00fck fel az <code>UpdateAllViews()</code>-t (ez felel meg az Observer minta Notify m\u0171velet\u00e9nek).</li> </ul>"},{"location":"labor/old-6-doc-view/#konkret-dokumentum-es-adatai","title":"Konkr\u00e9t dokumentum \u00e9s adatai","text":"<p>Sz\u00fcks\u00e9g van egy olyan dokumentum t\u00edpusra, ami a bet\u0171t\u00edpusok szerkeszt\u00e9s\u00e9hez tartozik, amely a tagv\u00e1ltoz\u00f3iban nyilv\u00e1ntartja a sz\u00fcks\u00e9ges adatokat: legyen a neve <code>FontEditorDocument</code>.</p> <ul> <li>Vegy\u00fck fel a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Sz\u00e1rmaztassuk a <code>Document</code>-b\u0151l (Toolbox \u2013 Inheritence kapcsolat).</li> <li>Ekkor a <code>LoadDocument</code> \u00e9s <code>SaveDocument</code> m\u0171veletekre automatikusan megsz\u00fcletik az override-ol\u00f3 m\u0171velet. Ha m\u00e9gsem lenne \u00edgy<ul> <li>Jel\u00f6lj\u00fck ki az \u0151sben a k\u00e9t m\u0171veletet.</li> <li>Copy</li> <li>Jel\u00f6lj\u00fck ki a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Paste</li> <li>Jel\u00f6lj\u00fck itt ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban a Instance Modifier legyen <code>override</code>.</li> </ul> </li> </ul> <p>A dokumentumunk tagv\u00e1ltoz\u00f3kban t\u00e1rolja az adatokat. Gondoljuk \u00e1t, hogy ezt hogyan c\u00e9lszer\u0171 megval\u00f3s\u00edtani. Lehetne egy h\u00e1romdimenzi\u00f3s t\u00f6mb (karakter \u2013 x \u2013 y), de ink\u00e1bb emelj\u00fck ki egy k\u00fcl\u00f6n oszt\u00e1lyba az egy adott karakter pixeleinek t\u00e1rol\u00e1s\u00e1t/menedzsel\u00e9s\u00e9t: vezess\u00fck be a <code>CharDef</code> oszt\u00e1lyt.</p> <p>Pixel t\u00f6mb helyett</p> <p>Az\u00e9rt nem a pixelt\u00f6mb\u00f6t haszn\u00e1ljuk k\u00f6zvetlen\u00fcl, mert csak egy \u00faj oszt\u00e1ly bevezet\u00e9s\u00e9vel van lehet\u0151s\u00e9g\u00fcnk kifejezetten ide tartoz\u00f3 m\u0171veletek bevezet\u00e9s\u00e9re, vagyis az egys\u00e9gbez\u00e1r\u00e1s korrekt megval\u00f3s\u00edt\u00e1s\u00e1ra.</p> <ul> <li>Vegy\u00fck fel a <code>CharDef</code> oszt\u00e1lyt.</li> <li> <p><code>CharDef</code>-be <code>bool[,] Pixels</code> tulajdons\u00e1g felv\u00e9tele.</p> <p>t\u00f6bbdimenzo\u00f3s t\u00f6mb\u00f6k C#-ban</p> <p>A fenti p\u00e9ld\u00e1ban egy t\u00f6bbdimenzi\u00f3s t\u00f6mb\u00f6t haszn\u00e1ltunk <code>bool[,]</code> \u00e9s nem t\u00f6mb\u00f6k t\u00f6mbj\u00e9t <code>bool[][]</code>, mivel ezt nyelvi szinten is t\u00e1mogatja a C# \u00e9s jobb teljes\u00edtm\u00e9nyt ny\u00fajt, mint a t\u00f6mb\u00f6k t\u00f6mbje, mert egy objektumk\u00e9nt t\u00f6rol\u00f3dik a heapen.</p> </li> <li> <p><code>CharDef</code>-be <code>char Character</code> felv\u00e9tele: az egyes <code>CharDef</code> oszt\u00e1lyok t\u00e1rolj\u00e1k magukr\u00f3l, hogy mely karakter pixeleit reprezent\u00e1lj\u00e1k.</p> </li> </ul> <p>A dokumentumnak lesz egy gy\u0171jtem\u00e9nye <code>CharDef</code> objektumokb\u00f3l: minden karakterhez pontosan egy darab. Gondoljuk \u00e1t, hogy a legc\u00e9lszer\u0171bb ezt megval\u00f3s\u00edtani. Az egyes karakterdefin\u00edci\u00f3kat a karakterk\u00f3djukkal akarjuk c\u00edmezni, \u00edgy a <code>Dictionary&lt;char, CharDef&gt;</code> ide\u00e1lis v\u00e1laszt\u00e1s: a karakterk\u00f3d a kulcs, az hozz\u00e1 tartoz\u00f3 <code>CharDef</code> pedig az \u00e9rt\u00e9k.</p> <ul> <li><code>FontEditorDocument</code>-be: <code>Dictionary&lt;char, CharDef&gt; charDefs</code> mez\u0151 felv\u00e9tele. Jobb katt, Show as collection association.</li> </ul>"},{"location":"labor/old-6-doc-view/#dokumentumok-menedzselese-app-singleton-osztaly","title":"Dokumentumok menedzsel\u00e9se - App Singleton oszt\u00e1ly","text":"<p>Az alkalmaz\u00e1sban nyilv\u00e1n kell tartani a megnyitott dokumentumok list\u00e1j\u00e1t. Mely oszt\u00e1ly felel\u0151ss\u00e9ge legyen? Vezess\u00fcnk be r\u00e1 egy alkalmaz\u00e1sszint\u0171 oszt\u00e1lyt: legyen a neve <code>App</code> (Windows Forms alatt m\u00e1r van <code>Application</code>, nem c\u00e9lszer\u0171 ezt a nevet v\u00e1lasztani). Ez lesz az alkalmaz\u00e1sunk \u201egy\u00f6k\u00e9roszt\u00e1lya\u201d.</p> <ul> <li>Vegy\u00fck fel az <code>App</code> oszt\u00e1lyt.</li> <li><code>App</code>-ba <code>List&lt;FontEditorDocument&gt; documents</code> mez\u0151 felv\u00e9tele, majd Show as collection association.</li> </ul> <p>Gondoljuk v\u00e9gig, hogyan t\u00f6rt\u00e9nik majd egy \u00faj dokumentum l\u00e9trehoz\u00e1sa (mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor): be kell k\u00e9rni a felhaszn\u00e1l\u00f3t\u00f3l a dokumentum nev\u00e9t, l\u00e9tre kell hozni egy <code>FontEditorDocument</code> objektumot, fel kell venni a megnyitott dokumentumok list\u00e1j\u00e1ba stb. Ezt a logik\u00e1t ne tegy\u00fck a GUI-ba (men\u00fcelem click esem\u00e9nykezel\u0151): tegy\u00fck abba az oszt\u00e1lyba, melynek a felel\u0151ss\u00e9ge a megnyitott dokumentumok menedzsel\u00e9se, amely t\u00e1rolja a sz\u00fcks\u00e9ges adatokat hozz\u00e1 (dokumentum lista). \u00cdgy legyen ez az <code>App</code> oszt\u00e1lyunk feladata, benne vegy\u00fck fel a sz\u00fcks\u00e9ges m\u0171veleteket:</p> <ul> <li><code>App</code>-ba <code>NewDocument</code> \u00e9s <code>OpenDocument</code> m\u0171veletek felv\u00e9tele.</li> </ul> <p>Most a dokumentum ment\u00e9st gondoljuk v\u00e9gig: a File/Save mindig az akt\u00edv dokumentumra vonatkozik. Valakinek nyilv\u00e1n kell tartani, melyik az akt\u00edv dokumentum: legyen ez az <code>App</code>, hiszen \u0151 t\u00e1rolja a dokumentumok list\u00e1j\u00e1t is.</p> <ul> <li>A Toolbox-on v\u00e1lasszuk ki az Association kapcsolatot. Az <code>App</code>-b\u00f3l h\u00fazzunk egy nyilat a <code>FontEditorDocument</code>-be. V\u00e1lasszuk ki az \u00fajonnan l\u00e9trehozott kapcsolatot, \u00e9s nevezz\u00fck \u00e1t <code>ActiveDocument</code>-re.</li> <li><code>App</code>-ba <code>void SaveActiveDocument()</code> felv\u00e9tele.</li> <li><code>App</code>-ba <code>void CloseActiveDocument\u00e1()</code> felv\u00e9tele.</li> </ul> <p>Konkr\u00e9t dokumentumra vagy absztrakt \u0151sre hivatkozzunk?</p> <p>Mivel az <code>App</code> oszt\u00e1lyunk alkalmaz\u00e1s specifikus funkci\u00f3kat l\u00e1t el, nyugodtan hivatkozhat a konkr\u00e9t dokumentum t\u00edpusra, \u00e9s felesleges az absztrakt \u0151st\u0151l f\u00fcggen\u00fcnk, mert az csak nem k\u00edv\u00e1nt castol\u00e1sokhoz vezetne.</p> <p>Az <code>App</code> objektumb\u00f3l \u00e9rtelemszer\u0171en csak egyet kell/szabad l\u00e9trehozni, amely a fut\u00f3 alkalmaz\u00e1st reprezent\u00e1lja. Van m\u00e9g egy probl\u00e9m\u00e1nk: a File/Save stb. men\u00fcelem click esem\u00e9nykezel\u0151ben el kell \u00e9rj\u00fck ezt az egy objektumot. Illetve, majd t\u00f6bb m\u00e1s helyen is. J\u00f3 lenne, ha nem kellene minden oszt\u00e1lyban k\u00fcl\u00f6n el\u00e9rhet\u0151v\u00e9 tenni (tagv\u00e1ltoz\u00f3 vagy f\u00fcggv\u00e9nyparam\u00e9ter form\u00e1j\u00e1ban), hanem b\u00e1rhonnan egyszer\u0171en el\u00e9rhet\u0151 lenne. Erre ny\u00fajt megold\u00e1st a Singleton tervez\u00e9si minta. Egy oszt\u00e1lyb\u00f3l csak egy objektumot enged l\u00e9trehozni, \u00e9s ahhoz glob\u00e1lis hozz\u00e1f\u00e9r\u00e9st biztos\u00edt, m\u00e9gpedig az oszt\u00e1ly nev\u00e9n \u00e9s egy statikus <code>Instance</code> property-n kereszt\u00fcl, pl. \u00edgy: <code>App.Instance.SaveDocument</code> stb. Nem val\u00f3s\u00edtjuk meg teljes \u00e9rt\u00e9k\u0171en, de tegy\u00fck meg az al\u00e1bbiakat:</p> <ul> <li><code>App</code>-ba <code>App Instance</code> property felv\u00e9tele. Properties ablakban static: true.</li> <li><code>App</code>-ba priv\u00e1t konstruktor felv\u00e9tele.</li> </ul> <p>Az <code>App</code>-oszt\u00e1llyal v\u00e9gezt\u00fcnk.</p>"},{"location":"labor/old-6-doc-view/#nezetek","title":"N\u00e9zetek","text":"<p>A n\u00e9zetekkel eddig nem foglalkoztunk, ez a k\u00f6vetkez\u0151 l\u00e9p\u00e9s. Futtassuk a k\u00e9sz alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, hogy h\u00e1ny t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g, melyikb\u0151l h\u00e1ny p\u00e9ld\u00e1ny lesz:</p> <ul> <li>K\u00e9t t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g: az egyik a mintasz\u00f6veget jelen\u00edti meg, a m\u00e1sik egy adott karakter szerkeszt\u00e9s\u00e9t teszi lehet\u0151v\u00e9.</li> <li>Legyen az el\u0151z\u0151 neve <code>SampleTextView</code>, az ut\u00f3bbi\u00e9 <code>FontEditorView</code>.</li> <li><code>SampleTextView</code>-b\u00f3l mindig egy van (egy adott dokumentumra vonatkoz\u00f3an), a <code>FontEditorView</code> objektumok ig\u00e9ny szerint j\u00f6nnek l\u00e9tre, 0..n p\u00e9ld\u00e1ny l\u00e9tezhet.</li> <li>Vegy\u00fck fel a k\u00e9t oszt\u00e1lyt.</li> <li>Implement\u00e1ltassuk vel\u00fck az <code>IView</code> interf\u00e9szt (Toolbox / Inheritence kapcsolat). Az <code>Update</code> m\u0171velet automatikusan implement\u00e1lva lesz.</li> </ul> <p>Az egyes n\u00e9zetek a dokumentumukb\u00f3l \u201et\u00e1pl\u00e1lkoznak\u201d, a a dokumentumukban t\u00e1rolt adatokat jelen\u00edtik meg, azokat m\u00f3dos\u00edtj\u00e1k. Ehhez, a D-V architekt\u00far\u00e1nak megfelel\u0151en el kell \u00e9rj\u00e9k a dokumentumukat.</p> <ul> <li>A <code>SampleTextView</code> \u00e9s <code>FontEditorView</code>-ban vegy\u00fcnk fel egy <code>FontEditorDocument</code> t\u00edpus\u00fa <code>document</code> nev\u0171 mez\u0151t (ha felvett\u00fck az egyikben, lehet copy-paste-tel m\u00e1solni a m\u00e1sikba), majd \"Show as Association\". Megjegyz\u00e9s: az\u00e9rt nem c\u00e9lszer\u0171 \u00e1ltal\u00e1nos <code>Document</code> t\u00edpus\u00fat felvenni (\u00e9s az interf\u00e9szbe felvinni), mert a view-knak a konkr\u00e9t dokumentum adatait (l\u00e1sd al\u00e1bb) el kell \u00e9rni\u00fck.</li> </ul> <p>Gondoljuk v\u00e9gig, milyen adattagokkal rendelkeznek az egyes n\u00e9zetek. Ehhez futtassuk az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg ism\u00e9t a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t.</p> <ul> <li>A <code>SampleTextView</code> t\u00e1rolja a mintasz\u00f6veget, melyet meg kell jelen\u00edteni. Vegy\u00fcnk fel egy <code>sampleText:string</code> mez\u0151t. Ha el kellene menteni a mintasz\u00f6veget is, akkor a <code>FontEditorDocument</code>-ben kellene t\u00e1rolni (\u00e9s onnan mindig lek\u00e9rdezni), mert az adatok ment\u00e9s\u00e9\u00e9rt a dokumentum oszt\u00e1lyunk a felel\u0151s.</li> <li>A <code>FontEditorView</code> k\u00e9t dolgot t\u00e1rol:<ul> <li>A karakter k\u00f3dja, melynek pixeleit megjelen\u00edti. Vegy\u00fcnk fel egy <code>editedChar: char</code> mez\u0151t.</li> <li>A nagy\u00edt\u00e1si t\u00e9nyez\u0151t (<code>zoom: double</code> felv\u00e9tele)</li> </ul> </li> </ul> <p>A n\u00e9zetek maguk felel\u0151sek a kirajzol\u00e1suk\u00e9rt:</p> <ul> <li><code>Draw (g:Graphics)</code> felv\u00e9tele mindk\u00e9t n\u00e9zetbe.</li> </ul>"},{"location":"labor/old-6-doc-view/#fonteditordocument-muveletek","title":"FontEditorDocument m\u0171veletek","text":"<p>A <code>FontEditorDocument</code>-ben egy priv\u00e1t list\u00e1ban van egyel\u0151re jelen a <code>CharDef</code>-ek list\u00e1ja. A n\u00e9zetek \u00edgy nem tudj\u00e1k el\u00e9rni, pedig a megjelen\u00edt\u00e9shez sz\u00fcks\u00e9g\u00fck lenne r\u00e1. A dokumentumunkban be kell vezess\u00fcnk olyan m\u0171veleteket, melyek a dokumentum \u00e1ltal t\u00e1rolt adatokat a n\u00e9zetek sz\u00e1m\u00e1ra el\u00e9rhet\u0151v\u00e9 teszik, \u00e9s lehet\u0151s\u00e9get biztos\u00edtanak a m\u00f3dos\u00edt\u00e1sra is.</p> <ul> <li>Mindk\u00e9t n\u00e9zet el kell \u00e9rje a megjelen\u00edtett karakterek pixeleit t\u00e1rol\u00f3 <code>CharDef</code> objektumokat. Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben a <code>GetCharDef(c:char):CharDef</code> m\u0171veletet. Ezt hossz\u00fa t\u00e1von majd \u00fagy lesz c\u00e9lszer\u0171 megval\u00f3s\u00edtani, hogy a <code>GetCharDef</code> nem az eredeti objektumot adja vissza, hanem annak egy m\u00e1solat\u00e1t (clone). Ha az eredetit adn\u00e1 vissza, akkor a n\u00e9zetek K\u00d6ZVETLEN\u00dcL tudn\u00e1k m\u00f3dos\u00edtani a pixelek \u00e9rt\u00e9k\u00e9t, ezt mi nem akarjuk (b\u00e1r a funkci\u00f3k b\u0151v\u00edt\u00e9s\u00e9vel r\u00e1k\u00e9nyszer\u00fclhet\u00fcnk).</li> <li>A <code>FontEditorView</code>-nak k\u00e9pesnek kell lennie egy adott <code>CharDef</code> adott koordin\u00e1t\u00e1ban lev\u0151 pixel \u00e9rt\u00e9k\u00e9t invert\u00e1lni (eg\u00e9r kattint\u00e1skor). Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben az <code>InvertCharDefPixel(c:char, x: int, y: int)</code> m\u0171veletet.</li> </ul>"},{"location":"labor/old-6-doc-view/#a-tervezes-zarasa","title":"A tervez\u00e9s z\u00e1r\u00e1sa","text":"<p>Eljutottunk oda, hogy megtervezt\u00fck az architekt\u00far\u00e1t, minden igaz\u00e1n l\u00e9nyeges d\u00f6nt\u00e9st meghoztunk. Az UML diagram alapj\u00e1n megsz\u00fcletett az oszt\u00e1lyok v\u00e1za. Ezt term\u00e9szetesen jelent\u0151sen b\u0151v\u00edteni kell, m\u00e9g sz\u00fcletnek \u00faj oszt\u00e1lyok is (pl. Form-ok, vez\u00e9rl\u0151k).</p>"},{"location":"labor/old-6-doc-view/#3-feladat-a-kesz-alkalmazas-attekintese","title":"3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se","text":"<p>Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t (laboron kb. 15 percben), annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t.</p> <p>T\u00f6lts\u00fck le  a k\u00e9sz megold\u00e1st. Ehhez parancssorban navig\u00e1ljunk a c:\\work\\ mapp\u00e1ba (ha a laborban dolgozunk), \u00e9s adjuk ki a k\u00f6vetkez\u0151 parancsot: <p><code>git clone https://github.com/bmeviauab00/lab-docview-megoldas</code></p> <p>Nyissuk meg a k\u00e9sz solution-t, futtassuk \u00e9s pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1s alapfunkci\u00f3it.</p>"},{"location":"labor/old-6-doc-view/#nezetek-megvalositasa","title":"N\u00e9zetek megval\u00f3s\u00edt\u00e1sa","text":"<p>Nyissuk meg a <code>FontEditorView</code>-t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A <code>FontEditorView</code> egyr\u00e9szt implement\u00e1lja az <code>IView</code> interf\u00e9szt, m\u00e1sr\u00e9szt a <code>UserControl</code>-b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. A Visual Studio designer fel\u00fclet\u00e9n ak\u00e1r bele is m\u00f3dos\u00edthatn\u00e1nk a layoutba \u00e9s a vez\u00e9rl\u0151k tulajdons\u00e1gaiba. Ha k\u00edv\u00e1ncsiak vagyunk, ki is pr\u00f3b\u00e1lhatjuk ezt (pl. a nagy\u00edt\u00e1s \u00e9s a kicsiny\u00edt\u00e9s gombok hely\u00e9nek megv\u00e1ltoztat\u00e1s\u00e1val).</p> <p>A <code>SampleTextView</code> is <code>UserControl</code> lesz\u00e1rmazott, b\u00e1r annak egyszer\u0171 a fel\u00fclete (nincsenek rajta m\u00e1s vez\u00e9rl\u0151k), \u00edgy lehetett volna k\u00f6z\u00f6ns\u00e9ges <code>Control</code> lesz\u00e1rmazott is.</p> <p> Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan <code>UserControl</code>-k\u00e9nt (esetleg <code>Control</code>-k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani.</p>"},{"location":"labor/old-6-doc-view/#egy-oldal-tab-elrendezese","title":"Egy oldal (tab) elrendez\u00e9se","text":"<p>Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A <code>UserControl</code>-ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a <code>FontDocumentControl</code>-t tervez\u0151i n\u00e9zetben. Ez egy olyan vez\u00e9rl\u0151, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki (<code>Label</code>, <code>TextBox</code>, <code>Panel</code>-ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u00e9rdekess\u00e9g pedig az, hogy a <code>SampleTextView</code>-t is a Toolbox-r\u00f3l drag&amp;drop-pal ker\u00fclt felhelyez\u00e9sre (pont \u00fagy, mintha egy be\u00e9p\u00edtett vez\u00e9rl\u0151 lenne). Annyit n\u00e9zz\u00fcnk meg, hogy a <code>SampleTextView</code> val\u00f3ban ott van a Toolbox tetej\u00e9n.</p>"},{"location":"labor/old-6-doc-view/#forgatokonyv-1-egy-pixel-invertalasa-nezetek-szinkronizalasa","title":"Forgat\u00f3k\u00f6nyv 1 \u2013 Egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa","text":"<p> Ez egy kiemelt jelent\u0151s\u00e9g\u0171 forgat\u00f3k\u00f6nyv, mert ezt illusztr\u00e1lja a D-V architekt\u00fara alapmechanizmus\u00e1t, a n\u00e9zetek friss\u00edt\u00e9s\u00e9t \u00e9s konzisztensen tart\u00e1s\u00e1t. Keress\u00fck meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz pixel invert\u00e1l\u00e1s folyamat elindul. A <code>FontEditorView.FontEditorView_MouseClick</code> a kiindul\u00f3pont. Itt az al\u00e1bb kiemelt sor a l\u00e9nyeg:</p> <pre><code>private void FontEditorView_MouseClick(object sender, MouseEventArgs e)\n{\n    int x = e.X / zoom;\n    int y = (e.Y - offsetY) / zoom;\n    if (x &gt;= CharDef.FontSize.Width)\n        return;\n\n    document.InvertCharDefPixel(editedChar, x, y);\n}\n</code></pre> <p>N\u00e9zz\u00fck meg a <code>FontEditorDocument.InvertCharDefPixel</code>-t. Az invert\u00e1lja a megfelel\u0151 <code>CharDef</code> pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor:</p> <pre><code>public void InvertCharDefPixel(char c, int x, int y)\n{\n    var charDef = GetCharDefCore(c);\n    if (charDef == null)\n        return;\n\n    charDef.Pixels[x, y] = !charDef.Pixels[x, y];\n\n    UpdateAllViews();\n}\n</code></pre> <p>Az <code>UpdateAllViews</code> a <code>Document</code> \u0151sben van, <code>Update</code>-et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az <code>Update</code> hogyan van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a <code>FontEditView</code>-t:</p> <pre><code>public void Update()\n{\n    Invalidate();\n}\n</code></pre> <p>Az <code>Update</code> hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az <code>Update</code>-ben nem tudunk rajzolni, csak az <code>OnPaint</code>-ben. \u00cdgy itt az <code>Invalidate</code> h\u00edv\u00e1ssal kiv\u00e1ltjuk a <code>Paint</code> esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban a n\u00e9zetek <code>Update</code> f\u00fcggv\u00e9ny\u00e9ben tipikusan egy <code>Invalidate</code> h\u00edv\u00e1s szokott lenni.</p> <p>Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a <code>FontEditView.OnPaint</code> megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis <code>CharDef</code>-et (mert a n\u00e9zet a D-V architekt\u00fara alapelveinek megfelel\u0151en nem t\u00e1rolja), majd ki kell azt rajzolni.</p> <pre><code>protected override void OnPaint(PaintEventArgs e)\n{\n    base.OnPaint(e);\n\n    var editedCharDef = document.GetCharDef(editedChar);\n\n    CharDefViewModel.DrawFont(e.Graphics, editedCharDef, 0, offsetY, zoom);\n}\n</code></pre> <p>Kirajzol\u00e1s logik\u00e1ja</p> <p>Mivel a kirajzol\u00e1s logik\u00e1ja a <code>FontEditorView</code>-ban \u00e9s a <code>SampleTextView</code>-ban is azonosan m\u0171k\u00f6dik a <code>Graphics</code> oszt\u00e1ly haszn\u00e1lat\u00e1val, kiszervezt\u00fck ezt egy <code>CharDefViewModel</code> seg\u00e9doszt\u00e1lyba az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g kedv\u00e9\u00e9rt.</p> <p>A <code>CharDef</code>-be nem c\u00e9lszer\u0171 rakni ezt a logik\u00e1t, mivel az egy n\u00e9zet f\u00fcggetlen adatreprezent\u00e1ci\u00f3, \u00e9s sokkal ink\u00e1bb a dokumentumhoz tartozik, mint a n\u00e9zethez.</p>"},{"location":"labor/old-6-doc-view/#forgatokonyv-2-uj-dokumentum-letrehozasa-opcionalis","title":"Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa (opcion\u00e1lis)","text":"<p>Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor.</p> <p>Nyissuk meg a <code>MainForm</code>-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, majd ugorjunk el a <code>Click</code> esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az <code>App</code> oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el:</p> <pre><code>App.Instance.NewDocument();\n</code></pre> <p>Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az <code>App</code>-ba.</p> <p>Tekints\u00fck \u00e1t az <code>App.NewDocument</code> t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban fussuk \u00e1t a fontosabb l\u00e9p\u00e9seket.</p> <ol> <li><code>NewDocForm</code> n\u00e9zet megnyit\u00e1sa \u00e9s v\u00e1rakoz\u00e1s a v\u00e1laszra.</li> <li>Sikeres v\u00e1lasz eset\u00e9n \u00faj <code>FontEditorDocument</code> l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentumok k\u00f6z\u00e9, valamint akt\u00edvv\u00e1 t\u00e9tele.</li> <li>\u00daj tab l\u00e9trehoz\u00e1sa a n\u00e9zetekkel.</li> </ol> <pre><code>public void NewDocument()\n{\n    // Bek\u00e9rj\u00fckk az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a\n    // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban.\n    var form = new NewDocForm(GetDocumentNames());\n    if (form.ShowDialog() != DialogResult.OK)\n        return;\n\n    // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentum list\u00e1ba.\n    var doc = new FontEditorDocument(form.FontName);\n    documents.Add(doc);\n\n    // Az \u00faj tab lesz az akt\u00edv, az activeDocument tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani.\n    UpdateActiveDocument(doc.Name);\n\n    CreateTabForNewDocument(doc);\n}\n</code></pre> <p>App oszt\u00e1ly felel\u0151ss\u00e9gi k\u00f6re</p> <p>Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben az <code>App</code> oszt\u00e1ly most t\u00f6bb felel\u0151ss\u00e9ggel is rendelkezik, de ide\u00e1lis esetben sz\u00e9t lenne szedve pl. a k\u00f6vetkez\u0151 oszt\u00e1lyokra a felel\u0151ss\u00e9gi k\u00f6r\u00f6knek megfelel\u0151en:</p> <ul> <li><code>DocumentManager</code>: a megjelen\u00edt\u00e9st\u0151l f\u00fcggetlen\u00fcl a dokumentumokat t\u00e1roln\u00e1.</li> <li><code>ViewManager</code>: feladata a n\u00e9zetek menedzsel\u00e9se, tabcontrolokhoz hozz\u00e1ad\u00e1sa stb. lenne.</li> </ul> <p>Az <code>App.OpenDocument</code> m\u0171velet t\u00f6rzse nincs implement\u00e1lva, de a l\u00e9p\u00e9sek k\u00f3dmegjegyz\u00e9sek form\u00e1j\u00e1ban adottak, remek otthoni gyakorl\u00e1si lehet\u0151s\u00e9g a m\u0171velet t\u00e9nyleges megval\u00f3s\u00edt\u00e1sa.</p>"},{"location":"labor/old-7-tervezesi-mintak/","title":"7. Tervez\u00e9si mint\u00e1k","text":""},{"location":"labor/old-7-tervezesi-mintak/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai:</p> <ul> <li>Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento).</li> <li>A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik.</li> <li>Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba.</li> <li>Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa).</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok:</p> <ul> <li>Tervez\u00e9si mint\u00e1k</li> <li>Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara</li> <li>Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-designpattern-kiindulo -b megoldas-refactor-elott</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/old-7-tervezesi-mintak/#bevezeto","title":"Bevezet\u0151","text":""},{"location":"labor/old-7-tervezesi-mintak/#elmeleti-hatter","title":"Elm\u00e9leti h\u00e1tt\u00e9r","text":"<p>A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-feladat-ismertetese","title":"A feladat ismertet\u00e9se","text":"<p>A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se:</p> <ul> <li>Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis stb.</li> <li>A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni).</li> <li>A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen.</li> <li>Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk.</li> <li>Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok).</li> <li>Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#1-feladat-a-kiindulasi-kornyezet-megismerese","title":"1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se","text":"<p>Kl\u00f3nozzuk le a gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot,</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-designpattern-kiindulo</code></li> <li>Nyissuk meg a DesignPatternApp.sln solutiont Visual Studio-ban.</li> </ul> <p>Futtassuk az alkalmaz\u00e1st, az al\u00e1bbihoz hasonl\u00f3 fel\u00fcletet l\u00e1tunk (amennyiben a File/New men\u00fcelemet kiv\u00e1lasztjuk):</p> <p></p> <p>Ismerkedj\u00fcnk meg m\u0171k\u00f6d\u00e9s\u00e9nek n\u00e9h\u00e1ny aspektus\u00e1val:</p> <ul> <li>A legt\u00f6bb funkci\u00f3 nincs m\u00e9g megval\u00f3s\u00edtva.</li> <li>A File/New men\u00fcelem valamint a toolbar els\u0151 gombja egy \u00faj dokumentumot hoz l\u00e9tre. Ez m\u00e1r m\u0171k\u00f6dik, pr\u00f3b\u00e1ljuk ki.</li> <li>Mivel \u00faj alakzatot jelen pillanatban m\u00e9g nem tudunk l\u00e9trehozni, a dokumentum a l\u00e9trej\u00f6tt\u00e9t k\u00f6vet\u0151en nem \u00fcres, tartalmaz n\u00e9mi tesztel\u00e9st szolg\u00e1l\u00f3 adatot (k\u00e9t t\u00e9glalapot \u00e9s egy ellipszist).</li> <li>Az alakzatok kirajzol\u00e1sa is meg van val\u00f3s\u00edtva. Ezen fel\u00fcl a jobb oldali inform\u00e1ci\u00f3s panelen l\u00e1thatjuk a m\u00e1r l\u00e9tez\u0151 alakzatok param\u00e9tereit.</li> <li>Az alakzatok k\u00f6z\u00fcl egy ki lehet v\u00e1lasztva: ez piros sz\u00ednnel \u00e9s szaggatott k\u00e9k kerettel ker\u00fcl kirajzol\u00e1sra, illetve az inform\u00e1ci\u00f3s panelen ki is van v\u00e1lasztva az alakzathoz tartoz\u00f3 sor. \u00daj alakzat kijel\u00f6l\u00e9s\u00e9re az inform\u00e1ci\u00f3s panelen a megfelel\u0151 sor kiv\u00e1laszt\u00e1s\u00e1val van m\u00f3d. Ezt pr\u00f3b\u00e1ljuk is ki. Azt tapasztaljuk, hogy v\u00e1ltoztat\u00e1skor a bal oldali grafikus fel\u00fclet is friss\u00fcl, a kiv\u00e1lasztott alakzat sz\u00edne piros lesz. Hangs\u00falyozzuk, hogy ez bizony a klasszikus dokumentum-n\u00e9zet architekt\u00fara alap\u00fa megk\u00f6zel\u00edt\u00e9s ig\u00e9ny\u00e9t veti fel: a dokumentumunkhoz k\u00e9t n\u00e9zet kapcsol\u00f3dik, melyeket konzisztensen kell tartani. Megjegyz\u00e9s: a teljes \u00e9rt\u00e9k\u0171 megold\u00e1sban a bal oldali grafikus n\u00e9zetben is megval\u00f3s\u00edthatn\u00e1nk az eg\u00e9rkattint\u00e1sra t\u00f6rt\u00e9n\u0151 kijel\u00f6l\u00e9st. Ez jelent\u0151sen komplexebb\u00e9 tenn\u00e9 a k\u00e9s\u0151bbi feladataink megval\u00f3s\u00edt\u00e1s\u00e1t, \u00edgy ezt sz\u00e1nd\u00e9kosan kihagyjuk.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#megvalositando-funkciok","title":"Megval\u00f3s\u00edtand\u00f3 funkci\u00f3k","text":"<p>A k\u00f6vetkez\u0151 funkci\u00f3kat fogjuk a gyakorlat sor\u00e1n megval\u00f3s\u00edtani:</p> <ul> <li>\u00daj t\u00e9glalap \u00e9s \u00faj ellipszis l\u00e9trehoz\u00e1sa v\u00e9letlen poz\u00edci\u00f3ban. A funkci\u00f3k az eszk\u00f6zs\u00e1von (toolbar)  \u00e9s a Tools men\u00fc alatt is el\u00e9rhet\u0151k.</li> <li>Dokumentum tartalm\u00e1nak t\u00f6rl\u00e9se. Minden alakzatot elt\u00e1vol\u00edt a dokumentumb\u00f3l. File/Clear men\u00fcvel el\u00e9rhet\u0151.</li> <li>Visszavon\u00e1s (Undo). Az utols\u00f3 parancs visszavon\u00e1sa, ak\u00e1rh\u00e1ny l\u00e9p\u00e9sig visszamen\u0151en. Visszavonja az utols\u00f3 parancsot, legyen az valamilyen \u00faj alakzat l\u00e9trehoz\u00e1sa, vagy a dokumentum tartalm\u00e1nak t\u00f6rl\u00e9se. Az eszk\u00f6zs\u00e1von \u00e9s \u00e9s az Edit/Undo men\u00fcvel is el\u00e9rhet\u0151.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#a-solution-felepitese","title":"A solution fel\u00e9p\u00edt\u00e9se","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a kiindul\u00f3 k\u00f3db\u00e1zissal fogunk megismerkedni. Gyakorlatilag az architekt\u00far\u00e1nk komponens n\u00e9zet\u00e9t tekintj\u00fck \u00e1t ebben a l\u00e9p\u00e9sben. A Visual Studio Solution Explorer ablak\u00e1ban megfigyelhet\u0151, hogy solution\u00fcnk k\u00e9t projektet is tartalmaz.</p> <ul> <li><code>AppFx</code>: Egy oszt\u00e1lyk\u00f6nyvt\u00e1r (egy DLL a kimenete). Az ebben tal\u00e1lhat\u00f3 oszt\u00e1lyok \u00e1ltal\u00e1nos dokumentumkezel\u00e9si \u00e9s parancskezel\u00e9si szolg\u00e1ltat\u00e1sokat val\u00f3s\u00edtanak meg, melyek ak\u00e1r t\u00f6bb alkalmaz\u00e1sban is felhaszn\u00e1lhat\u00f3k. Az oszt\u00e1lyk\u00f6nyvt\u00e1r bevezet\u00e9s\u00e9vel az els\u0151dleges c\u00e9lunk teh\u00e1t az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g el\u00e9r\u00e9se.</li> <li><code>DesignPatternApp</code>: A futtathat\u00f3 (.exe) alkalmaz\u00e1sunk projektje, mely \u00e9p\u00edt az <code>AppFx</code> oszt\u00e1lyk\u00f6nyvt\u00e1rra.</li> </ul> <p>F\u00fcgg\u0151s\u00e9g a projektek k\u00f6z\u00f6tt</p> <p>Visual Studio projektek k\u00f6z\u00f6tt mindig csak egyir\u00e1ny\u00fa f\u00fcgg\u0151s\u00e9g lehet. Jelen esetben a DesignPatternApp \u00e9p\u00edt az <code>AppFx</code> projektre. Ezt a gyakorlatban \u00fagy val\u00f3s\u00edtottuk meg, hogy a DesignPatternApp projektben felvett\u00fcnk egy referenci\u00e1t az <code>AppFx</code> projektre. Ett\u0151l kezdve az DesignPatternApp-ban el\u00e9rhet\u0151k az <code>AppFx</code> (publikus) oszt\u00e1lyai. Ford\u00edtva viszont nem igaz az \u00e1ll\u00edt\u00e1s, \u00e9s ennek el\u00e9r\u00e9s\u00e9re nincs is m\u00f3d.</p>"},{"location":"labor/old-7-tervezesi-mintak/#document-view-architektura","title":"Document-View architekt\u00fara","text":"<p>Az alkalmaz\u00e1sunk a Document-View architekt\u00far\u00e1ra \u00e9p\u00fcl, annak n\u00e9mik\u00e9ppen tov\u00e1bbfejlesztett koncepci\u00f3j\u00e1t val\u00f3s\u00edtja meg: ahelyett, hogy a n\u00e9zeteknek egy <code>Update</code> m\u0171velete lenne, amelyen kereszt\u00fcl \u00e1ltal\u00e1nos v\u00e1ltoz\u00e1s \u00e9rtes\u00edt\u00e9st kapnak a dokumentumukt\u00f3l, a dokumentumok k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltoz\u00e1si esem\u00e9nyeket publik\u00e1lhatnak: minden n\u00e9zet arra az esem\u00e9nyre fizet el\u0151, \u00e9s arr\u00f3l kap \u00e9rtes\u00edt\u00e9st, mely sz\u00e1m\u00e1ra \u00e9rdekes.</p> <ul> <li>Az <code>AppFx</code> projekt DocView mapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 egy <code>Document</code> oszt\u00e1ly \u00e9s egy <code>IView</code> interf\u00e9sz. N\u00e9zz\u00fck meg \u0151ket sorban (nyissuk is meg a forr\u00e1sf\u00e1jlt):<ul> <li><code>Document</code>: K\u00fcl\u00f6nb\u00f6z\u0151 dokumentum t\u00edpusok \u0151soszt\u00e1lyak\u00e9nt szolg\u00e1lhat. T\u00f6bbek k\u00f6z\u00f6tt van egy n\u00e9zet list\u00e1ja. (Megjegyz\u00e9s: mivel alkalmaz\u00e1sunk a Document-View architekt\u00fara egy speci\u00e1lis vari\u00e1ns\u00e1t haszn\u00e1lja, a n\u00e9zet list\u00e1t az \u0151sb\u0151l el is hagyhattuk volna).</li> <li><code>IView</code>: K\u00fcl\u00f6nb\u00f6z\u0151 n\u00e9zet implement\u00e1ci\u00f3k k\u00f6z\u00f6s interf\u00e9sze. Nincs <code>Update</code> m\u0171velet, helyette egy <code>SetDocumentAndRegisterToDocEvents</code> m\u0171veletet tal\u00e1lunk (ebben kell a n\u00e9zetnek a dokumentum megfelel\u0151 esem\u00e9nyeire beregisztr\u00e1lnia).</li> </ul> </li> </ul> <p>A k\u00f6vetkez\u0151kben a <code>DesignPatternApp</code> projekt kapcsol\u00f3d\u00f3 oszt\u00e1lyait tekintj\u00fck \u00e1t:</p> <ul> <li> <p><code>DrawingDocument</code> oszt\u00e1ly</p> <ul> <li>Egy <code>shapes</code> nev\u0171 list\u00e1ban t\u00e1rolja az alakzatokat.</li> <li>A <code>selectedShape</code> az aktu\u00e1lisan kiv\u00e1lasztott alakzatra mutat.</li> <li>A dokumentum adatai a <code>Shapes</code>, <code>SelectedShape</code> \u00e9s <code>SelectedShapeIndex</code> tulajdons\u00e1gokon kereszt\u00fcl \u00e9rhet\u0151k el a k\u00fclvil\u00e1g (pl. n\u00e9zetek) sz\u00e1m\u00e1ra.</li> <li>A kor\u00e1bban ismertetett koncepci\u00f3nknak megfelel\u0151en a dokumentumunk k\u00e9t esem\u00e9nyt is publik\u00e1l, melyek C# esem\u00e9nyk\u00e9nt vannak megval\u00f3s\u00edtva:<ul> <li><code>ShapesChanged</code>: azt jelzi, hogy az alakzatok list\u00e1ja megv\u00e1ltozott, pl. \u00faj alakzattal b\u0151v\u00fclt, vagy kiker\u00fclt egy alakzat a list\u00e1b\u00f3l, vagy ak\u00e1r egy alakzat adatai v\u00e1ltoztak meg a list\u00e1ban.</li> <li><code>SelectionChanged</code>: azt jelzi, hogy egy kor\u00e1bbit\u00f3l elt\u00e9r\u0151 alakzat ker\u00fclt kiv\u00e1laszt\u00e1sra (mely piros sz\u00ednnel jelenik meg rajzol\u00e1skor).</li> </ul> </li> <li>A <code>CreateRect</code> \u00e9s <code>CreateEllipse</code> m\u0171veletek l\u00e9trehoznak egy megfelel\u0151 alakzatot, amit a dokumentum el is t\u00e1rol (\u00e9s term\u00e9szetesen el is s\u00fcti a <code>ShapesChanged</code> esem\u00e9nyt).</li> </ul> </li> <li> <p><code>ViewBase</code> oszt\u00e1ly</p> <ul> <li>A n\u00e9zeteink k\u00f6z\u00f6s \u0151soszt\u00e1lya, a k\u00f3dduplik\u00e1ci\u00f3 elker\u00fcl\u00e9s\u00e9re vezett\u00fck be. Implement\u00e1lja az <code>IView</code> interf\u00e9szt.</li> <li><code>UserControl</code>-b\u00f3l sz\u00e1rmazik (hasonl\u00f3 koncepci\u00f3t m\u00e1r l\u00e1ttunk a megel\u0151z\u0151 gyakorlat <code>FontEditor</code> p\u00e9ld\u00e1j\u00e1ban).</li> <li>A <code>document</code> tagv\u00e1ltoz\u00f3ban t\u00e1rolja a n\u00e9zetet.</li> <li>A dokumentum megfelel\u0151 esem\u00e9nyeire val\u00f3 fel/leiratkoz\u00e1shoz bevezeti a <code>RegisterToDocEvents</code> \u00e9s <code>UnRegisterToDocEvents</code> virtu\u00e1lis m\u0171veleteket, a lesz\u00e1rmazottakban ig\u00e9ny szerint kell implement\u00e1lni.</li> </ul> </li> <li><code>GraphicsView</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk bal oldali, grafikus n\u00e9zet\u00e9nek implement\u00e1ci\u00f3ja.</li> <li>A <code>ViewBase</code>-b\u0151l sz\u00e1rmazik, \u00edgy k\u00f6zvetve ezen oszt\u00e1lyunk is egy <code>UserControl</code>.</li> <li>A <code>RegisterToDocEvents</code> m\u0171velet\u00e9ben a dokumentum mindk\u00e9t esem\u00e9ny\u00e9re (<code>ShapesChanged</code> \u00e9s <code>SelectionChanged</code>) el\u0151fizet, ugyanazt a <code>DocumentOnShapesChanged</code> esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt regisztr\u00e1lja be. Az esem\u00e9nykezel\u0151ben egy egyszer\u0171 <code>Invalidate</code> h\u00edv\u00e1st tal\u00e1lunk, mely kik\u00e9nyszer\u00edti a n\u00e9zet\u00fcnk \u00fajrarajzol\u00e1s\u00e1t.</li> <li>Az <code>OnPaint</code> megval\u00f3s\u00edt\u00e1s\u00e1nak alapelve: minden alakzatra megh\u00edvjuk a <code>Draw</code> m\u0171veletet, mely gondoskodik a t\u00e9nyleges megjelen\u00edt\u00e9sr\u0151l.</li> </ul> </li> <li><code>InfoPanel</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk jobb oldali inform\u00e1ci\u00f3s panel n\u00e9zet\u00e9nek implement\u00e1ci\u00f3ja.</li> <li>Szint\u00e9n a <code>ViewBase</code>-b\u0151l sz\u00e1rmazik, \u00edgy k\u00f6zvetve ezen oszt\u00e1lyunk is egy UserControl.</li> <li>Az inform\u00e1ci\u00f3k megjelen\u00edt\u00e9s\u00e9re egy <code>ListBox</code> vez\u00e9rl\u0151t haszn\u00e1l.</li> <li>A <code>RegisterToDocEvents</code> m\u0171velet\u00e9ben \u0151 is feliratkozik a dokumentum mindk\u00e9t esem\u00e9ny\u00e9re:<ul> <li>Amikor a dokumentum ShapesChanged esem\u00e9nye s\u00fcl el, az InfoPanel <code>Document_ShapesChanged</code> m\u0171velete h\u00edv\u00f3dik meg: ebben friss\u00edti a listbox tartalm\u00e1t a dokumentum aktu\u00e1lis \u00e1llapot\u00e1nak megfelel\u0151en.</li> <li>Amikor a dokumentum SelectionChanged esem\u00e9nye s\u00fcl el, a <code>Document_SelectionChanged</code> h\u00edv\u00f3dik: ebben a listbox megfelel\u0151 elem\u00e9t \u00e1ll\u00edtjuk be kiv\u00e1lasztottnak.</li> </ul> </li> <li>Amikor a felhaszn\u00e1l\u00f3 egy \u00faj elemet v\u00e1laszt ki a listboxban, a <code>listBox_SelectedIndexChanged</code> esem\u00e9nykezel\u0151 h\u00edv\u00f3dik: ebben az <code>App.Instance.SetSelectedShape()</code> h\u00edv\u00e1ssal az aktu\u00e1lis dokumentumunkban \u00e1ll\u00edtjuk \u00e1t a kiv\u00e1lasztott alakzatot a listbox felhaszn\u00e1l\u00f3 \u00e1ltal kiv\u00e1lasztott sor\u00e1nak megfelel\u0151en.</li> </ul> </li> <li><code>Shape</code>, <code>Rect</code>, <code>Ellipse</code> oszt\u00e1lyok<ul> <li>A <code>Shape</code> a k\u00f6z\u00f6s \u0151s, az egyes alakzatok ennek lesz\u00e1rmazottai.</li> <li>A gyakorlat sor\u00e1n ezek k\u00f3dj\u00e1ra \u00e9ppen csak n\u00e9zz\u00fcnk r\u00e1, ezek implement\u00e1ci\u00f3s r\u00e9szletei sz\u00e1munkra most kev\u00e9sb\u00e9 izgalmasak. Megjegyz\u00e9s: Az egyik feladat megval\u00f3s\u00edt\u00e1sa sor\u00e1n m\u00e1solatot k\u00e9sz\u00edt\u00fcnk majd az alakzatokr\u00f3l. Annak \u00e9rdek\u00e9ben, hogy az alakzatot \u00e9s a m\u00e1solatait \u00f6ssze tudjuk \u201etal\u00e1ltatni\u201d, az egyes alakzatokhoz egy sz\u00e1mazonos\u00edt\u00f3t rendel\u00fcnk (<code>Id</code> tag), mely az alakzat \u00e9s m\u00e1solatai eset\u00e9ben ugyanazt az \u00e9rt\u00e9ket veszi fel.</li> </ul> </li> <li><code>App</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk \u201eroot\u201d oszt\u00e1lya, mag\u00e1t az alkalmaz\u00e1st reprezent\u00e1lja. Szerepe hasonl\u00f3, mint az el\u0151z\u0151 gyakorlat <code>FontEditor</code> p\u00e9ld\u00e1j\u00e1ban.</li> <li>Megval\u00f3s\u00edt\u00e1sa a <code>Singleton</code> tervez\u00e9si minta fontosabb elveit k\u00f6veti: egy p\u00e9ld\u00e1ny l\u00e9tezhet bel\u0151le, mely egy statikus <code>Instance</code> nev\u0171 tulajdons\u00e1gon kereszt\u00fcl \u00e9rhet\u0151 el, a konstruktora pedig v\u00e9dett.</li> <li>Mivel alkalmaz\u00e1sunkban egyszerre egy dokumentum lehet megnyitva (\u00fan. SDI, Single Document Interface application), egy jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9lhett\u00fcnk: a dokumentumunkb\u00f3l \u00e9s mindk\u00e9t n\u00e9zet t\u00edpusunkb\u00f3l egy-egy objektumra van csak sz\u00fcks\u00e9g. Ezekre az <code>App</code> oszt\u00e1lyunkban el is t\u00e1rolunk egy-egy hivatkoz\u00e1st az al\u00e1bbi tagv\u00e1ltoz\u00f3kban: <pre><code>    private DrawingDocument document;\n    private GraphicsView graphicsView;\n    private InfoPanel infoPanel;\n</code></pre></li> <li>Az <code>Initialize</code> m\u0171veletben lev\u0151 <code>CommandBindingManager</code> h\u00edv\u00e1sokra k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza.</li> </ul> </li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#command-binding","title":"Command Binding","text":"<p>A komplex felhaszn\u00e1l\u00f3 fel\u00fclettel rendelkez\u0151 alkalmaz\u00e1sok eset\u00e9n gyakran el\u0151fordul, hogy ugyanazt a parancsot k\u00fcl\u00f6nb\u00f6z\u0151 felhaszn\u00e1l\u00f3i fel\u00fcletelemekhez is hozz\u00e1 szeretn\u00e9nk k\u00f6tni. P\u00e9ld\u00e1ul New/Open/Close/Cut/Copy/stb. parancsok a legt\u00f6bb alkalmaz\u00e1sban egyar\u00e1nt el\u00e9rhet\u0151k men\u00fcb\u0151l \u00e9s eszk\u00f6zs\u00e1vr\u00f3l is. Vagyis a parancs \u00e9s a kiv\u00e1lt\u00f3 fel\u00fcletelemek k\u00f6z\u00f6tt egy-t\u00f6bb kapcsolat van.  Ilyen esetben egy adott parancs vonatkoz\u00e1s\u00e1ban a k\u00f6vetkez\u0151ket kell megval\u00f3s\u00edtani:</p> <ul> <li>Parancs futtat\u00e1sa. Ak\u00e1rmelyik fel\u00fcletelemet is aktiv\u00e1lja a felhaszn\u00e1l\u00f3, a parancshoz tartoz\u00f3 ugyanazon \u201eesem\u00e9nykezel\u0151\u201d k\u00f3dot kell futtatni. Ez a gyakorlatban egy adott f\u00fcggv\u00e9ny megh\u00edv\u00e1s\u00e1t jelenti.</li> <li>Fel\u00fcletelemek \u00e1llapotkezel\u00e9se. Adott parancs vonatkoz\u00e1s\u00e1ban valamennyi fel\u00fcletelem \u00e1llapot\u00e1t konzisztensen kell tartani. Vagyis ha pl. letiltjuk az Undo men\u00fct, mert nincs visszavonhat\u00f3 m\u0171velet, akkor a visszavon\u00e1sra szolg\u00e1l\u00f3 Undo toolbar gombot is le kell tiltani. Hasonl\u00f3k\u00e9ppen, ha egy men\u00fcelemet el akarunk rejteni, akkor a kapcsol\u00f3d\u00f3 toolbar gombot is rejteni kell. De m\u00e9g fel\u00fcletelemek kijel\u00f6lts\u00e9gi \u00e1llapot\u00e1t is akarhatjuk szab\u00e1lyozni, erre is \u00e9l a szab\u00e1lyunk.</li> </ul> <p>N\u00e9zz\u00fcnk erre p\u00e9ld\u00e1kat az alkalmaz\u00e1sunkban:</p> <ol> <li>Ind\u00edtsuk el az alkalmaz\u00e1st. Figyelj\u00fck meg, hogy a File men\u00fc alatt a Save/Save As/Close men\u00fcelemek \u00e9s az ezeknek megfelel\u0151 toolbar gombok (a Close a harmadik gomb a toolbaron) is le vannak tiltva: am\u00edg nem hoztunk l\u00e9tre vagy t\u00f6lt\u00f6tt\u00fcnk be dokumentumot, ezen parancsok futtat\u00e1s\u00e1nak nincs \u00e9rtelme.</li> <li>Hozzunk l\u00e9tre egy \u00faj dokumentumot (File/New men\u00fc). Ekkor valamennyi, az el\u0151z\u0151 pontban eml\u00edtett fel\u00fcletelem konzisztens m\u00f3don enged\u00e9lyezett lesz.</li> <li>Ha bez\u00e1rjuk a dokumentumot (File/Close men\u00fc), ism\u00e9t valamennyi fel\u00fcletelem tiltott lesz.</li> </ol> <p>Egy komplex alkalmaz\u00e1sban a fenti probl\u00e9mak\u00f6r egyszer\u0171 kezel\u00e9s\u00e9re c\u00e9lszer\u0171 egy k\u00f6zponti megold\u00e1st bevezetni. Ezt sz\u00e1mos m\u00f3don lehet implement\u00e1lni, a legt\u00f6bb k\u00f6rnyezet Command Binding n\u00e9ven hivatkozik a koncepci\u00f3ra. Sajnos az elnevez\u00e9s tekintet\u00e9ben nincs egys\u00e9gess\u00e9g: van olyan technol\u00f3gia, mely Command n\u00e9ven neves\u00edti ezt a technik\u00e1t. Mi Command minta alatt \u2013 a tervez\u00e9si mint\u00e1k klasszikus nevez\u00e9ktan\u00e1t k\u00f6vetve \u2013 m\u00e1st fogunk \u00e9rteni, egy k\u00e9s\u0151bbi feladatban t\u00e9r\u00fcnk majd r\u00e1.</p> <p>A Command Binding minta alapelvei:</p> <ul> <li>Minden felhaszn\u00e1l\u00f3i parancshoz egy k\u00f6zponti (<code>CommandBinding</code>) objektumot hozunk l\u00e9tre.</li> <li>Ehhez hozz\u00e1k\u00f6tj\u00fck a parancs aktiv\u00e1l\u00e1sakor futtatand\u00f3 esem\u00e9nykezel\u0151t.</li> <li>Hozz\u00e1k\u00f6tj\u00fck valamennyi aktiv\u00e1l\u00f3 fel\u00fcletelemet (men\u00fc, toolbar gomb stb.)</li> <li>Seg\u00e9dm\u0171veleteket vezet\u00fcnk be a parancsok tilt\u00e1s\u00e1ra/enged\u00e9lyez\u00e9s\u00e9re/elrejt\u00e9s\u00e9re/megjelen\u00edt\u00e9s\u00e9re.</li> <li>A parancsokat a k\u00f6nny\u0171 azonos\u00edt\u00e1s \u00e9rdek\u00e9ben valamilyen egyszer\u0171 m\u00f3don, tipikusan stringgel azonos\u00edtjuk.</li> </ul> <p>A solution\u00fcnk <code>AppFx</code> projektj\u00e9ben tal\u00e1lunk t\u00e1mogat\u00e1st a Command Binding megval\u00f3s\u00edt\u00e1s\u00e1ra (<code>CommandBinding</code> mappa). A megval\u00f3s\u00edt\u00e1s r\u00e9szletei sz\u00e1munkra teljesen \u00e9rdektelenek, gyakorlaton ne is n\u00e9zz\u00fck a k\u00f3dj\u00e1t, ink\u00e1bb a felhaszn\u00e1l\u00e1s\u00e1nak m\u00f3dj\u00e1t tekints\u00fck \u00e1t r\u00f6viden DesignPatternApp projekt\u00fcnkben:</p> <ul> <li>N\u00e9zz\u00fck meg a <code>CommandName</code> oszt\u00e1lyt: minden parancshoz egy string nevet vezett\u00fcnk be, mely a parancsot azonos\u00edtja (pl. \"Open\", \"Undo\" stb.).</li> <li>Inicializ\u00e1l\u00e1s: a <code>CommandBinding</code> objektumokat a <code>MainForm</code> oszt\u00e1ly <code>initCommandBindings</code> m\u0171veletben hozzuk l\u00e9tre \u00e9s k\u00f6tj\u00fck hozz\u00e1 az egyes men\u00fcelemekhez/toolbar gombokhoz. El\u00e9g, ha itt egy p\u00e9ld\u00e1t megn\u00e9z\u00fcnk a sok el\u0151fordul\u00e1s k\u00f6z\u00fcl.</li> <li>Ezt k\u00f6vet\u0151en adott parancshoz tartoz\u00f3 fel\u00fcletelemek \u00e1llapotai a <code>CommandBindingManager</code> oszt\u00e1ly \u00e1llapot\u00e1ll\u00edt\u00f3 seg\u00e9df\u00fcggv\u00e9nyeivel b\u00e1rmikor k\u00e9nyelmesen \u00e1ll\u00edthat\u00f3k (pl. <code>EnableCommandBinding</code> tilt\u00e1shoz/enged\u00e9lyez\u00e9shez). N\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik ez a Save/Save As/Close parancsok vonatkoz\u00e1s\u00e1ban:<ul> <li>Amikor az alkalmaz\u00e1s elindul, a parancsokat az <code>App</code> oszt\u00e1ly Initialize m\u0171velet\u00e9ben tiltjuk (a false m\u00e1sodik param\u00e9ter jelzi, hogy tiltani akarjuk a vez\u00e9rl\u0151t): <pre><code>CommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.CloseDocument, false);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveDocument, false);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveAsDocument, false);\n</code></pre></li> <li>A parancsok enged\u00e9lyez\u00e9s\u00e9re az <code>App.NewDocument</code>-ben l\u00e1tunk p\u00e9ld\u00e1t. Ez a m\u0171velet egy parancs esem\u00e9nykezel\u0151je, a t\u00f6bbi esem\u00e9nykezel\u0151vel egy\u00fctt az <code>App.CommandHandlers.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 (az App oszt\u00e1ly \u201epartial\u201d, t\u00f6bb f\u00e1jlban van meg\u00edrva). <pre><code>CommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.CloseDocument, true);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveDocument, true);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveAsDocument, true);\n</code></pre></li> </ul> </li> </ul> <p>A tov\u00e1bbi feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n is a <code>CommandBindingManager</code> oszt\u00e1lyunkat fogjuk haszn\u00e1lni a parancsok tilt\u00e1s\u00e1hoz \u00e9s enged\u00e9lyez\u00e9s\u00e9hez.</p>"},{"location":"labor/old-7-tervezesi-mintak/#2-feladat-command-processor-minta","title":"2. Feladat - Command Processor minta","text":"<p>A feladat sor\u00e1n a Command, pontosabban annak tov\u00e1bbfejlesztett v\u00e1ltozata, a Command Processor tervez\u00e9si minta megval\u00f3s\u00edt\u00e1s\u00e1t fogjuk gyakorolni. Mindk\u00e9t minta elm\u00e9leti h\u00e1tter\u00e9t a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1s ismerteti r\u00e9szletesen, UML diagramokkal illusztr\u00e1lva. A gyakorlat sor\u00e1n, \u00e9s \u00edgy jelen \u00fatmutat\u00f3ban is csak az elm\u00e9leti h\u00e1tt\u00e9r legfontosabb elemeire t\u00e9r\u00fcnk ki. L\u00e9nyeges, hogy a mint\u00e1t ne keverj\u00fck a m\u00e1r kor\u00e1bban ismertetett Command Binding mint\u00e1val, mert att\u00f3l elt\u00e9r\u0151 probl\u00e9m\u00e1ra mutat megold\u00e1st.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-command-processor-minta-koncepcioja","title":"A Command Processor minta koncepci\u00f3ja","text":"<p>A minta alapelve az, hogy minden felhaszn\u00e1l\u00f3i k\u00e9r\u00e9st egy k\u00fcl\u00f6n parancs (Command) objektumk\u00e9nt z\u00e1r egys\u00e9gbe. Ezen t\u00falmen\u0151en a v\u00e9grehajtott parancs objektumok elt\u00e1rol\u00e1sra ker\u00fclnek, ami lehet\u0151v\u00e9 teszi a kor\u00e1bban v\u00e9grehajtott parancsok visszavon\u00e1s\u00e1t. A k\u00f6vetkez\u0151kben \u00e1ttekintj\u00fck a minta m\u0171k\u00f6d\u00e9s\u00e9t. Els\u0151 l\u00e9p\u00e9sben m\u00e9g nem val\u00f3s\u00edtjuk meg, csak az alapelveire koncentr\u00e1lunk (b\u00e1r hogy k\u00f6nnyebben meg\u00e9rthet\u0151 legyen, a mint\u00e1t az alkalmaz\u00e1sunkra vet\u00edtve mutatjuk be). K\u00f6vetkezzen egy \u00e1bra, majd a hozz\u00e1 kapcsol\u00f3d\u00f3 gondolatok. </p> <p></p> <ul> <li>Bevezet\u00fcnk egy <code>Command</code> \u0151soszt\u00e1lyt vagy interf\u00e9szt, melynek van egy <code>Execute</code> \u00e9s egy <code>UnExecute</code> absztrakt m\u0171velete (vagy nevezhetj\u00fck <code>Do</code> \u00e9s <code>Undo</code>-nak is \u0151ket, ha \u00fagy tartja kedv\u00fcnk).</li> <li>Az egyes felhaszn\u00e1l\u00f3i parancsokhoz bevezet\u00fcnk egy Command lesz\u00e1rmazott oszt\u00e1lyt.<ul> <li>Els\u0151 k\u00f6rben a New Rect \u00e9s New Ellipse parancsokra vonatkoz\u00f3an k\u00edv\u00e1nunk Undo t\u00e1mogat\u00e1st bevezetni, \u00edgy ezekhez vezet\u00fcnk majd r\u00f6videsen be egy-egy \u00faj oszt\u00e1lyt, pl. <code>NewRectCommand</code> \u00e9s <code>NewEllipseCommand</code> n\u00e9ven.</li> <li>Ezen oszt\u00e1lyokban a parancsspecifikusan meg\u00edrjuk az <code>Execute</code> m\u0171veletet (pl. a <code>NewRectCommand.Execute</code>-ban felvesz\u00fcnk a dokumentumunkban egy \u00faj t\u00e9glalapot), az <code>UnExecute</code>-ban pedig visszacsin\u00e1ljuk a m\u0171velet hat\u00e1s\u00e1t. </li> <li>A <code>Command</code> lesz\u00e1rmazott oszt\u00e1lyok sokszor nem maguk val\u00f3s\u00edtj\u00e1k meg funkci\u00f3jukat, hanem deleg\u00e1lj\u00e1k azt egy vagy t\u00f6bb m\u00e1sik oszt\u00e1lynak. Ezt az oszt\u00e1lyt az UML diagramon Receiver n\u00e9ven t\u00fcntett\u00fck fel. A gyakorlatban nem \u00edgy szoktuk h\u00edvni. Alkalmaz\u00e1sunkban a Command-ok tipikusan az <code>App</code> oszt\u00e1lyba h\u00edvnak tov\u00e1bb, vagyis eset\u00fcnkben az <code>App</code> felel meg legt\u00f6bb esetben az \u00e1br\u00e1n szerepl\u0151 Receiver oszt\u00e1lynak.</li> </ul> </li> <li>Bevezet\u00fcnk egy k\u00f6zponti <code>CommandProcessor</code> oszt\u00e1lyt k\u00e9t m\u0171velettel:<ul> <li><code>ExecuteCommand</code>: v\u00e9grehajtja a param\u00e9ter\u00fcl kapott parancsot (megh\u00edvja az <code>Execute</code> m\u0171velet\u00e9t), majd elt\u00e1rolja egy bels\u0151 stack gy\u0171jtem\u00e9nyben.</li> <li><code>UnExecuteLastCommand</code>: kiveszi az utolj\u00e1ra v\u00e9grehajtott parancsot a command stack-b\u0151l, \u00e9s megh\u00edvja annak <code>UnExecute</code> m\u0171velet\u00e9t. Ezzel gyakorlatilag a parancs visszavon\u00e1s funkci\u00f3j\u00e1t (Undo) val\u00f3s\u00edtja meg.</li> </ul> </li> </ul> <p>L\u00e9nyeges, hogy a Command Binding mint\u00e1val ellent\u00e9tben itt a parancsok minden egyes futtat\u00e1s\u00e1hoz \u00faj Command objektumot hozunk l\u00e9tre, vagyis ha pl. h\u00e1romszor \u201efuttatjuk\" a <code>NewRectCommand</code> parancsot, akkor h\u00e1rom <code>NewRectCommand</code> objektumot hozunk ehhez l\u00e9tre. Ennek oka az, hogy a <code>CommandProcessor</code> command stack-j\u00e9ben h\u00e1rom parancsobjektumot kell elt\u00e1rolni (hiszen ezeket egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl akarjuk visszavonni Undo eset\u00e9n).</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-command-processor-minta-megvalositasa-alkalmazasunkban","title":"A Command Processor minta megval\u00f3s\u00edt\u00e1sa alkalmaz\u00e1sunkban","text":"<p>K\u00f6vess\u00fck az al\u00e1bbi l\u00e9p\u00e9seket:</p> <ol> <li>Az <code>AppFx</code> projekt Command mapp\u00e1j\u00e1ban m\u00e1r l\u00e9tezik egy absztrakt <code>Command</code> oszt\u00e1ly, \u00edgy ezzel nincs teend\u0151nk.</li> <li>A <code>Command</code> mapp\u00e1ban vegy\u00fck fel a parancsok menedzsel\u00e9s\u00e9\u00e9rt felel\u0151s az \u00e1ltal\u00e1nos <code>CommandProcessor</code> oszt\u00e1lyt: <pre><code>public class CommandProcessor\n{\n    Stack&lt;Command&gt; commands = new Stack&lt;Command&gt;();\n\n    public void ExecuteCommand(Command cmd)\n    {\n        cmd.Execute();\n        commands.Push(cmd);\n    }\n\n    public void UnExecuteLastCommand()\n    {\n        // Ha \u00fcres, nem csin\u00e1lunk semmit\n        if (!commands.Any())\n            return;\n\n        Command lastCommand = commands.Pop();\n        lastCommand.UnExecute();\n    }\n\n    public void Clear()\n    {\n      commands.Clear();\n    }\n\n    public bool HasAny { get { return commands.Any(); } }\n}\n</code></pre> A megval\u00f3s\u00edt\u00e1s sor\u00e1n a .NET be\u00e9p\u00edtett <code>Stack&lt;T&gt;</code> oszt\u00e1ly\u00e1t haszn\u00e1ljuk a command stack megval\u00f3s\u00edt\u00e1s\u00e1ra. A met\u00f3dusok implement\u00e1ci\u00f3ja egyszer\u0171, a kor\u00e1bban ismertetett logik\u00e1t k\u00f6veti.</li> <li>Integr\u00e1ljuk be a <code>CommandProcessor</code> oszt\u00e1lyt az alkalmaz\u00e1sunkba. Vegy\u00fcnk fel egy tagv\u00e1ltoz\u00f3t az <code>App</code> oszt\u00e1lyba: <pre><code>readonly CommandProcessor commandProcessor = new CommandProcessor();\n</code></pre> Annak \u00e9rdek\u00e9ben, hogy ez forduljon, a forr\u00e1sf\u00e1jlban az <code>AppFx.Command</code> n\u00e9vteret \u201eusing-olni\u201d kell.</li> <li>Az <code>App.CommandHandlers.cs</code>-be a <code>CloseDocument</code> v\u00e9g\u00e9re vegy\u00fck fel ezt a sort: <pre><code>commandProcessor.Clear();\n</code></pre> Ennek az a szerepe, hogy amikor bez\u00e1rjuk a dokumentumot, kipucoljuk az undo sort, hiszen a benne lev\u0151 elemek egy m\u00e1r bez\u00e1rt, nem l\u00e9tez\u0151 dokumentumra vonatkoznak.</li> <li>Amikor egy parancsot futtatunk vagy visszavonunk, az Undo men\u00fct \u00e9s toolbar gombot is megfelel\u0151en tiltani vagy enged\u00e9lyezni kell: ha van legal\u00e1bb egy command a command stack-en, akkor enged\u00e9lyezz\u00fck, egy\u00e9bk\u00e9nt tiltjuk. Vezess\u00fcnk be egy-egy seg\u00e9df\u00fcggv\u00e9nyt az App oszt\u00e1lyba a parancsok futtat\u00e1s\u00e1hoz \u00e9s visszavon\u00e1s\u00e1hoz, melyek a kor\u00e1bban ismertetett CommandBindingManager oszt\u00e1lyunk seg\u00edts\u00e9g\u00e9vel gondoskodnak az Undo tilt\u00e1s\u00e1r\u00f3l/enged\u00e9lyez\u00e9s\u00e9r\u0151l is: <pre><code>void executeCommand(Command cmd)\n{\n    commandProcessor.ExecuteCommand(cmd);\n    CommandBindingManager.Instance.EnableCommandBinding(\n                    CommandName.Undo, commandProcessor.HasAny);\n}\n</code></pre> <pre><code>void unexecuteLastCommand()\n{\n    commandProcessor.UnExecuteLastCommand();\n    CommandBindingManager.Instance.EnableCommandBinding(\n                    CommandName.Undo, commandProcessor.HasAny);\n}\n</code></pre> Az <code>unexecuteLastCommand</code> m\u0171veletet akkor kell megh\u00edvni, amikor a felhaszn\u00e1l\u00f3 az Undo funkci\u00f3t aktiv\u00e1lja. Az <code>App.CommandHandlers.cs</code> f\u00e1jlban lev\u0151 UndoLast met\u00f3dus egy <code>CommandBinding</code> seg\u00edts\u00e9g\u00e9vel m\u00e1r hozz\u00e1 van k\u00f6tve a fel\u00fcletelemekhez (Undo men\u00fc \u00e9s toolbar gomb), \u00edgy aktiv\u00e1l\u00e1sukkor meg is h\u00edv\u00f3dik. M\u00e1r csak az a dolgunk, hogy \u00e1t\u00edrjuk az <code>UndoLast</code> t\u00f6rzs\u00e9t: <pre><code>public void UndoLast()\n{\n    unexecuteLastCommand();\n}\n</code></pre></li> <li>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben Command lesz\u00e1rmazott oszt\u00e1lyokat hozunk l\u00e9tre az egyes alkalmaz\u00e1sspecifikus parancsokhoz. A <code>DesignPatternApp</code> projektben vegy\u00fcnk fel egy <code>Commands</code> nev\u0171 mapp\u00e1t (jobb katt a projekten, Add/New Folder men\u00fc), ebbe fogjuk az ide tartoz\u00f3 oszt\u00e1lyokat \u00f6sszegy\u0171jteni.</li> <li>Ebbe a <code>Commands</code> mapp\u00e1ba vegy\u00fcnk fel egy <code>NewRectCommand</code> oszt\u00e1lyt a \u201eNew Rect\u201d funkci\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1hoz, a k\u00f6vetkez\u0151 k\u00f3ddal: <pre><code>using AppFx.Command;\n\u2026\n\nclass NewRectCommand : Command\n{\n    private int shapeId;\n\n    public override void Execute()\n    {\n        shapeId = App.Instance.CreateRandomRect().Id;\n    }\n\n    public override void UnExecute()\n    {\n        App.Instance.RemoveShape(shapeId);\n    }\n}\n</code></pre> Az <code>Execute</code> m\u0171velet megh\u00edvja az <code>App</code> singleton <code>CreateRandomRect</code> m\u0171velet\u00e9t, amely felvesz egy \u00faj <code>Rectangle</code> objektumot a dokumentumban, v\u00e9letlenszer\u0171en gener\u00e1lt befoglal\u00f3 t\u00e9glalapban, \u00e9s visszat\u00e9r vele. Az \u00fajonnan l\u00e9trehozott <code>Rect</code> objektumra a <code>NewRectCommand</code> elt\u00e1rolja az alakzat azonos\u00edt\u00f3j\u00e1t a <code>shapeId</code> tagv\u00e1ltoz\u00f3ban. (Jelen pillanatban egy referencia t\u00e1rol\u00e1sa is el\u00e9g lenne, de mikor k\u00e9s\u0151bb a Memento megval\u00f3s\u00edt\u00e1sa sor\u00e1n m\u00e1solatot k\u00e9sz\u00edt\u00fcnk az alakzat objektumokr\u00f3l, a referencia haszn\u00e1lata m\u00e1r nem jelentene megold\u00e1st.) Az <code>UnExecute</code> m\u0171veletben az App singleton <code>RemoveShape</code> m\u0171velet\u00e9nek seg\u00edts\u00e9g\u00e9vel elt\u00e1vol\u00edtjuk a parancs \u00e1ltal l\u00e9trehozott alakzatot, \u00edgy visszavonjuk annak hat\u00e1s\u00e1t (n\u00e9zz\u00fck meg a k\u00f3dban, hogyan van megval\u00f3s\u00edtva).</li> <li>Vegy\u00fcnk fel a <code>Commands</code> mapp\u00e1ba egy <code>NewEllipseCommand</code> oszt\u00e1lyt, \u00e9s implement\u00e1ljuk a <code>NewRectCommand</code>-hoz hasonl\u00f3 elveknek megfelel\u0151en: <pre><code>using AppFx.Command;\n\nclass NewEllipseCommand : Command\n{\n    private int shapeId;\n\n    public override void Execute()\n    {\n        shapeId = App.Instance.CreateRandomEllipse().Id;\n    }\n\n    public override void UnExecute()\n    {\n        App.Instance.RemoveShape(shapeId);\n    }\n}\n</code></pre></li> <li>A <code>NewRectCommand</code> \u00e9s <code>NewEllipseCommand</code> oszt\u00e1lyainkat m\u00e9g nem haszn\u00e1ljuk sehol, most ezek bevet\u00e9se k\u00f6vetkezik. Amikor a felhaszn\u00e1l\u00f3 ak\u00e1r men\u00fcb\u0151l, ak\u00e1r toolbarr\u00f3l aktiv\u00e1lja a New Rect funkci\u00f3t, l\u00e9tre kell hozzunk egy NewRectCommand objektumot, \u00e9s futtatni kell seg\u00e9dm\u0171veleteink felhaszn\u00e1l\u00e1s\u00e1val. Keress\u00fck meg az <code>App.CommandHandlers.cs</code> f\u00e1jlban a <code>NewRect</code> met\u00f3dust. Ez egy <code>CommandBinding</code> seg\u00edts\u00e9g\u00e9vel m\u00e1r r\u00e1 van k\u00f6tve a megfelel\u0151 men\u00fcre/toolbar gombra, csak a t\u00f6rzs\u00e9ben lev\u0151 <code>showNotImplemented()</code> h\u00edv\u00e1st kell lecser\u00e9lni: <pre><code>using DesignPatternApp.Commands;\n\u2026\npublic void NewRect()\n{\n    executeCommand( new NewRectCommand() );\n}\n</code></pre> Ehhez hasonl\u00f3an alak\u00edtsuk \u00e1t a <code>NewRect</code> mellett tal\u00e1lhat\u00f3 <code>NewEllipse</code> m\u0171veletet is: <pre><code>public void NewEllipse()\n{\n    executeCommand( new NewEllipseCommand() );\n}\n</code></pre></li> <li>Mostant\u00f3l tudunk \u00faj alakzatokat l\u00e9trehozni, \u00edgy \u00faj dokumentum l\u00e9trehoz\u00e1sakor tesztadatok automatikus felv\u00e9tel\u00e9re nincs sz\u00fcks\u00e9g: az App.NewDocument m\u0171veletben kommentezz\u00fck ki az <code>addTestData</code> h\u00edv\u00e1s\u00e1t.</li> </ol> <p>Elk\u00e9sz\u00fclt\u00fcnk, tesztelj\u00fck a megold\u00e1sunkat:</p> <ol> <li>Futtassuk az alkalmaz\u00e1st, \u00e9s hozzunk l\u00e9tre egy dokumentumot.</li> <li>Figyelj\u00fck meg, hogy az Undo parancs (toolbar \u00e9s men\u00fc is) tiltva van.</li> <li>A New Rect paranccsal hozzunk l\u00e9tre egy \u00faj t\u00e9glalapot. A t\u00e9glalap megjelenik, \u00e9s az Undo parancs enged\u00e9lyezett lesz.</li> <li>Hozzunk l\u00e9tre n\u00e9h\u00e1ny tov\u00e1bbi alakzatot, t\u00e9glalapot \u00e9s ellipszist vegyesen.</li> <li>Az Undo funkci\u00f3 haszn\u00e1lat\u00e1val vonjuk vissza a m\u0171veleteket mindaddig, am\u00edg nem marad alakzat: ekkor az Undo parancs letilt\u00e1sra ker\u00fcl.</li> </ol> <p>Amennyiben a gyakorlat sor\u00e1n j\u00f3l \u00e1llunk id\u0151vel, a k\u00f3dot l\u00e9p\u00e9senk\u00e9nt futtatva is n\u00e9zz\u00fck vissza megold\u00e1sunk m\u0171k\u00f6d\u00e9s\u00e9t:</p> <ol> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot az <code>App.CommandHandlers.cs</code>-ben tal\u00e1lhat\u00f3 <code>NewRect</code> \u00e9s <code>UndoLast</code> m\u0171veletek t\u00f6rzs\u00e9be (mindk\u00e9t m\u0171velet egysoros).</li> <li>Ind\u00edtsuk el debug m\u00f3dban az alkalmaz\u00e1st (F5).</li> <li>Hozzunk l\u00e9tre egy dokumentumot, majd egy t\u00e9glalapot. A <code>NewRect</code> k\u00f3dj\u00e1b\u00f3l kiindulva az F11 billenty\u0171vel az <code>executeCommand</code> \u00e9s a <code>CommandProcessor</code> m\u0171veleteibe belel\u00e9pve \u201e\u00e9rtelmezz\u00fck\u201d megold\u00e1sunkat.</li> <li>Ezt k\u00f6vet\u0151en vonjuk vissza az utols\u00f3 m\u0171veletet. Ekkor az <code>UndoLast</code> m\u0171veletb\u0151l kiindulva l\u00e9pkedj\u00fcnk v\u00e9gig a k\u00f3dunkon.</li> </ol>"},{"location":"labor/old-7-tervezesi-mintak/#3-feladat-memento-minta","title":"3. Feladat \u2013 Memento minta","text":"<p>A feladatban a Memento minta megval\u00f3s\u00edt\u00e1s\u00e1t gyakoroljuk. A minta teljes elm\u00e9leti h\u00e1ttere \u2013 UML diagramokkal illusztr\u00e1lva - el\u0151ad\u00e1son ker\u00fcl ismertet\u00e9sre, itt a minta legfontosabb elemeire koncentr\u00e1lunk.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-memento-minta-koncepcioja","title":"A Memento minta koncepci\u00f3ja","text":"<p>El\u0151z\u0151 feladatunkban a New Rect \u00e9s New Ellipse parancsok visszavon\u00e1s\u00e1t k\u00f6nnyen meg tudtuk val\u00f3s\u00edtani: mind\u00f6ssze el kellett t\u00e1vol\u00edtani a parancs \u00e1ltal l\u00e9trehozott alakzatot a dokumentum alakzatlist\u00e1j\u00e1b\u00f3l. A command objektumainkban ehhez el\u00e9g volt egy azonos\u00edt\u00f3t elt\u00e1rolni az \u00fajonnan l\u00e9trehozott alakzatra.</p> <p>Az alkalmaz\u00e1sok t\u00f6bbs\u00e9g\u00e9n\u00e9l azonban sz\u00e1mos olyan parancs felbukkanhat, mely a dokumentum \u00e1llapot\u00e1t jelent\u0151s m\u00e9rt\u00e9kben befoly\u00e1solja. Ilyenkor a parancsnak a v\u00e9grehajt\u00e1s el\u0151tt a dokumentum \u00e1llapot\u00e1nak jelent\u0151s r\u00e9sz\u00e9hez, vagy ak\u00e1r a teljes \u00e1llapot\u00e1hoz is hozz\u00e1 kell f\u00e9rnie, hogy eltudja azt menteni az UnExecute megval\u00f3s\u00edt\u00e1s\u00e1hoz. Ez \u00fagy lehets\u00e9ges, ha a dokumentum teljes \u00e1llapot\u00e1t publikuss\u00e1 tessz\u00fck. Ez viszont nem szerencs\u00e9s, mert ellentmond az egys\u00e9gbez\u00e1r\u00e1s elv\u00e9nek. Nem szeretn\u00e9nk a teljes \u00e1llapotot \u2013 r\u00e1ad\u00e1sul m\u00f3dos\u00edt\u00e1sra vonatkoz\u00f3an is \u2013 hozz\u00e1f\u00e9rhet\u0151v\u00e9 tenni a k\u00fclvil\u00e1g sz\u00e1m\u00e1ra, csak a visszavon\u00e1s kedv\u00e9\u00e9rt.  Erre a probl\u00e9m\u00e1ra ny\u00fajt megold\u00e1st a Memento tervez\u00e9si minta.</p> <p>Alapelve egy mondatban: dokumentumunk \u00e1llapot\u00e1t egy \u00fan. Memento objektumba csomagoljuk be, hogy az k\u00e9s\u0151bb a visszavon\u00e1s sor\u00e1n vissza\u00e1ll\u00edthat\u00f3 legyen.</p> <p>K\u00f6vetkezzen egy \u00e1bra, majd a hozz\u00e1 kapcsol\u00f3d\u00f3 gondolatok.</p> <p></p> <p>Alapelve r\u00e9szletesebben: - Az <code>Originator</code> azon oszt\u00e1ly, melynek az \u00e1llapot\u00e1hoz hozz\u00e1 szeretn\u00e9nk f\u00e9rni. Eset\u00fcnkben ez a <code>DrawingDocument</code> oszt\u00e1ly t\u00f6lti be az <code>Originator</code> szerep\u00e9t. Az \u00e1llapotot \u00f6sszefog\u00f3an az \u00e1bra a <code>state:State</code> taggal jel\u00f6li. Eset\u00fcnkben ez a <code>shapes</code> lista, valamint a <code>selectedShape</code> tag lesz.  A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekt\u0151l a mint\u00e1t az alkalmaz\u00e1sunkra vet\u00edtj\u00fck. - A dokumentumunk \u00e1llapot\u00e1t (eset\u00fcnkben ez a <code>shapes</code> lista, valamit a <code>selectedShape</code> tag) NEM tessz\u00fck publikuss\u00e1. - A dokumentumunkban bevezet\u00fcnk egy <code>CreateMemento</code> m\u0171veletet, mely egy \u00fan. <code>Memento</code> objektumot hoz l\u00e9tre. A <code>Memento</code> tagv\u00e1ltoz\u00f3iban a dokumentum \u00e1llapot\u00e1nak pillanatnyi k\u00e9p\u00e9t tartalmazza (vagyis tulajdonk\u00e9ppen egy csomagol\u00f3 objektum a dokumentum aktu\u00e1lis \u00e1llapot\u00e1hoz). - A dokumentum \u00e1llapot\u00e1nak vissza\u00e1ll\u00edt\u00e1s\u00e1ra bevezet\u00fcnk a dokumentumban egy <code>RestoreFromMemento</code> m\u0171veletet, mely param\u00e9terk\u00e9nt egy <code>Memento</code> objektumot kap. A dokumentum ebben a m\u0171veletben vissza\u00e1ll\u00edtja saj\u00e1t \u00e1llapot\u00e1t a param\u00e9terk\u00e9nt kapott <code>Memento</code> objektum alapj\u00e1n.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-memento-minta-megvalositasa-alkalmazasunkban","title":"A Memento minta megval\u00f3s\u00edt\u00e1sa alkalmaz\u00e1sunkban","text":"<p>Alkalmaz\u00e1sunkban a Clear funkci\u00f3t val\u00f3s\u00edtjuk meg a Memento mint\u00e1ra \u00e9p\u00edtve. A Clear parancs t\u00f6rli a dokumentumb\u00f3l az \u00f6sszes alakzatot. Annak \u00e9rdek\u00e9ken, hogy ez visszavonhat\u00f3 legyen, a dokumentumunk teljes \u00e1llapot\u00e1t el kell menteni a parancs v\u00e9grehajt\u00e1sa el\u0151tt. Ehhez a <code>DrawingDocument</code> oszt\u00e1lyunk \u00e1llapot\u00e1t jelent\u0151 shapes tagot NEM fogjuk publikuss\u00e1 tenni. M\u00e9g k\u00f6zvetve, property-n/m\u0171veleten kereszt\u00fcl sem tessz\u00fck m\u00f3dos\u00edthat\u00f3v\u00e1!</p> <p>Warning</p> <p>Amennyiben kev\u00e9s id\u0151 maradt gyakorlaton, nyissuk meg a k\u00e9sz megold\u00e1st, \u00e9s abban mutassuk be a megval\u00f3s\u00edt\u00e1s r\u00e9szleteit!</p> <ul> <li> <p>A dokumentum \u00e1llapot\u00e1t t\u00e1rol\u00f3 Memento oszt\u00e1lyt egy a <code>DrawingDocument</code>-be be\u00e1gyazott oszt\u00e1lyk\u00e9nt val\u00f3s\u00edtjuk meg, ezzel is hangs\u00falyozva, hogy <code>Memento</code> oszt\u00e1lyunk nagyon szorosan kapcsol\u00f3dik a dokumentumhoz. Forr\u00e1sk\u00f3d szintj\u00e9n viszont igyeksz\u00fcnk lev\u00e1lasztani, \u00edgy a DrawingDocument oszt\u00e1lyt partial class-ra alak\u00edtva k\u00fcl\u00f6n f\u00e1jlban dolgozunk.</p> <ul> <li>Alak\u00edtsuk a <code>DrawingDocument</code>-et partial class-\u00e1: <pre><code>public partial class DrawingDocument\n</code></pre></li> <li>Vegy\u00fcnk fel egy <code>DrawingDocument.Memento.cs</code> f\u00e1jlt a <code>DesignPatternApp</code> projektbe (jobb katt a projekten, Add/New Item, \u00e9s a megjelen\u0151 ablakban a Code File-t v\u00e1lasszuk ki).</li> <li> <p>Illessz\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet a f\u00e1jlba:</p> DrawingDocument.Memento.cs <pre><code>using System.Collections.Generic;\n\nnamespace DesignPatternApp\n{\n    public partial class DrawingDocument\n    {\n        public class Memento\n        {\n            private List&lt;Shape&gt; shapes = new List&lt;Shape&gt;();\n            private Shape selectedShape;\n\n            public Memento(List&lt;Shape&gt; shapes, Shape selectedShape)\n            {\n                // Deep copyra van sz\u00fcks\u00e9g\u00fcnk!\n                foreach (Shape shape in shapes)\n                    this.shapes.Add(shape.CreateCopy());\n\n                // Be kell \u00e1ll\u00edtsuk selectedShape-nek. Az \u00faj Shape list\u00e1ban kell a megfelel\u00f5\n                // elemre hivatkoznia, nem az eredetiben. Be kell \u00e1ll\u00edtsuk.\n                this.selectedShape = null;\n                for (int i = 0; i &lt; shapes.Count; ++i)\n                    if (shapes[i] == selectedShape)\n                    {\n                        this.selectedShape = this.shapes[i];\n                        break;\n                    }\n            }\n\n            public void GetState(out List&lt;Shape&gt; shapes, out Shape selectedShape)\n            {\n                shapes = this.shapes;\n                selectedShape = this.selectedShape;\n            }\n        }\n\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>A <code>Memento</code> oszt\u00e1lyunk legfontosabb aspektusai:</p> <ul> <li>Pontosan olyan tagv\u00e1ltoz\u00f3i vannak, mint a dokumentum oszt\u00e1lyunknak: \u00edgy tudja annak teljes \u00e1llapot\u00e1t elt\u00e1rolni.</li> <li>Konstruktor\u00e1ban a dokumentum \u00e1llapotv\u00e1ltoz\u00f3it v\u00e1rja (<code>shapes</code> \u00e9s <code>selectedShape</code>). L\u00e9nyeges, hogy a <code>shapes</code> list\u00e1r\u00f3l deep-copy m\u00e1solatot k\u00e9sz\u00edt: ha csak referenci\u00e1kat t\u00e1rolna a dokumentumban lev\u0151 objektumokra, akkor a dokumentum v\u00e1ltoz\u00e1s\u00e1val a memento objektumunk \u00e1llapota is v\u00e1ltozna. Nek\u00fcnk viszont az aktu\u00e1lis \u00e1llapot meg\u0151rz\u00e9se a c\u00e9lunk.</li> <li>A <code>GetState</code>-ben k\u00e9t out param\u00e9terben visszaadja az elmentett \u00e1llapotot. Az Undo m\u0171velet sor\u00e1n fogjuk ezt haszn\u00e1lni.</li> </ul> </li> <li> <p>Emelj\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet a <code>DrawingDocument.cs</code> f\u00e1jlba a <code>DrawingDocument</code> oszt\u00e1lyba:</p> DrawingDocument.cs f\u00e1jlba <pre><code>public Memento CreateMemento()\n{\n    return new Memento(shapes, selectedShape);\n}\n\npublic void RestoreFromMemento(Memento m)\n{\n    m.GetState(out shapes, out selectedShape);\n    fireShapesChanged();\n    fireSelectionChanged();\n}\n</code></pre> <p>A <code>CreateMemento</code> m\u0171velet a mint\u00e1nak megfelel\u0151en legy\u00e1rt egy <code>Memento</code> objektumot a dokumentum \u00e1llapot\u00e1r\u00f3l. A <code>RestoreFromMemento</code> pedig a param\u00e9ter\u00fcl kapott <code>Memento</code> objektum alapj\u00e1n vissza\u00e1ll\u00edtja a dokumentum \u00e1llapot\u00e1t.</p> </li> </ul> <p>Ezzel a Memento t\u00e1mogat\u00e1s be\u00e9p\u00edt\u00e9s\u00e9vel v\u00e9gezt\u00fcnk. Ugyanakkor jelen pillanatban egyetlen parancsunk sem haszn\u00e1lja ezt a szolg\u00e1ltat\u00e1st.  Mint kor\u00e1bban eml\u00edtett\u00fck, a Clear funkci\u00f3t val\u00f3s\u00edtjuk meg a Memento mint\u00e1ra \u00e9p\u00edtve.</p> <ul> <li>Vegy\u00fcnk fel egy <code>ClearCommand</code> oszt\u00e1lyt a <code>DesignPatternApp</code> projekt <code>Commands</code> mapp\u00e1j\u00e1ban.</li> <li> <p>Emelj\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet az \u00faj <code>ClearCommand.cs</code> f\u00e1jlba:</p> ClearCommand.cs <pre><code>class ClearCommand: Command\n{\n    DrawingDocument.Memento memento = null;\n\n    public override void Execute()\n    {\n        if (App.Instance.Document == null)\n            return;\n\n        memento = App.Instance.Document.CreateMemento();\n        App.Instance.Document.Clear();\n    }\n\n    public override void UnExecute()\n    {\n        if (App.Instance.Document == null)\n            return;\n\n        App.Instance.Document.RestoreFromMemento(memento);\n    }\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel a f\u00e1jl elej\u00e9re ez al\u00e1bbi sort: <pre><code>using AppFx.Command;\n</code></pre></p> </li> <li>Az <code>App.CommandHandlers.cs</code> f\u00e1jlban a <code>ClearDocument</code> m\u0171veletet \u00edrjuk \u00e1t, hogy most m\u00e1r az \u00fajonnan l\u00e9trehozott <code>ClearCommand</code> parancsunkat \u201efuttassa\u201d: <pre><code>public void ClearDocument()\n{\n    executeCommand(new ClearCommand());\n}\n</code></pre></li> </ul> <p>Tesztelj\u00fck megold\u00e1sunkat:</p> <ul> <li>Futtassuk az alkalmaz\u00e1st,</li> <li>Hozzunk l\u00e9tre p\u00e1r alakzatot,</li> <li>A File/Clear men\u00fcb\u0151l futtassuk a Clear parancsot: az alakzataink elt\u0171nnek.</li> <li>Az Undo paranccsal vonjuk vissza a parancsot: az alakzatok \u00fajra megjelennek.</li> </ul> <p>L\u00e9p\u00e9senk\u00e9nt futtatva is tesztelj\u00fck a megold\u00e1st:</p> <ul> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot a <code>ClearCommand.Execute</code> m\u0171velet els\u0151 sor\u00e1ra.</li> <li>Ind\u00edtsuk ez az alkalmaz\u00e1st, hozzunk l\u00e9tre p\u00e1r alakzatot, majd a File/Clear men\u00fcb\u0151l futtassuk a Clear parancsot.</li> <li>Mikor a k\u00f3dunk meg\u00e1ll a t\u00f6r\u00e9spontn\u00e1l, l\u00e9pkedj\u00fck el a <code>CreateMemento</code> h\u00edv\u00e1s\u00e1ig, \u00e9s l\u00e9pj\u00fcnk is \u00e1t rajta. A <code>CreateMemento</code> \u00e1ltal visszaadott memento objektum bels\u0151 \u00e1llapot\u00e1t n\u00e9zz\u00fck meg vagy a Watch ablakban, vagy tooltipben r\u00e1\u00e1llva. Azt l\u00e1tjuk, hogy val\u00f3ban \u201etartalmazza\u201d a dokumentum pillanatnyi \u00e1llapot\u00e1t a shapes \u00e9s <code>selectedShape</code> tagv\u00e1ltoz\u00f3j\u00e1ban. A <code>ClearCommand</code> ezt el is t\u00e1rolja a tagv\u00e1ltoz\u00f3j\u00e1ban, amit az <code>UnExecute</code> m\u0171veletben haszn\u00e1l fel a dokumentum \u00e1llapot\u00e1nak vissza\u00e1ll\u00edt\u00e1s\u00e1ra.</li> </ul> <p>P\u00e9ld\u00e1nkban a Memento minta arra \u00e9p\u00edt, hogy a dokumentum teljes \u00e1llapot\u00e1r\u00f3l m\u00e1solatot k\u00e9sz\u00edt\u00fcnk. Sok alkalmaz\u00e1s, illetve nagym\u00e9ret\u0171 dokumentum eset\u00e9ben ennek nagyon nagy lehet a mem\u00f3riaig\u00e9nye. Milyen megold\u00e1sokban gondolkozhatunk a probl\u00e9ma elker\u00fcl\u00e9s\u00e9re?</p> <ul> <li>A kisebb v\u00e1ltoz\u00e1sok hat\u00e1s\u00e1t ink\u00e1bb \u201einverz\u201d m\u0171velettel pr\u00f3b\u00e1ljuk visszacsin\u00e1lni. Ezt alkalmaztuk pl. a New Rect parancs eset\u00e9ben.</li> <li>A Memento-ba nem mentj\u00fck bele a teljes \u00e1llapotot, hanem csak m\u00f3dosult \u00e1llapotot. Sajnos ez nem mindig tehet\u0151 meg, valamint nehezebben karbantarthat\u00f3 megold\u00e1st eredm\u00e9nyez.</li> <li>Korl\u00e1tozzuk a visszavonhat\u00f3 l\u00e9p\u00e9sek sz\u00e1m\u00e1t.</li> </ul>"}]}